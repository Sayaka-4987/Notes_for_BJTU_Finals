汇编与接口技术笔记

期末考试开卷、50% + 平时成绩20% + 常规实验15% + 研究性实验15%

地点：**YF312** 或九教 4 层实验室

- #### 这份笔记画 ※ 的都要背！

- #### 做实验 **<u>需要在上机前就编写完程序</u>** ！！




## 汇编网络参考资料

[8086汇编语言初学者教程](https://www.cnblogs.com/QuLory/archive/2012/11/07/2758048.html) （点击 [#补充资料8086-汇编语言初学者教程](https://github.com/Sayaka-4987/Notes_for_BJTU_Finals/blob/main/21-Fall-%E6%B1%87%E7%BC%96%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0.md#%E8%A1%A5%E5%85%85%E8%B5%84%E6%96%998086-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%88%9D%E5%AD%A6%E8%80%85%E6%95%99%E7%A8%8B) 可以跳转到本笔记的这一部分）



# 汇编部分



## 1. 基础知识

### 1.2 硬件接口

~~（这段抄的 zll 的，后面还一段也是，不想打字惹）~~

CPU与接口交换数据的方式：

1. **查询方式**

信息交换的控制完全由主机执行程序实现，程序查询方式接口中设置一个数据缓冲寄存器（数据端口）和一个设备状态寄存器（状态顿口）；

主机进行 I/O 操作时，先发出询问信号，读取设备的状态，并根据设备状态决定下一步操作究竟是进行数据传送还是等待。在这种控制方式下，CPU 一旦启动 I/O，就必须停止现行程序的运行，并在现行程序中插入一段程序；

CPU 要花费很多时间来查询和等待，而且在一段时间内只能与一台外设交换信息，效率低；

2. **中断方式**

CPU在程序中安排好于某个时刻启动某台外设，然后CPU继续执行原来的程序，不需要像查询方式一样一直等待外设准备就绪；

一旦外设完成数据传送的准备工作，就主动向CPU发出中断请求，请求CPU为自己服务；在可以响应中断的条件下，CPU暂时中止正在执行的程序，转去执行中断服务程序为外设服务，在终端服务程序中完成一次主机与外设之间的数据传送，传送完成后，CPU返回原来的程序；

3. **DMA 方式**

主存和 DMA 接口之间有一条直接的数据通路；

DMA 方式传送数据不需要经过CPU，因此不必中断现行程序，I/O与主机并行工作，程序和传送并行工作。



## 2. 80x86 计算机组织

本课程以 16 位的 8086 作为教学对象；



### 2.1 计算机系统

微处理器就是把 **运算器、寄存器组、控制器** 集成在一个超大规模集成电路芯片上的功能部件；

存储器是微机存放和记忆程序、数据的部件，分为内存和外存；

外设可以分为两部分，一类是直接为计算机运行服务的，如键盘、鼠标；另外一类是暂时不影响计算机的外设，如打印机，显示器；

系统总线包括数据总线（传送数据）、地址总线（指出数据来源或目的地）、控制总线（传送 CPU 对存储器或 I/O 设备的控制命令，和 I/O 设备对 CPU 的请求服务信号），总线工作由系统总线控制模块指挥；



### 2.2 8086 微处理器

8086 的基本性能指标：

1. 16位微处理器；
2. 16根数据线、20根地址线，可寻址的地址空间达 1MB (220Byte＝1MB)；
3. 可以和浮点运算器、I/O 处理器或其他处理器组成多处理器系统，提高系统的数据吞吐能力、处理能力

<img src=".\media\微信截图_20210908104652.webp" style="zoom:33%;" />

通用寄存器包括 8 个 16 位寄存器：AX、BX、CX、DX、SP、BP、SI 和 DI；
标志寄存器为 FLAGS ，是一个 16 位的寄存器；

总线接口部件：负责管理与系统总线的接口，负责对存储器和外设访问；包括指令队列、指令指针、段寄存器、地址加法器和总线控制逻辑；

指令执行部件：包括 ALU 、通用寄存器、标志寄存器和控制电路；负责指令译码、数据运算和指令执行；

指令执行的两个主要阶段：取指和执行，其中取指：从主存取出指令代码进入指令队列，执行：译码指令、并发出有关控制信号实现指令功能；

8086 处理器的指令读取实质是 **指令预取**：8086 处理器维护着长度为 6 个字节的指令队列；EU 单元译码、执行指令，同时 BIU 单元读取后续指令，BIU 和 EU 两个单元相互独立，可以并行操作；



#### ※ 8086 CPU 寄存器分组表

<img src=".\media\8086寄存器.webp" style="zoom:67%;" />

以 [ BX+SI ] 为例：BX 为基址、SI 为变址；

##### 数据寄存器 AX,  BX, CX, DX

- 数据寄存器用来保存 **操作数或运算结果** 等；

  - AX 是累加器，用于算术、逻辑运算以及外设传送信息等；
  - BX 是基址寄存器，常用于存放存储器地址；
  - CX 是计数器，作为循环或串操作等指令中的隐含计数器；
  - DX 是数据寄存器，用来存放双字数据的高16位或存放外设端口地址；

- 以 AX 为例，它对应的 AH, AL 指的是 AX 的高位和低位；

  

##### 指针寄存器 SP, BP 

- 指针寄存器和变址寄存器用于存放 **某个存储单元的偏移地址**；

  - SP 用于存放当前堆栈中栈顶的偏移地址；

  - BP 用于存放堆栈段中某一存储单元的偏移地址；

    

##### 变址寄存器 SI, DI

- 在串操作中， SI 和 DI 都具有自动增量或减量的功能，它的目的操作数和源操作数都在连续空间；

  - SI 用于存源地址（操作完其值不改变）；
  - DI 用于存目的地址，操作完其值发生改变；



##### 控制寄存器 IP, FLAGS 

- 2 个控制寄存器

  - IP 指令指针寄存器保存下一次将要取出指令的偏移地址，IP 的内容由微处理器硬件自动设置，不能用指令直接修改，有一些指令可以改变 IP 的值，如转移指令、子程序调用指令等；
  - FLAGS 标志寄存器包含 9 个标志位，保存一条指令执行后，CPU 所处状态信息及运算结果的特征；

  

##### 段寄存器 CS, DS, SS, ES 

- 段寄存器用来确定 **该段在内存中的起始地址**，8086 有 4 个 16 位的段寄存器

  - 代码段 CS 主要存放运行的程序
  - 数据段 DS 存放运行程序所用的数据
  - 堆栈段 SS 定义了堆栈的所在区域
  - 附加段 ES 是附加的数据段，它是辅助数据区，在串操作指令中，用到的目的串必定存放在附加段中

  

#### 通用寄存器的专门用途

<img src=".\media\通用寄存器的专门用途.webp" style="zoom: 33%;" />



#### 堆栈的两种访问方式

1. 随机访问方式：用 BP 寄存器来指示随机访问地址；

2. 先进后出访问方式：用 SP 寄存器来表示栈顶；



#### ※ 标志寄存器的格式及各位的含义

<img src=".\media\标志寄存器的格式及各位的含义.webp" style="zoom:50%;" />

##### 进位标志 CF（Carry Flag）

当 **无符号整数** 加减运算的最高有效位有进位（加法）或借位（减法）时，CF＝1，否则 CF＝0；



##### 零标志 ZF（Zero Flag）

若运算结果为 0，则 ZF＝1，否则 ZF＝0；



##### 奇偶标志 PF（Parity Flag）

当运算结果的 **最低字节**（注：就是看最后 8 位，1 个字节 Byte 是 8 位 bit，8 位的结果看全部 8 位，16 位的结果看后 8 位）中， 1 的个数为零或偶数时，PF＝1；否则 PF＝0；



##### 辅助进位标志 AF（Auxiliary Carry Flag）

当运算结果的 **最低字节** （同 PF）低位的一半向高位（看最后 8 位的低 4 位向高 4 位）有进位或借位时，AF = 1；

该标志与操作数长度无关，只看最低字节中间那两位就行；



##### 符号标志 SF（Sign Flag）

若运算结果最高位为 1，则 SF＝1，否则 SF＝0；



##### 溢出标志 OF（Overflow Flag）

当 **有符号整数** 加减结果有溢出，则 OF＝1，否则 OF＝0；

> 对于程序员，无符号数关心进位，有符号数关心溢出，相同符号数相加后符号相反（如正+正=负），则有溢出；
>
> 对于处理器硬件判断，最高位和次高位同时进位或不进位，则无溢出；反之则有溢出；



##### 方向标志 DF（Direction Flag）

仅用于串操作指令，控制地址的变化方向：

1. 设置 DF＝0，每次串操作后的存储器地址就自动增加，即从低地址向高地址处理数据串；
2. 设置 DF＝1，每次串操作后的存储器地址就自动减少，即从高地址向低地址处理数据串；
3. 可以执行 CLD 指令设置 DF＝0；执行 STD 指令设置 DF＝1 ；



##### 中断允许标志 IF（Interrupt-enable Flag）

主要针对外中断中可屏蔽中断的开放或禁止：

1. 当 IF=1 时，CPU 允许响应可屏蔽中断，中断当前程序，转去执行中断处理程序；
2. 当 IF＝0 时，则不允许响应可屏蔽中断；
3. 可以执行 STI 指令设置 IF = 1；执行 CLI 指令设置 IF = 0；



##### 追踪标志 TF（Trace Flag）

用于单步调试程序：

1. 当 TF=1 时，在执行完一条指令后，产生单步中断；这在DEBUG调试程序状态下，可以使指令单步运行，可逐一检查各寄存器内容，标志状态、存储器的检查或修改等等；
2. 追踪标志 TF=1 时为调试程序时所用，当程序调试成功后让 TF=0，CPU正常工作不产生单步中断；



### 2.3 存储器地址

#### 存储器的组织：8086 实模式

采用分段方式，20 位的物理地址 由 **16 位的段地址** 和 **16 位的偏移地址** 形成，每个段的最大寻址空间为 64KB；

段地址必须是 16 的倍数，即（二进制写法）末尾 4 位必须为 0；



#### 存储单元的内容

课件记为存储地址加括号”( )” ，编程时用 []；

X 单元中存放着 Y，而 Y 是另一个存储单元的地址，则 Y 单元的内容表示为 (Y) = ((X))；

字单元由**两个字节单元**组成，其地址采用它的低地址来表示；

字存入存储器：低位字节存入低地址单元，高位字节存入高地址单元；



#### 储存单元地址例题

<img src=".\media\储存单元地址例题.webp" alt="image-20210908121210248" style="zoom:50%;" />



#### 储存器的分段

8086 的内部寄存器是 16 位，地址是 20 位，地址宽度大于字长，显然不能用16位的寄存器仅一次操作实现对 2^20^＝1M 字节单元的寻址；

- 20 根地址线，地址范围 00000H ~ FFFFFH （1MB）
- 机器字长 16 位，仅能表示地址范围  0000H ~ FFFFH（64KB)
- 物理地址：每一个存储单元有一个唯一的 20 位地址



为此引入存储器“分段”的概念，即把 1M 字节内存空间，分成最大 64KB 的段，每段可用 16 位寄存器进行寻址；



段地址：表示一个段的开始，段地址一般存在段寄存器；

偏移地址：在段内相对于段起始地址的偏移值；

逻辑地址：**段地址：偏移地址**



<img src=".\media\储存器的逻辑地址与物理地址.webp" style="zoom:38%;" />



物理地址：每一个存储单元有一个唯一的 20 位地址，表示范围：00000H～FFFFFH；

物理地址形成：**段地址左移 4 位，再加上偏移地址值**；

<img src=".\media\物理地址的形成.webp" style="zoom:38%;" />



- 逻辑地址的形式：指令操作数，指令间的相对地址
- 物理地址：MEM 的绝对地址
- 逻辑地址到物理地址的转换过程因 CPU 架构的不同而不同



##### 例：8086 逻辑地址与物理地址的转换

<img src=".\media\逻辑地址与物理地址的转换.webp" style="zoom:38%;" />



> 这里左移的 4 位是二进制位；如果用十六进制表达地址就是左移一位；
>
> 左移 4 位还可以表达为乘以 16，即：**物理地址 = 段地址 × 16D + 偏移地址** （或 = 段地址 × 10H + 偏移地址）



例：设某操作数存放在数据段，DS = 250AH，数据所在单元的偏移地址 = 0204H；则该操作数所在单元的物理地址为（    ）；

解：此类题目会设坑，给出一堆寄存器，答题需要先找**哪个是段地址**，需要注意偏移地址和段基址对应关系；本题提示了操作数存放在数据段，所以 DS 就是段地址，得物理地址 = **252A4H**；



<img src=".\media\段寄存器分配.webp" style="zoom:38%;" />



#### 偏移地址的组成

16 位有效地址：

- EA＝基址寄存器＋变址寄存器＋位移量
  - 基址寄存器：BX 或 BP，**一般由基址寄存器决定哪个段寄存器作为段指针**
  - 变址寄存器：SI 或 DI
  - 位移量：8 或 16 位有符号值（可正可负）



## ※ 8086 缺省 16 位段 + 偏移寻址组合表

注意：当 BX/BP 与 SI/DI 组合作为偏移地址时，默认的段寄存器是 BX/BP 所在段的寄存器，而不是 SI/DI 所在段的寄存器；

一般程序中 **只给出偏移地址**，因此需要背这张表的默认对应关系，记 **偏移寄存器 -> 段寄存器** 方向；

| 段寄存器  | 偏移寄存器            | 主要用途   |
| --------- | --------------------- | ---------- |
| CS 代码段 | IP                    | 指令寻址   |
| DS 数据段 | BX, DI, SI 或 16 位数 | 数据寻址   |
| SS 堆栈段 | SP 或 BP              | 堆栈寻址   |
| ES 附加段 | DI                    | 目标串寻址 |



## 3. 寻址方式

操作数寻址：获取操作数

指令寻址：控制指令跳转

### 3.1 操作数寻址

#### 8086 汇编指令格式

指令 = 操作码 + 操作数；

<img src=".\media\8086汇编指令格式.webp" style="zoom:38%;" />

寻址方式：为取得操作数或指令地址所使用的方法

操作数寻址：与数据有关的寻址方式

指令寻址：与转移地址有关的寻址方式  

指令寻址分为顺序寻址（IP 一条指令接一条指令地顺序进行移动）和跳转寻址（下条指令的地址码不是由程序计数器给出，而是由本条指令给出）



#### 3 种数据寻址方式

这 3 种寻址方式没有 “物理地址” 的概念；

AX 中一定是 16 位数，AL 中一定是 8 位数；

##### 立即数寻址

例：**MOV AX, 1100H**

<img src=".\media\立即数寻址.webp" style="zoom:38%;" />

- 操作数直接存在 **指令** 中，即 **立即数**（Immediate），用常量形式直接表达；
- 因此操作数存储在 **代码段（CS）**中；
- 注意：
  - 源操作数和目的操作数的 **字长必须一致**；例如 **MOV  AH, 3064H** 就是非法的；
  - 只能用于源操作数；



##### 寄存器寻址

例：**MOV  AX,  BX**

- 操作数在 CPU 的 **内部寄存器** 中；
- 不需要访问存储器，速度快；
- 注意：
  - 源操作数和目的操作数的 **字长必须一致**；例如 **MOV  AH (16 位), BX (8 位)** 是非法的；
  - 代码段寄存器 CS 不能用 MOV 指令改变（其他段寄存器都允许重新分配）；



##### 存储器寻址

- 存储器寻址共有 5 种寻址方式（见后文）
- 操作数在 **存储器** 中，用存储单元的地址表示；
- 编程时使用包含 **段寄存器** 和 **偏移地址** 的逻辑地址（一般只给出偏移地址）；
- 段寄存器指示段的 **基地址**；
- 偏移地址由各种寻址方式计算，常被称为 **有效地址 EA**（Effective Address）；
- 一般情况下存储器地址由有效地址表示，段寄存器不用显式说明，数据在默认的段中；如果不使用默认段寄存器，则要用 **段超越指令前缀** 加以说明；



#### 段寄存器的默认和超越

| 访问存储器的方式   | 默认      | 偏移地址    | 可超越             |
| ------------------ | --------- | ----------- | ------------------ |
| 取指令             | 代码段 CS | IP          | 无                 |
| 堆栈操作           | 堆栈段 SS | SP          | 无                 |
| 一般数据访问       | 数据段 DS | 有效地址 EA | CS, ES, SS, FS, GS |
| BP 基址的寻址方式  | 堆栈段 SS | 有效地址 EA | CS, ES, SS, FS, GS |
| 串操作的源操作数   | 数据段 DS | SI          | CS, ES, SS, FS, GS |
| 串操作的目的操作数 | 附加段 ES | DI          | 无                 |



#### 5 种存储器寻址方式

做题注意一下哪边是高地址，哪边是低地址；

##### 直接寻址

例：**MOV CX，[2000H]**

- 指令中直接包含了操作数的有效地址 EA，在指令操作码之后；
- 默认段地址在DS寄存器中，即操作数的实际地址（物理地址）是 DS:EA ；
- 常用于存取变量；



##### 寄存器间接寻址

例： **MOV AX，[SI]**

- 操作数的有效地址 EA 存放在基址寄存器 BX 或变址寄存器 SI, DI 中，**不能放在 AX / CX / DX 中**；
- 操作数的段地址（数据处于哪个段）取决于 **选择哪一个间址寄存器**；
- 可以方便地对数组的元素或字符串的字符进行操作；
- 寄存器间接寻址没有说明存储单元类型；



##### 寄存器相对寻址

例： **MOV BX，NUM+[DI]** 

- 有效地址 EA 是 **寄存器内容与位移量之和**；
- 适用于数组、字符串、表格的操作；

<img src=".\media\寄存器相对寻址.webp" style="zoom:38%;" />



例：计算寄存器相对寻址的有效地址

<img src=".\media\寄存器相对寻址例题.webp" style="zoom:38%;" />



##### 基址变址寻址

例：**MOV AX，\[BX][SI]**

- 有效地址是基址寄存器和变址寄存器之和
- 适用于二维数组、字符串、表格的操作
- 必须是一个基址寄存器和一个变址寄存器的组合
  - **MOV  AX,  \[BX][BP]**    非法，这是两个基址寄存器
  - **MOV  AX,  \[SI][DI]**      非法，这是两个变址寄存器

<img src=".\media\基址变址寻址.webp" style="zoom:48%;" />



##### 相对基址变址寻址

例：**MOV AX，MASK\[BX][SI]**

也可以写成 **MOV AX, [BX+SI+MASK]** 

或 **MOV AX, MASK[BX+SI]**

- 有效地址计算如下：

<img src=".\media\相对基址变址寻址.webp" style="zoom:38%;" />



例：计算相对基址变址寻址的有效地址

<img src=".\media\相对基址变址寻址例题.webp" style="zoom:38%;" />



#### 操作数寻址（共 7 种）总结

1. 立即数寻址                **MOV  AX , 3069H**
2. 寄存器寻址                **MOV  AL , BH**
3. 直接寻址                    **MOV  AX , [2000H]**
4. 寄存器间接寻址         **MOV  AX , [BX]** 
5. 寄存器相对寻址         **MOV  AX , NUM [ SI ]** 
6. 基址变址寻址             **MOV  AX , \[BP][DI]**
7. 相对基址变址寻址      **MOV  AX , MASK \[BX][SI]**



#### 未解决的疑问（更新解答）

2021/9/13：老师说下次课讲

2021/9/16：讲了，但没完全讲.jpg

作业题：假设（DS）= 2000H，（ES）= 2100H，（SS）= 1500H，（SI）= 00A0H，（BX）= 0100H，（BP）= 0010H，数据段中的变量名VAL的 **偏移地址值** 为 0050H；试指出下列源操作数的寻址方式是什么？其物理地址值是什么？（8）MOV  AX，VAL

（这里先放一下 lys 大佬和老师的说法：）

<img src=".\media\image-20210913193654164.webp" alt="image-20210913193654164" style="zoom:33%;" />

<img src=".\media\image-20210913193830411.webp" alt="image-20210913193830411" style="zoom:33%;" />

老师的解释：

MOV AX, VAL 等价于 MOV AX, [VAL]，是一个直接寻址，变量的名字就代表变量的偏移地址；



### 3.2 指令寻址

#### 段内直接寻址

例： 

**JMP  NEAR PTR  NEXT**    近转移    <u>-32768 ~ +32767</u>，汇编时，位移量为16位

**JMP  SHORT  NEXT**          短转移    <u>-128 ~ +127</u>，汇编时，位移量为8位

- 段内寻址 CS 不变，只改变 IP；
- 直接体现地址信息，需要进行一个转换；
- 转向的有效地址 = 当前 (IP) + 位移量 (8bit/16bit) ，其中位移量是 **转向的有效地址与当前 IP 值之差**；



#### 段内间接寻址

<img src=".\media\段内间接寻址.webp" style="zoom:48%;" />

- 段内寻址 CS 不变，只改变 IP；
- PTR 是强制类型转换；
- 转向的有效地址是一个寄存器或存储单元的内容；
- 可用除立即数以外的任何一种数据寻址方式得到；



#### 段间寻址

例：

**JMP  1234H:5678H**                        ;  (CS) = 1234H ，(IP) = 5678H

**JMP dword ptr 内存地址单元**      ;  (CS) = (内存地址单元+2) ，(IP) = (内存地址单元) 

- 段间寻址，既改变 IP 也改变 CS 转向的有效地址是 XXXX:YYYY 形式

- 一般仅供操作系统（OS）使用

  

### 3.3 伪指令

汇编语言语句分为 **指令** 和 **伪指令** 两种类型：

| 指令性语句                                                   | 指示性语句（伪指令语句）                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 能够被直接翻译成机器码，并让CPU直接执行的语句；<br>每一条指令语句对应一条可执行的CPU机器指令，执行产生相应的CPU动作；<br>有操作码和操作数两个部分； | 指导汇编程序如何编译汇编语言源程序，并不翻译成机器代码，CPU也不执行；<br>通常完成储存模式定义、数据定义、存储器分配、指示程序开始结束等功能；<br>可以提高编程效率，指导编译器如何编译汇编程序； |

<img src=".\media\汇编语言语句类型.webp" style="zoom:75%;" />



#### 汇编语言语句格式 

名字定义满足的规则：

1. 数字不能作为第一个字符；
2. 单独的问号（?）不能作为名字；
3. 最大有效长度为 31；
4. 保留字不能作为名字使用；

<img src=".\media\汇编语言语句格式.webp" style="zoom: 25%;" />



##### 操作码

- 含义：指明操作的性质或功能；
- 书写规则：操作码与操作数之间用空格分开；



##### 操作数

- 含义：指定参与操作的数据或者地址表达式；
- 个数：一般指令，1个或2个，也可以没有；伪指令和宏指令可以有多个；
- 书写规则：操作数多于1个时，操作数之间用逗号分开



#### 段定义伪操作 `SEGMENT`、`ENDS`

- 程序由4个逻辑段组成：数据段、堆栈段、附加段和代码段；

- 每个逻辑段以 `SEGMENT` 语句开始，以 `ENDS` 语句结束；

  

##### 段定义的格式

```assembly
段名  SEGMENT  [定位类型]  [组合类型]  [使用类型]  [‘类别’]	; 方括号这几项一般采取默认设置，缺省：
          ……
          ……            ; 语句序列
段名  ENDS
```

例：

```assembly
DATA   SEGMENT         ; 定义数据段
       …
DATA   ENDS
;----------------------------------------
EXTRA  SEGMENT         ; 定义附加段
       …
EXTRA  ENDS
;----------------------------------------
CODE   SEGMENT         ; 定义代码段
       ASSUME CS:CODE, DS:DATA, ES:EXTRA
START: 
       MOV   AX, DATA
       MOV   DS, AX    ; 段地址 -> 段寄存器
       …
CODE   ENDS
       END   START
```



#### 指定段地址伪指令 `ASSUME`

- 伪指令的格式：**ASSUME <段寄存器名>:<段名>[,<段寄存器名>:<段名>…]**
- 功能：建立段寄存器与段的缺省关系；
- 注意：ASSUME 伪指令 **是给程序员看的**，并不为段寄存器设定初值，没有真正建立关联；



**例： assume cs:code, ds:data, es:extra**

其中：code 是代码段的段名，data 是数据段的段名，extra 是扩展段的段名



#### 设置段地址值 

- 在代码段开始处进行 DS, SS, ES 的段地址装填；
- DS, SS, ES 默认指向 PSP（默认分 256 字节），CS 默认指向 PSP 完成段后的地址；

<img src=".\media\设置段地址值.webp" style="zoom:38%;" />

* 8086 **不支持将数据直接送入段寄存器** ，DATA 是地址常量，只能通过 AX 中继一下才能进入 DS 
* MOV 也不能在段寄存器之间直接赋值；



#### 程序结束伪操作 `END`

- 格式：**END  [ label ]**

例：

```assembly
code   segment           ; 定义代码段
       assume cs:code, ds:data, es:extra
start: 
       mov   ax, data
       mov   ds, ax      ; 段地址 -> 段寄存器
       …
code   ends
       end   start
```



#### 数据定义及存储器分配伪操作 `DB`、`DW`、`DD`、`DQ`、`DT`

- 格式：**[变量] 助记符 操作数 \[,操作数,…] \[;注释]** 

- 助记符：**DB, DW, DD, DQ (8字节), DT (10字节)** 

  - DB： 定义字节
  - DW：定义字
  - DD： 定义双字

  

<img src=".\media\数据定义以及储存器分配伪操作.webp" style="zoom:48%;" />

例：

```assembly
DATA_BYTE  DB  10,4,10H,?            
DATA_WORD  DW  100,100H,-5,? 	; -5 按补码存储
```

<img src=".\media\数据定义例.webp" style="zoom:38%;" />

这里 **DB 2 DUP (0,2 DUP(1,2),3) = 2 DUP（0, 1, 2, 1, 2, 3）= （0, 1, 2, 1, 2, 3, 0, 1, 2, 1, 2, 3）**

<img src=".\media\数据定义例2.webp" style="zoom:38%;" />



##### 操作数

<img src=".\media\操作数.webp" style="zoom: 50%;" />

**MOV AL, OPER2**  和 **MOV AL, [OPER2]** 是等价的；  

<img src=".\media\操作数和类型匹配.webp" style="zoom:38%;" />



#### 表达式赋值伪操作 `EQU`

- 相当于给表达式起一个别名，碰到别名就替换成表达式；
- 格式：表达式名 EQU 表达式
- 同一个程序中 `=` 可以对一个符号重复定义，但 EQU 不能对同一个符号重复定义
- 注意：EQU 指令不占用内存空间；

```assembly
BUF1 DW 1,2,3
INTT EQU 5
BUF2 DW 4,5,6       ; 3和4的地址是连续的
```



#### 解除定义伪指令 `PURGE`

- 格式：PURGE <符号1，符号2，…，符号n>
- 功能：解除指定符号的定义



#### 地址计数器与对准伪操作 `$`

- 常用于确定数组中元素的个数

```assembly
BUF1 DB 1，2，3，4，5
CNT1 EQU $-BUF1              ;（常用）
BUF2 DW 1，2，3，4，5
CNT2 EQU ($-BUF2)/2          ;（/2后等于数组元素个数）
```

- 在代码段，\$ 表示当前正在汇编的指令的地址；

```assembly
ORG   $+8       ;  跳过8个字节的存储区
JNE   $+6       ;  转向地址是 JNE 的地址 +6
JMP   $+2       ;  转向下一条指令
```

- 在数据段，\$ 表示当前地址计数器的值；

```assembly
ARRAY DW 1, 2 , $+4 , 3 , 4 , $+4
```

结果如图：

<img src=".\media\地址计数器内存图.webp" style="zoom:38%;" />



#### 表达式操作符

在指令中出现，主要是对常量进行运算:

| 运算符类型 | 运算符及说明                                            |
| ---------- | ------------------------------------------------------- |
| 算术运算符 | + 、－、*、 /、MOD（取余数）                            |
| 逻辑运算符 | AND（与）、OR（或）、XOR（异或）、NOT（非）             |
| 位移运算符 | SHL（逻辑左移）、SHR（逻辑右移）                        |
| 关系运算符 | EQ（=）、NE（!=）、GT（>）、LT（<）、GE（>=）、LE（<=） |



##### 算术运算符：`+` 、`-`、`*`、 `/`、`MOD` 

```assembly
VIDEO_BUF  DB  25*80*2  DUP(?)
ARRAY   DW   1,2,3,4,5,6,7
ARYEND  DW   ?
MOV  CX, (ARYEND-ARRAY)/2	; 赋值
BLOCK DB  1，2，3

MOV  AL, BLOCK+2   ; 符号地址 ± 常数有意义，等价于  MOV  AL, [BLOCK+2] 
```



##### 逻辑和移位操作符： `AND`、`OR`、`XOR`、`NOT`、`SHL`、`SHR` 

```assembly
OPR1  EQU  25    ; 00011001B
OPR2  EQU  7     ; 00000111B

AND  AX, OPR1 AND OPR2     ; AND AX,1

MOV  AX,  0FFFFH SHL 2     ; MOV AX,0FFFCH
```



##### 关系操作符： `EQ`、`NE`、`GT`、`LT`、`GE`、`LE`

```assembly
MOV FID, (OFFSET Y - OFFSET X) LE 128
; 若 <= 128  (真)   汇编结果：  MOV  FID, -1
; 若 >  128  (假)   汇编结果：  MOV  FID, 0
```



##### 数值回送操作符： `OFFSET`、`SEG`、`LENGTH`、`SIZE`

- **OFFSET /  SEG**      变量 / 标号
  - 功能：回送变量或标号的偏址 / 段址
  - 如 **MOV DX, SEG FUNC** 或  **MOV AX, OFFSET LNAME**



- **LENGTH**   变量
  - 功能：回送由 **<u>DUP 定义的变量</u>** 的 **单元数**，其它情况 **回送 1**；



- **SIZE**   变量
  - 功能：返回配送给由 **<u>DUP 定义的变量</u>** 的 **字节数**，其它情况 **回送 1**；
  - **SIZE** 操作等价于 **LENGTH * TYPE        ;DB的TYPE值为1，DW的TYPE值为2**



例：

```assembly
ARRAY   DW   100 DUP (?)
TABLE   DB   ‘ABCD’

MOV  CX,  LENGTH  ARRAY   ;  MOV  CX, 100
MOV  CX,  LENGTH  TABLE   ;  MOV  CX, 1
MOV  CX,  SIZE    ARRAY   ;  MOV  CX, 200
MOV  CX,  SIZE    TABLE   ;  MOV  CX, 1
```



##### 属性修改的伪指令： `PTR`

- **BYTE PTR** 表示字节，**WORD PTR**  表示字（2个字节）
  - 例：**BYTE PTR [BX]       ; 按字节访问 BX**
  - ​        **WORD PTR [BX]    ; 按字访问 BX** 
- 格式： 新属性 PTR （旧属性的）表达式
- 功能：用于 **暂时改变** 内存变量或标号的原有属性，但 **不能修改寄存器的原有属性**（寄存器属性是固定的）；
- 方式：与其它汇编指令配合使用，不能独立使用

例：**MOV  AX, WORD PTR [BX]**

应用场合：

```assembly
; 1. 有一些指令中，操作数或表达式的属性是不明显的，需要加以明确。
CALL DWORD PTR [BX]    ; 远调用
CALL BYTE PTR  [BX]    ; 段内近调用

; 2. 需要修改操作数或表达式的属性的。
F1 DW 1234H
MOV AL，BYTE PTR F1   ; AL=34H
F2 DB 23H，56H，18H
MOV BX，WORD PTR F2   ; BX=5623H
```



##### 定位类型的伪指令： `PARA`

- `PARA` 是定位类型之一；
- 功能：PARA (Paragraph，节) 表明 **该段起始地址对齐到 para** ，供 OS 使用
- 一般各个逻辑段的首地址在“节”的整数边界上（每 16 个存储单元叫做一节, 1 para = 16 Bytes），即每个逻辑段的起始地址是 16 的整数倍，或地址的最低 4 位为 0

例： **code segment para 'code'**

（完全没看明白，但还是先记下了）



#### 汇编语言程序格式

- 一个汇编源程序一般应该由 3 个逻辑段组成，即数据段、堆栈段、代码段；
- 每个逻辑段以 **SEGMENT** 语句开始，以 **ENDS** 语句结束。整个源程序以 **END** 语句结束；
  - 数据段用来在内存中建立一个适当容量的工作区，以存放常数、变量等操作数据；
  - 堆栈段用来在内存中建立一个适当的堆栈区，以便在中断、子程序调用时使用；
  - 代码段包括了许多以符号表示的指令，其内容就是程序要执行的指令；

例：求字存储单元中两个数之差，存入下一个相邻字单元

<img src=".\media\用段定义伪指令.webp" style="zoom:38%;" />





#### 程序段前缀结构 FAR 

把整个程序定义成一个 FAR 型过程（或子程序），该过程能够让其它汇编文件中的段来调用，而 near 则不能。 

##### 过程定义伪指令：`PROC`、`ENDP`

格式：

```assembly
NAME  PROC  [TYPE]
; ... 
NAME  ENDP
```

例：

<img src=".\media\程序段前缀结构FAR.webp" style="zoom:38%;" />

##### 代码段中程序结束的两种方式

```assembly
INT 21H ; DOS 中断调用

RET     ; 过程结束
```



#### 汇编语言程序的上机过程

汇编程序的主要功能：

- 检查源程序，给出出错信息
- 产生目标文件 (.obj) 和列表文件 (.lst) 
- 展开宏指令

<img src=".\media\汇编程序运行步骤以及生成的文件.webp" style="zoom:38%;" />



## 4. 8086 的指令系统

（这部分为啥在伪指令后面？？？）

主要可以分为：

- 数据传送指令
- 算术指令
- 逻辑指令
- 串处理指令
- 控制转移指令
- 处理机控制指令
- 杂项操作指令

需要记忆：指令的基本功能、支持的寻址方式、执行前后标志位的影响、指令的特殊要求



### 传送指令：`MOV` 

**MOV DST, SRC**       ; 执行操作：**(DST)   ←  (SRC)**

- **寄存器 REG**：AX, BX, CX, DX, AH, AL, BL, BH, CH, CL, DH, DL, DI, SI, BP, SP；
- **段寄存器 SREG**：DS, ES, SS, 注意 **CS 只能作为操作源**（意思是 MOV CS, AX 会报错，MOV AX, CS 可以）；
- **存储器 memory**：[BX], [BX+SI+7], 变量等；
- **立即数 immediate**：5, -24, 3Fh, 10001101b 等；
- 注意事项：
  - 不允许使用 AX、CX、DX 存放 EA； 
  - CS 和 IP 寄存器的修改只能使用 JMP XX:YY 指令进行修改，不能用 MOV 指令修改。通常来说，CS 都是由 OS 分配的，应用程序不能对其进行修改；
  - DST、SRC 的类型要匹配，因此不能同时为存储器寻址。因为两者的位宽是否匹配不能确定；
  - MOV 只允许下方代码块中允许的移动：

```assembly
; MOV 支持的寄存器操作：
MOV REG, memory
MOV REG, REG
MOV REG, immediate
MOV memory, REG
MOV memory, immediate

; MOV 只支持如下段寄存器操作：
MOV SREG, memory
MOV memory, SREG
MOV REG, SREG
MOV SREG, REG
```

总结：

<img src=".\media\MOV小结.webp" style="zoom: 50%;" />



### 堆栈操作指令：`PUSH`、`POP` 

- 堆栈是 **后进先出**（LIFO）的存储区；
- 栈顶是低位地址，SP 指向栈顶；
- 段地址存放在 SS 中，堆栈指针 SP 在任何时候都指向栈顶，进出栈后自动修改 SP；   
- 堆栈用于 **保存子程序返回地址和断点地址** 以及 **主程序通用寄存器内容的保护和恢复** ；
- 因为 LIFO，所以在保存和恢复寄存器的内容时，要 **按照相反的顺序** 执行一组压入和弹出指令；
- 注意：
  - 堆栈操作必须以字为单位
  - 不影响标志位
  - 不能用立即寻址方式（不能压栈一个立即数），例：**PUSH  1234H      ; 非法**
  - DST 不能是 CS ，CS 只能用 JMP 指令间接修改，例：**POP  CS      ; 非法**
  - 没有明确的寄存器表示栈底，除非程序人为定义了 SS 段使用自定义的堆栈；
  - BP 可以寻址堆栈中任何一个位置；

指令格式：

```assembly
进栈指令：PUSH  SRC
执行操作：
(SP) ←  (SP) – 2        ; 栈顶指针 SP 上移，所以是 - ；堆栈以字（2个字节）为单位，所以 -2
((SP+1), (SP)) ←  (SRC)

出栈指令：POP  DST
执行操作：
(DST) ←  ((SP+1), (SP))
(SP) ←  (SP) + 2        ; 栈顶指针 SP 下移，
```



### 数据交换指令：`XCHG` 

- 格式：**XCHG  OPR1，OPR2**
- 功能： (OPR1)  <-->  (OPR2) 交换值
- 注意： 
  - 不影响标志位
  - 不允许使用段寄存器，两个操作数必须有一个在寄存器中（内存之间不能相互传送数据，因为不知位宽是否匹配）

 例：

```assembly
BX=6F30H，BP=0200H，SI=0046H，AX=2105H
SS=2F00H，(2F246H)=4154H 
XCHG  BX，[BP+SI]     ; (BX) = 4154H, [SS*10H +BP+SI] = 6F30H
XCHG  AL，BH          ; (AL) = 41H, BH = 05H 
```



### I/O数据传送指令：`IN`、`OUT`

- 功能：用于外部设备 I/O 端口与 CPU 之间的信息交换；
- IN/OUT 指令中 AX（AL）操作数的位置是不同的，一个是目标操作数位置，另一个是源操作数位置；
- IN/OUT 指令操作期间，端口地址处将产生一个负脉冲信号；
- 只能使用 AX 或 AL 来存放数据，只限 **8 位立即数** 或 **DX** 来存放端口号；
  - 该操作不影响标志位
  - 前 256 个端口号（00H~FFH）可直接在指令中指定（长格式）
  - 如果端口号大于等于 256，端口号就只能存在 DX 中（短格式）

输入指令：

```assembly
; I/O端口直接寻址方式(直接用 8 位的立即数)
; 长格式：
IN   AL, PORT         （字节）
IN   AX, PORT         （字）
; 执行操作：
(AL) ← (PORT)   	  （字节）
(AX) ← ((PORT+1),(PORT)) （字）

; I/O端口间接寻址方式(超过 256 位的时候只能间接寻址)
; 短格式：   
IN   AL, DX   	  （字节）
IN   AX, DX   	  （字）
; 执行操作：
(AL) ← (DX)     	  （字节）
(AX) ← ((DX+1),(DX)) （字）     
```



输出指令：

```assembly
; I/O端口直接寻址方式(直接用 8 位的立即数)
; 长格式： 
OUT   PORT, AL  （字节）
OUT   PORT, AX  （字）
; 执行操作：
(PORT) ← (AL)      （字节）
((PORT+1),(PORT)) ← (AX)（字）

; I/O端口间接寻址方式(超过 256 位的时候只能间接寻址)
; 短格式：   
OUT   DX, AL  	（字节）
OUT   DX, AX  	（字）
; 执行操作： 
(DX) ← (AL)    （字节）
((DX+1),(DX)) ← (AX)（字）
```



例：

```assembly
IN   AL, 28H    ; 将端口28H中的字节数据读出送AL
OUT  28H, AL    ; 将AL的数据写入28H中

MOV  DX, 03FCH  ; 将端口03FCH送DX
IN   AL, DX     ; 将端口03FCH中字节数读出送AL
OUT  DX, AL     ; 将AL中数据写入端口03FCH中

; TEST 指令测试某状态寄存器（端口号27H）的第2位是否为1
IN     AL, 27H
TEST   AL, 00000100B
JNZ    ERROR          ; 若第2位为1，转ERROR处理
```



### 换码/查表指令：`XLAT` 或 `XLAT  OPR`

这两个指令默认了操作数，执行操作：**(AL）←  ( BX + AL )**

功能：AL 给出偏移量，然后存储该偏移地址处的内容

注意：
*  不影响标志位
*  字节表格（长度不超过256）首地址存在 BX
*  需转换的位移量存在 AL

```assembly
; 例：
MOV BX, OFFSET TABLE   ; BX=0040H
MOV  AL, 3
XLAT  TABLE ; 指令执行后：(AL)=33H
```

<img src=".\media\换码查表指令内存示意图.webp" style="zoom:48%;" />



### 地址传送指令：`LEA`、`LDS`、`LES`



- ##### 有效地址送寄存器指令：LEA  REG, SRC

  - 执行操作： **(REG) ← SRC**
  - 功能：将源操作数的有效地址 EA 传送到目标寄存器
  - 注意：
    - **SRC** 不能是立即寻址或寄存器寻址，**必须为存储器寻址方式**；
    - **REG 不能是段寄存器；**



- ##### 指针送寄存器和 DS 指令：LDS  REG, SRC

  - 执行操作：**(REG) ← (SRC) ,  (DS) ← (SRC+2)**
  - 功能：将源操作数中存放的地址指针 ”段基址: 偏移地址” 的低 16 位送入目标寄存器，高 16 位送入 DS 段寄存器



- ##### 指针送寄存器和 ES 指令：LES  REG, SRC

  - 执行操作：**(REG)  ←  (SRC)，(ES)  ←  (SRC+2)**
  - 功能：将源操作数中存放的地址指针”段基址: 偏移地址”的低 16 位送入目标寄存器，高 16 位送入 ES 段寄存器

例：

<img src=".\media\地址传送指令例.webp" style="zoom:38%;" />

判断题：

① LEA    BX,  [2728H]      ; (BX)=2728H  

② MOV   BX,  [2728H]     ; (BX)=DS段内2728H处一个字的内容

③ MOV   BX,  2728H        ; (BX)=2728H

④ LDS    BX,  [2728H]      ; (BX)=DS段内2728H处一个字的内容

⑤ LEA    BX,  2728H         ×

⑥ LDS    BX,  2728H        ×

⑦ LES    BX,  2728H         ×

⑧ LEA    BX,  SI                 ×

⑨ LDS    BX,  SI                 ×

⑩ LES    BX,  SI                  ×



### 标志寄存器传送指令：`LAHF` 、`SAHF` 、`PUSHF`、`POPF` 

**FLAGS** 为 16 位标志寄存器，低字节指 FLAGS 的 **低 8 位**；

这里的操作都影响标志位；



- ##### 标志送 AH 指令：`LAHF`

  - 功能：读取标志位低字节，把标志寄存器中的 SF、ZF、AF、PF、CF 五个标志传至 AH 的第 7、6、4、2、0 位，第 5、3、1 位未定义；
  - 执行操作：(AH) ← (FLAGS 的低字节)

  <img src=".\media\LAHF指令.webp" style="zoom:38%;" />

  

  

- ##### AH 送标志寄存器指令：`SAHF`

  - 功能：写入标志位低字节
  - 执行操作：**（FLAGS 的低字节） ←  (AH)**

  

- ##### 标志进栈指令：`PUSHF` （FLAGS 的高和低两字节） 

  - 功能：读取标志位的 2 个字节内容到堆栈中；
  - 执行操作：**(SP)  ←  (SP) – 2 ，((SP)+1，(SP))  ←  (FLAGS)**

  

- ##### 标志出栈指令：`POPF` （FLAGS 的高和低两字节） 

  - 功能：写入堆栈的 2 个字节内容到标志位中；
  - 执行操作：**(FLAGS)  ←  ((SP)+1, (SP))，(SP)  ←  (SP) + 2**



### 加法指令：`ADD`、`ADC`、`INC`



- ##### 加法指令：ADD  DST, SRC
  
  - 执行操作：**(DST) ← (SRC) + (DST)**
  



- ##### 带进位加法指令：ADC  DST, SRC
  
  - 执行操作：**(DST) ← (SRC) + (DST) + CF**
  



- ##### 加 1 指令：INC  OPR 
  
  - 执行操作：**(OPR) ← (OPR) + 1**



注意：  

   * `INC` 指令不影响 CF 标志（硬件结构决定的），对其它条件标志位都有影响；

   * 汇编器不会区分有符号数还是无符号数，它会统一当作有符号的，并全部编译成补码形式进行运算；

   * 如果要将一个加法解释成无符号数加法，那么就只使用 CF，否则就需要使用 OF；

   * OF = 1 说明运算结果已经错误，应该中止运算；

   * CF 与 OF 不在同一解释中同时使用；

     

> 8086 指令中专门提供了一条 **[溢出中断指令 `INTO`](https://github.com/Sayaka-4987/Notes_for_BJTU_Finals/blob/main/21-Fall-%E6%B1%87%E7%BC%96%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0.md#%E4%B8%AD%E6%96%AD%E4%B8%8E%E4%B8%AD%E6%96%AD%E8%BF%94%E5%9B%9E%E6%8C%87%E4%BB%A4intintoiret)**，用来判断有符号数加减运算是否有溢出；
>
> 该命令常用于算术运算中，若算术运算（它的上一条指令）的结果产生溢出，即 OF=1 ，则立即调用一个处理算术溢出的中断服务程序；否则不进行任何操作，接着执行下一条指令；



例：双精度数的加法，分别加低位和高位

DX = 0002H，AX = 0F365H （16 进制表示中，最高位是字母时，前面要补 0）

BX = 0005H，CX = 8100H

指令序列：

```assembly
ADD  AX, CX    ; (1) 执行后，(AX) = 7465H，CF=1，OF=1
ADC  DX, BX    ; (2) 执行后，(DX) = 0008H，CF=0，OF=0
```



### 减法指令：`SUB`、`SBB`、`DEC`、`NEG`

- ##### 减法指令：SUB  DST, SRC

  - 执行操作： **(DST) ←  (DST) – (SRC)**



- ##### 带借位减法指令：SBB  DST, SRC

  - 执行操作： **(DST) ←  (DST) – (SRC) – CF**



- ##### 减 1 指令：DEC  OPR 

  - 作： **(OPR)  ←  (OPR) – 1**



- ##### 求补指令：NEG  OPR 

  - 执行操作：**(OPR) ←  – (OPR)**
  - 功能：将操作数按位求反后末位加1，因而操作也可以表示为（OPR）←  0FFFFH（补码的 -1） –  (OPR) + 1（也可以写成 0 -  (OPR) 
  - 例：如果 (CL) = 100，执行 NEG CL 后 (CL)=1001 1100B，是 -100 的补码；如果(CL) = –8，执行 NEG CL 后 (CL)=0000 1000B，是 8 的补码
  - 

### 比较指令 `CMP`

- ##### 格式： CMP  OPR1, OPR2 

  - 执行操作： **(OPR1) – (OPR2)**
  - 功能：该指令与 SUB 指令一样执行减法操作，但它不保存结果，只根据结果 **设置条件标志位**；
  - CMP 指令后一般跟随条件转移指令，根据比较结果产生不同的程序分支；
  - 说明：OPRT1 和 OPRT2 可以是寄存器或存储器，但**不能同时为存储器**（否则位宽不能保证），OPRT2 还可以为立即数



注意：

* `DEC` 指令不影响 CF 标志（硬件结构决定的），对其它条件标志位都有影响；
* 有符号减法下 CF 没有意义，无符号数减法下 OF 没有意义；
* `CMP` 指令执行后对标志位的影响：
  * 对于有符号数，SF 异或 OF 等于 1 时是小于，

<img src=".\media\CMP指令执行后对标志位的影响.webp" style="zoom:38%;" />



### 乘法指令：`MUL`、`IMUL`  



- ##### 无符号数乘法指令：**MUL    SRC**

- ##### 带符号数乘法指令：**IMUL   SRC**

- 执行操作：

  - 字节操作数      **(AX) ← (AL) * (SRC)**
  - 字操作数    **(DX,AX) ← (AX) * (SRC)**

- 注意：
  *  AL (AX) 为隐含的乘数寄存器；
  *  AX (DX,AX) 为隐含的乘积寄存器；
  *  SRC 不能为立即数，因为位宽不详；
  *  除 CF 和 OF 外，对条件标志位无定义；

<img src=".\media\乘法指令对CF和OF的影响.webp" style="zoom:38%;" />

<img src=".\media\乘法指令对CF和OF的影响2.webp" style="zoom: 25%;" />



### 除法指令：`DIV`、`IDIV`



### 十进制调整指令：`DAA`、`DAS`、`AAA`、`AAS`、`AAM`、`AAD`



### 逻辑运算指令：`AND`、`OR`、`NOT`、`XOR`、`TEST` 



- ##### 逻辑非指令：**NOT  OPR**  

- 执行操作： **(OPR) ←  ¬ (OPR)**    

  

- ##### 逻辑与指令：**AND  DST, SRC**

- 执行操作： **(DST) ← (DST) ∧ (SRC)**



- ##### 逻辑或指令：**OR  DST, SRC**

- 执行操作： **(DST) ← (DST) ∨ (SRC)**



- ##### 异或指令：  **XOR  DST, SRC**

- 执行操作： **(DST) ← (DST) ⊕ (SRC)**



- ##### 测试指令：  **TEST  OPR1, OPR2**

- 执行操作： **(OPR1) ∧ (OPR2)**

- 注意：

  - OPR 不能为立即数
  - 不影响标志位 



例：

<img src=".\media\逻辑运算使用例.webp" style="zoom:38%;" />



### 移位指令：`SHL`、`SHR`、`SAL`、`SAR`、`ROL`、`ROR`、`RCL`、`RCR`

注意：

*  OPR 可用 **除立即数以外** 的任何寻址方式 
*  条件标志位：
     *  CF = 移入的数值
     *  OF=1：当 CNT=1 时，最高有效位的值发生变化
     *  OF=0：当 CNT=1 时，最高有效位的值不变
     *  CNT>1时，OF 无意义
     *  移位指令：SF、ZF、PF 根据移位结果设置，AF 无定义；
     *  循环移位指令可以改变操作数中所有位的位置，不影响 SF、ZF、PF、AF
*  算术/逻辑移位指令常用来乘以 2 或除以 2，以及 2 的整数幂，根据移位的位数，即移动 1、2、3…，分别为乘以或除以 21、 22、 23…
*  **算术 **移位适用于 **带符号数** 的运算；**逻辑 **移位指令用于 **无符号数** 的运算；



<img src=".\media\移位指令1.webp" style="zoom:38%;" />

<img src=".\media\移位指令2.webp" style="zoom:38%;" />



### 无条件转移指令：`JMP`

- ##### 段内直接短转移：JMP   SHORT  OPR 

- 执行操作：IP ←  IP + 8位位移量



- ##### 段内直接近转移：JMP   NEAR PTR  OPR

- 执行操作：IP ← IP + 16位位移量



- ##### 段内间接转移：JMP   WORD PTR  OPR

- 执行操作：IP ← (EA) ，其中 OPR 为存放在 16 位通用寄存器或字内存单元内的偏移量



### 条件转移指令：`JZ/JNZ` 、 `JE/JNE`、 `JS/JNS`、 `JO/JNO`、`JP/JNP`、 `JB/JNB`、 `JL/JNL`、 `JBE/JNBE`、`JLE/JNLE`、 `JCXZ` 

首先回忆标志位作用：

<img src=".\media\标志寄存器的格式及各位的含义.webp" style="zoom:50%;" />



**条件转移指令** 将标志位的状态作为测试的条件，所以 **首先需要执行影响标志位的指令**（如 CMP 或 TEST 等），然后采用条件转移指令测试相应的标志，决定程序的转移

注意：

- 只能使用 **段内直接寻址** 的 8 位位移量；
- 条件转移指令均为段内短转移，即转移范围为：**-128 ~ +127** 



（还是 PPT 最靠后出现的这张表比较细……）

测试 CX 的值为 0 则转移：**JCXZ   OPR           (CX)=0**

<img src=".\media\条件转移指令表.webp" style="zoom:75%;" />



条件转移指令可分为三种：

* ##### 根据单个条件标志的设置情况转移

  <img src=".\media\根据单个条件标志.webp" style="zoom:38%;" />

  

* ##### 比较两个无符号数，并根据比较结果转移

  * 适用于地址（为无符号数）或双精度数低位字（为无符号数）的比较

<img src=".\media\比较两个无符号数.webp" style="zoom:38%;" />



* ##### 比较两个有符号数，并根据比较结果转移

  * 参考有符号数的 CMP 指令或减法指令对 SF/OF 的影响
  *  适用于有符号数的比较

<img src=".\media\比较两个带符号数.webp" style="zoom:38%;" />



### 循环指令：`LOOP`、`LOOPZ/LOOPE`、`LOOPNZ/LOOPNE`

- ##### 循环指令：**LOOP   OPR**

  测试条件：(CX) ≠ 0

  

- ##### 为零或相等时循环指令：**LOOPZ(LOOPE)   OPR**

  测试条件：ZF=1 且 (CX) ≠ 0

  

- ##### 不为零或不相等时循环指令：**LOOPNZ(LOOPNE)   OPR**

  测试条件：ZF=0 且 (CX) ≠ 0

  

- 执行步骤：

  - (CX) ← (CX) - 1   
  - 检查是否满足测试条件，如满足则 (IP) ← (IP) + 8 位位移量，实行循环；不满足则 IP 不变，退出循环；
    - **LOOP  AGAIN** 等价于 **DEC  CX；JNZ  AGAIN**，可以进行等价替换

- 注意：

  - CX 中存放循环次数；

  - 只能使用段内直接寻址的 8 位位移量；

  - LOOP 不影响 CF 和 ZF 位；

    

  #### 两种多重循环的方式：

<img src=".\media\CX计数器的保存和恢复.webp" style="zoom:38%;" />



### 子程序调用和返回指令：`CALL`、`RET`

##### 子程序调用和返回的执行过程
- 保护断点；
  - 将调用指令的下一条指令的地址（断点）压入堆栈
- 获取子过程的入口地址；
  - 子过程第1条指令的偏移地址
- 执行子过程，含相应参数的保存及恢复；
- 恢复断点，返回原程序；
  - 将断点偏移地址由堆栈弹出



段间调用需要同时保护 CS 和 IP：

<img src=".\media\子过程调用和返回.webp" style="zoom:38%;" />



#### `CALL` 调用指令：

- 段内直接近调用：**CALL  DST**（其中 DST 为子程序名）

  - 执行操作： **(SP) ← (SP) – 2              ; 断点压入堆栈**

  ​                           **( (SP)+1,(SP) ) ← (IP)     ; 主程序地址压栈**

  ​                           **(IP) ← (IP) + 16 位位移量**

  - 注意：IP为Call指令的下一条指令的地址，其与 DST 子程序的地址间的相对地址或位移量是固定的

    

- 段内间接近调用：**CALL  DST**，其中 DST 为寄存器（如 BX）或存储器地址（如 WORD PTR [BX]）

  - 执行操作： **(SP) ← (SP) – 2**

  ​                           **( (SP)+1, (SP) ) ← (IP)**

  ​                           **(IP) ← (EA)     ; (DST为内存地址)**



#### `RET` 返回指令

- 段内近返回：**RET**

- 功能：将堆栈中保存的2字节断点的偏移地址恢复IP中，CS不变

  - 执行操作： **(IP) ← ( (SP)+1, (SP) )** 

    ​                    **(SP) ← (SP) + 2**

- 段内带立即数近返回：**RET  EXP**

  - EXP 表示弹出断点之后，使 SP 内容再回退 EXP 个字节单元，作用是 **使断点之后的 EXP 个字节单元分数据失效**（区别于带参数返回，主要作用是回退堆栈，使之前入栈内容失效）



<img src=".\media\子过程例题.webp" style="zoom:38%;" />





### 中断与中断返回指令：`INT`、`INTO`、`IRET`

8086 中断系统最大支持 256 个中断，每个中断具有唯一的中断号，且具有独立的中断服务程序；

发生中断时，CPU 当前程序被暂停，转而执行中断处理程序；

<img src=".\media\8086中断表.webp" style="zoom:48%;" />



#### **中断向量**

- 中断向量是中断例行程序的入口地址，存放于中断向量区，指向中断服务程序的段值和偏移量（CS:IP）；
- CPU 在执行 `INT` 指令时，从中断向量表中取出相应的值赋值给 CS 和 IP，转去执行中断服务程序。这些操作是由硬件直接实现的，把它称为中断隐指令，其操作过程程序员不可见；程序员能够做的就是修改中断向量表中存储的值。
- 中断隐指令并不是指令系统中的一条真正的指令，它没有操作码，所以中断隐指令是一种特殊指令。



（在 8086 中，reset 不算是中断，不在中断向量表内）



#### 中断指令格式：`INT   TYPE` 或  `INT`（没有类型号就默认调用 3 号中断）

- 隐含的操作：**(SP) ← (SP) - 2**

  ​                       **( (SP)+1, (SP) ) ← (FLAGS)**

  ​                       **(SP) ← (SP) - 2**

  ​                       **( (SP)+1, (SP) ) ← (CS)**

  ​                       **(SP) ← (SP) - 2**

  ​                       **( (SP)+1, (SP) ) ← (IP)**

  ​                       **(IP) ← (TYPE\*4)**

  ​                       **(CS) ← (TYPE\*4+2)**

- 注意：

  - TYPE (0~255) 是中断类型号



#### 中断返回指令：**`IRET`**

- 执行操作： **(IP) ← ( (SP)+1,(SP) )** 

  ​                    **(SP) ← (SP) + 2**

  ​                    **(CS) ← ( (SP)+1,(SP) )** 

  ​                    **(SP) ← (SP) + 2**

  ​                    **(FLAGS) ← ( (SP)+1,(SP) )** 

  ​                    **(SP) ← (SP) + 2**

  - `INT` 指令还把 IF 和 TF 置0，但不影响其它标志位
  - `IRET` 指令执行完，标志位由堆栈中取出的值确定



#### 溢出中断指令：**`INTO`**

- 执行操作：**若 OF=1**，则 **(SP) ← (SP) - 2**

  ​                                          **( (SP)+1, (SP) ) ← (FLAGS)**

  ​                                          **(SP) ← (SP) - 2**

  ​                                          **( (SP)+1, (SP) ) ← (CS)**

  ​                                          **(SP) ← (SP) - 2**

  ​                                          **( (SP)+1, (SP) ) ← (IP)**

  (最后两步不一样)

  ​                                          **(IP) ← (10H)**

  ​                                          **(CS) ← (12H)**



### 处理机控制指令

#### 标识处理指令

- ##### `CLC`、 `STC`、 `CMC`：对CF位清零/置位/取反

- ##### `CLD`、`STD`：字符串移动方向增/减标志

- ##### `CLI`、`STI`：开/关中断  



#### 其他处理机控制与杂项操作指令

##### 空操作指令：`NOP`

该指令没有的显式操作数，主要起延迟下一条指令的执行，只是占用一条指令的时间，不影响任何标志位。



##### 等待指令：`WAIT`

该指令使CPU处于等待状态，直到协处理器(Coprocessor)完成运算，并用一个重启信号唤醒CPU为止。该指令的执行不影响任何标志位。 

* 协处理器不算外设，而是另一个FPU（浮点运算器）



##### 暂停指令：`HLT`

在等待中断信号时，该指令使CPU处于暂停工作状态【低功耗模式】，CS:IP指向下一条待执行的指令，但不进行任何操作，保持先前操作中所有寄存器的状态不变 。

当产生了中断信号，CPU把CS和IP压栈，并转入中断处理程序。在中断处理程序执行完后，中断返回指令IRET弹出IP和CS，并唤醒CPU执行下条指令。指令的执行不影响任何标志位。

* 实验箱用不了，但这个指令本身有意义



##### 封锁数据指令：`LOCK` 

格式：**LOCK INSTRUCTION**

该指令是一个前缀指令形式，后面跟一个具体的操作指令；
LOCK指令可以保证是在其后指令执行过程中，禁止协处理器修改数据总线上的数据，起到独占总线的作用。

该指令的执行不影响任何标志位。




## 习题课（作业 1 ~ 作业 3）

- 寄存器和立即数寻址没有物理地址
- 汇编机器中数字一律以补码形式储存，**DB -12H** 记成 **0EEH**  
- 一个 Byte 只能放一个字母的 ascii 码值
- 定义字符串可以后加 `,’$’`，类似于 C 语言的 `\0`，代表显示字符串结束



课堂小测题：

1、指出下列指令的错误

(1)	**MOV	AH,BX**                                 错，位宽不匹配

(2)	**MOV	[BX],[SI]**                              错，不能在内存之间mov

(3)	**MOV	AX,\[DI][SI]**                          错，DI和SI都是变址寄存器

(4)	**MOV	MYDAT\[BX][SI],ES:AX**      错，1.两个内存不能mov，2.AX不能进行段超越，应该是ES:[BX]

(5)	**MOV	CS,AX**                                  错，CS不能用mov改变



2、下列哪些指令是非法的

(1)	**CMP	15,BX**                                  错，第一个不能是立即数

(2)	**CMP	BYTE PTR OP1,25**             对

(3)	**CMP	OP1,OP2**                            错，不能同时是存储器寻址

(4)	**CMP	AX,OP1**                               对



## 5. 汇编程序的结构设计



### 编写汇编代码的一般步骤

1. 分析题意，确定算法
2. 确定解决问题的思路和方法
3. 根据算法画出程序框图
4. 根据框图编写程序
5. 上机调试程序



#### 两个常用中断指令调用

参考 [中断功能表（全英文）](https://github.com/Sayaka-4987/Notes_for_BJTU_Finals/blob/main/21-Fall-%E6%B1%87%E7%BC%96%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0.md#%E4%B8%AD%E6%96%AD%E5%8A%9F%E8%83%BD%E8%A1%A8%E5%85%A8%E8%8B%B1%E6%96%87) 部分；

- ##### `INT 21H`，功能号 `02H`
  向显示屏幕上输出来自 DL 的单个字符；

```assembly
MOV  DL, 'A' 	; 调用参数: 输出字符 ‘A’ 
MOV	 AH, 02	    ; DOS功能号: 显示输出
INT	 21H		; DOS调用
```



- ##### `INT 21H`，功能号 `09H`
  向显示屏幕上输出来自 DX 的字符串；

```assembly
STR	DB ‘computer’, ‘$’	 ;在数据段定义

MOV	DX, OFFSET STR        ; 调用参数: 输出字符串 ‘computer’ 
MOV	AH, 09H               ; DOS功能号: 显示输出串
INT	21H 	              ; DOS调用
```



### 分支结构程序设计

首先需要理明白程序逻辑；

#### 分支程序涉及的条件转移指令

##### 无条件转移指令 `JMP`

功能：无条件地使程序转移到指定的目标地址

<img src=".\media\JMP类型表.webp" style="zoom:38%;" />



例：不同类型的 `JMP` 指令

```assembly
JMP  NEXT                ; 段内直接转移
JMP  SHORT LP1           ; 段内直接转移，LP1 为短距离标号
JMP  AX                  ; 段内间接转移，IP ← AX
JMP  [BX]                ; 段内间接转移，IP ← [BX+1][BX]
JMP  LABLE_NAME          ; 段间直接转移，LABEL_NAME 标号在其他代码段
JMP  DWORD PTR[BX][SI]   ; 段间间接转移，DWORD PTR 说明后面是双字数据
```



##### 条件转移指令 

<img src=".\media\条件转移指令表.webp" style="zoom:75%;" />



例：字符比较程序，两个字符相同时，显示 YES ；否则显示 NO ；

```assembly
DATA SEGMENT
  D1   DB ‘A’
  D2   DB ‘B’
  RES1 DB ‘YES’, ’$’
  RES2 DB ‘NO’,  ’$’
DATA ENDS
CODE SEGMENT	
ASSUME CS:CODE,
	   DS:DATA
START: MOV AX,DATA
       MOV DS,AX
       MOV AL,D1
       MOV BL,D2    
       CMP AL,BL 
       JNE NEXT1
       LEA DX,RES1 
       JMP NEXT2         
NEXT1: LEA DX,RES2
NEXT2: MOV AH,09H
       INT 21H
       MOV AH,4CH
       INT 21H
CODE ENDS
     END START
```



例：设存储单元 A 和 B 各有一 **无符号字节数**，比较大小，将较大数送A单元

```assembly
DATA  SEGMENT
  A   DB 39H             
  B   DB 0B4H
DATA  ENDS

CODE  SEGMENT	
      ASSUME CS:CODE,DS:DATA
START:MOV AX,DATA
      MOV DS,AX
      MOV AL,A
      CMP AL,B
      JNB NEXT
      XCHG AL,B
      MOV A,AL
NEXT: MOV AH,4CH
      INT 21H	
CODE ENDS
     END START
```



#### 分支程序的 CASE 和 IF-THEN-ELSE 结构

实现方法：

1. 用多个双分支结构实现多分支结构
2. 利用地址表法实现多分支结构（存指令入口地址）
3. 利用转移表法实现多分支结构（存指令）
4. 利用逻辑分解法实现多分支结构



例：计算符号函数 SNG（X）的值

```assembly
DATA   SEGMENT
   X   DB 0B9H
   Y   DB ?
DATA   ENDS
CODE   SEGMENT	
       ASSUME CS:CODE,DS:DATA 
START: MOV AX,DATA
       MOV DS,AX
       MOV AL,X
       CMP AL,0
       JL NEXT1
       CMP AL,0
       JG NEXT2      	
       MOV Y,0 	   	; 0 送 Y
       JMP RES	  
NEXT1: MOV Y,0FFH	; -1 送 Y    
       JMP RES
NEXT2: MOV Y,1	   	; 1 送 Y
    RES: MOV AH,4CH
         INT 21H
CODE  ENDS
      END START
```



#### 地址表法

设计方法：把各分支程序段的入口地址依次存放在 **数据段用 `ADTAB` 定义的一个表中**，形成地址表，取各分支程序段的编号作为各分支入口地址的表地址的位移量；

某个分支程序入口地址的表地址为：**表地址 = 编号 * 2（IP 是 16 位，占两个字节）+ 入口地址首地址**



例：用地址表法编写程序实现从低到高逐位检测一个字节数据，找出第一个非0的位数；

检测时，为0则继续检测，为1则转移到对应的处理程序段显示相应的位数；

```assembly
DATA   SEGMENT
    NUM   DB 78H
    ADTAB DW AD0,AD1,AD2,AD3,AD4,AD5,AD6,AD7
DATA   ENDS

CODE   SEGMENT
       ASSUME CS:CODE,DS:DATA
       
START: MOV AX,DATA
       MOV DS,AX
       MOV AL,NUM
       MOV DL,'?'
       CMP AL,0
       JZ DISP
       MOV BX,0
       
AGAIN: SHR AL,1
       JC NEXT
       INC BX
       JMP AGAIN
       
 NEXT: SHL BX,1        
       JMP ADTAB[BX]
       
  AD0: MOV DL,’0’ 
       JMP DISP
  AD1: MOV DL,’1’
       JMP DISP
  AD2: MOV DL,’2’
       JMP DISP
  AD3: MOV DL,’3’
       JMP DISP
  AD4: MOV DL,’4’
       JMP DISP 
  AD5: MOV DL,’5’
       JMP DISP
  AD6: MOV DL,’6’
       JMP DISP
  AD7: MOV DL,’7’
  
 DISP: MOV AH,2
       INT 21H
       MOV AH,4CH
       INT 21H
CODE ENDS
     END START 
```



#### 转移表法

设计方法：把转移到各分支程序段的转移指令依次存放在一起，用 `TAB: ` 开头，作为转移表；

使用时，以各转移指令在表中的位置，即离表首地址的偏移量，作为转移条件，偏移量加上表首地址作为转移地址，转到表的相应位置，执行相应的无条件转移指令；

转移表中每条转移指令（段内短转移）占用2个字节，计算公式如下：**表地址 = 模式字 * 2 + 转移表首地址**



例：根据输入值（0~4）的不同，执行不同的操作，用转移表法编写程序

```assembly
CODE   SEGMENT
       ASSUME CS:CODE
START: LEA BX,TAB    ; 转移表首地址送BX
       MOV AH,1           
       INT 21H       ; 输入字符送AL  
       SUB AL,30H    ; 字符变数字
       MOV AH,0
       ADD AX,AX     ; 模式字*2送AX
       ADD BX,AX
       JMP BX
       
  TAB: JMP SHORT MODE0    ; 转移表
       JMP SHORT MODE1
       JMP SHORT MODE2
       JMP SHORT MODE3
       JMP SHORT MODE4 

MODE0: MOV DL,30H
       JMP EXIT
MODE1: MOV DL,31H
       JMP EXIT
MODE2: MOV DL,32H
       JMP EXIT
MODE3: MOV DL,33H
       JMP EXIT
MODE4: MOV DL,34H

     EXIT: MOV AH,2
           INT 21H
           MOV AH,4CH
           INT 21H
           
CODE  ENDS
      END START
```



#### 逻辑分解法

设计方法：将多分支结构采用逻辑等效的方法，按条件的先后，依次分解成一串双分支结构，然后再使用双分支的方法来进行程序设计；

例：根据AL中的值（0~4），执行不同的操作，但用逻辑分解法编写程序    

```assembly
DATA  SEGMENT
      NUM   DB 2
DATA  ENDS

CODE  SEGMENT
ASSUME CS:CODE,DS:DATA
START: MOV AX,DATA
       MOV DS,AX
       MOV AL,NUM
       CMP AL,0
       JZ NEXT0
       CMP AL,1       
       JZ NEXT1
       CMP AL,2
       JZ NEXT2
       CMP AL,3
       JZ NEXT3
       CMP AL,4
       JZ NEXT4
NEXT0: MOV DL,30H
       JMP EXIT
NEXT1: MOV DL,31H
       JMP EXIT
NEXT2: MOV DL,32H
       JMP EXIT
NEXT3: MOV DL,33H
       JMP EXIT
NEXT4: MOV DL,34H
    EXIT: MOV AH,2
          INT 21H
          MOV AH,4CH
          INT 21H
CODE ENDS
     END START
```







### 循环结构程序设计

<img src=".\media\循环程序的两种结构.webp" style="zoom:38%;" />

循环结构包括这些部分：

- 初始化：设置循环的初始状态
- 循环体：循环的工作部分及修改部分
- 控制条件：
  - 计数控制
  - 特征值控制
  - 地址边界控制



可以用分支指令控制循环：

```assembly
DATA  SEGMENT
  STR  DB ’computer$’
  LEN  DB ?
DATA  ENDS

CODE  SEGMENT
      ASSUME CS:CODE,DS:DATA
START:
    MOV AX,DATA	
    MOV DS,AX
    LEA SI,STR		    ; 串首地址
    XOR BL,BL		    ; 计数器清0
    LOP:
        MOV AL,[SI]	    ; 取一个字节
        CMP AL,24H      ; 和’$’进行比较
        JZ STOP         ; 相等则结束
        INC BL          ; 否则计数器加1
        INC SI          ; 地址指针加1
        JMP LOP         ; 转回到LOP
    STOP:
        MOV LEN,BL  ; 存储字符个数
        MOV AH,4CH 
        INT 21H
CODE  ENDS	
      END START
```



#### 用专用的循环指令控制循环

循环指令执行步骤： 

1.  **(CX)  ←  (CX) - 1**

2.  检查是否满足测试条件，如满足则 (IP) ← (IP) + 8 位位移量，实行循环；不满足则 IP 不变，退出循环；



注意：`LOOP` 指令执行时，CX 是否为 0 不影响 ZF 和 CF 的变化，等价于 `DEC` 指令；所以 `LOOP` 指令和 `LOOPNZ` 指令才有区别；

| 指令                        | 转移条件                   | 说明                 |
| --------------------------- | -------------------------- | -------------------- |
| **`LOOP  OPR`**             | 测试条件：(CX) ≠ 0         |                      |
| **`LOOPZ (LOOPE)   OPR`**   | 测试条件：ZF=1 且 (CX) ≠ 0 | 为零或相等时循环     |
| **`LOOPNZ (LOOPNE)   OPR`** | 测试条件：ZF=0 且 (CX) ≠ 0 | 不为零或不相等时循环 |



例：求以 BUF 为首地址的10个内存单元的无符号数据和。已知其和小于等于 255，将结果存入第 11 个内存单元

```assembly
DATA  SEGMENT
  BUF  DB 12H,38H,46H,0BH,09H,41H,32H,56,02H,26H
  RES  DB ?
DATA  ENDS
CODE  SEGMENT
      ASSUME CS:CODE,DS:DATA
START: 
    MOV AX,DATA	
    MOV DS,AX
    MOV AL,0	; 存放累加之和
    MOV CX,0AH  ; 累加次数
    LEA BX,BUF  ; 数据表的首地址	
    LP: 
        ADD AL,[BX]          ; 累加
        INC BX          	 ; 地址增1     	
        LOOP LP              ; 若CX-1不为0，则继续循环
    MOV RES,AL 	         ; CX-1=0，则存累加和 
    MOV AH,4CH
    INT 21H
CODE  ENDS	
      END START
```



例：在字节数组中找出第一个非 0 的数据，并将其下标存入 RES 单元，假设其下标值小于 10 

```assembly
DATA  SEGMENT
  ARR  DB 0,0,38H,46H	
       DB 89H,67H,0H,92H
  CNT  EQU $–ARR
  RES  DW ?
DATA  ENDS
CODE  SEGMENT	
      ASSUME CS:CODE,DS:DATA
START: 
    MOV AX,DATA
    MOV DS,AX
    MOV CX,CNT   ; 循环次数为 CNT 数组长度
    MOV DI,-1    ; 数组下标从 0 开始
AGAIN: 
    INC DI                                       
    CMP ARR[DI],0       ; 和0比较
    LOOPZ AGAIN         ; 为0，且没比较完，则循环
    JZ EXIT             ; 比较完仍为0，转 EXIT
    MOV RES,DI          ; 找到了，送下标号到 RES
EXIT: 
    MOV AH,4CH
    INT 21H 
CODE  ENDS
      END START
```



#### 按问题的条件控制循环

含义：用转移指令来判断循环条件

应用场合：循环次数不确定



例：记录某个字节存储数据单元中1的个数，并把结果存入RES中

```assembly
DATA  SEGMENT
  NUM  DB  75H
  RES  DB  ?
DATA  ENDS   

CODE  SEGMENT
      ASSUME CS:CODE,DS:DATA
START:
    MOV AX,DATA        
    MOV DS,AX
    MOV BL,NUM    	
    XOR DL,DL    ; DL清零    
    AGAIN:
        TEST BL,0FFH
        JZ NEXT      ; 判断数据是否0
        SHR BL,1     ; 逻辑右移1位
        ADC DL,0     ; 带进位加法
        JMP AGAIN
NEXT:
    MOV RES,DL
    MOV AH,4CH
    INT 21H		
CODE  ENDS	       
      END START
```



#### 按逻辑变量控制循环

含义：用转移指令来判断循环条件

应用场合：控制转入不同的循环支路

方法：把逻辑变量送入寄存器中，以逻辑变量各位的状态作为执行某段程序的标志



例：在以 BUF 为起始地址的内存中放有若干个字节型无符号数，假定某逻辑变量的长度为一个字节（其值为10010101），它的 D0 \~ D7 位对应着 BUF \~ BUF + 7 单元内容的运算。即某位为 0，则将相应单元内容的最高位求反，其它位不变；而某位为 1，则将相应单元内容之高低四位互换

```assembly
DATA  SEGMENT
 BUF  DB 75H,12H,87H,98H
      DB 81H,56H,73H,51H
  B   EQU 8
  C   EQU 10010101B
DATA  ENDS	

CODE  SEGMENT	                          
      ASSUME CS:CODE,DS:DATA
START:
    MOV AX，DATA        
    MOV DS,AX            
    MOV AH,B       ; 指示数据个数
    MOV CH,C
    LEA BX,BUF
LP:
    MOV AL,[BX]      
    SHR CH,1
    JNC NEXT       ; CF=0跳转
    MOV CL,4
    ROL AL,CL      ; 高低位交换
    JMP RES
    
NEXT:
    XOR AL,80H     ; 高位取反
    
RES:
    MOV [BX],AL 
    INC BX
    DEC AH         ; 数据个数-1
    JNZ LP         ; 未读完则继续
    MOV AH,4CH
    INT 21H
    
CODE ENDS
     END START
```



<img src=".\media\例8配图.webp" style="zoom:48%;" />



#### 多重循环程序设计

含义：指循环体内还有循环，也就是嵌套循环

注意：(1) 不允许循环结构交叉；(2) 转移指令只能从循环结构内转出或可在同层循环内转移



例：设在以 EXST 为首址的存储区中依次存放着某考区 245 个理科生的七门成绩，现要统计每个考生的总成绩，并将其存放在该考生单科成绩之后的两个单元

```assembly
DATA  SEGMENT
    EXST  DB 01,75,82,84,92,78,49,85,00,00
          DB 02,83,92,63,76,82,58,69,00,00
    ……      
DATA  ENDS   

CODE  SEGMENT                                                            
    ASSUME CS:CODE,DS:DATA                               
    MOV AX,DATA                                                     
    MOV DS,AX
START:
    LEA SI,EXST		; 数据表首地址
    MOV BL,245  	; 245个学生，外循环次数
    LOP2: 
        MOV CX,7        ; 七门课成绩，内循环次数 
        XOR AX,AX		; 清0，存总成绩
        INC SI     		; 跳过准考证号
        LOP1: 
            ADD AL,[SI]	    ; 单科成绩累加
            ADC AH,0	    ; 加进位位
            INC SI 		    ; 修改地址指针
            LOOP LOP1       ; 没累加完单科成绩，则继续   
        MOV WORD PTR [SI],AX   ; 累加完，存总成绩
        INC SI 		           ; 跳过存总成绩的2个单元               
        INC SI                                     
        DEC BL 		           ; 外循环次数减1
        JNZ LOP2		       ; 不为0，则求下个学生总成绩              
    MOV AH,4CH             
    INT 21H
CODE  ENDS                                           
END  START
```



## 实验 1. Debug 调试

命令不区分大小写；



### DOS 命令

`dir` 显示目录下所有文件夹

`cd [相对路径]` 进入某文件夹

`[文件名].exe` 运行指定可执行文件



### DEBUG 命令

#### “ U ” 命令：将程序反汇编

格式：-`U` 

例：

-`U CS:0` ; 显示不再有伪指令的汇编指令

-`U [开始地址] [终止地址]` ; 显示开始地址到终止地址的指令



#### “ D ” 命令：显示内存单元的内容.

注意：十六进制是 DEBUG 唯一认识的数字系统,键入和输出时十六进制数不用后加 “H”，十进制数后要加 “D” 

D 命令 **默认显示 CS 段的内容**；

格式： -`D [存储单元地址]`    

例：

1. -`D 7A0:100`    ; 显示的信息是段地址是 7A0H 和偏移地址是 100H 开始的内存单元的内容，表示方式是一行 16 个数据，然后是对应的 ASCII 字符
2. -`D DS:0`          ; 显示数据段内容
3. -`D 100 120`    ; 显示从偏移地址100开始到偏移地址120的内存单元



#### “ E ” 命令：修改存储单元的内容

格式：

1.  -`E 存储单元地址 数据 数据 数据 ...`  ;（输入数据后按空格键可连续修改数据）此格式使键入的数据替代了指定范围的存储单元内容
2.  -`E 存储单元地址`       ; 此格式采用逐个存储单元相继修改的方法



#### “ F ” 命令：用一个指定的十六进制数填入一部分存储单元

格式：-`F 开始地址 终止地址 常量`        ;   “F”命令与“E”命令都可修改存储单元的内容,但“F”命令只能键入一串相同的数据。

例：-`F 100 120 4F`



#### “ R ” 命令：检查和修改寄存器的内容

格式：

1. -`R`                       ; 显示CPU内所有寄存器内容和标志位状态
2. -`R 寄存器名字`   ; 显示和修改某个寄存器的内容
3. -`RF`                    ; 显示和修改标志位状态



#### “ A ” 命令：输入汇编语句

格式：-`A [开始存放指令的地址]`    ; 可以键入汇编语言语句，并能把它汇编成机器代码，相继放入从指定地址开始的存储器中，回车键退出，回到 DEBUG 提示符下



#### “ T ” 命令：跟踪命令

格式：

1. -`T [=指令地址]`   ; 功能：从指定的地址起执行一条指令后停下来，显示所有寄存器内容及标志位的值；从当前的 CS:IP 开始单步执行
2. -`T [=指令地址][要执行的指令条数N]`   ; 功能：从指定地址开始执行 N 条指令后停下来显示

注意：要跳过 INT 中断指令正常运行



#### “ G ” 命令：运行命令

格式：-`G=<地址>,<断点>`       ; 从起始地址 0 开始运行，在断点地址 1C 处停止，并显示指令从 0 开始，到断点 1C 执行后，所有寄存器及标志位内容，以及下一条要执行的指令

例：-`G=0,1C`



#### “ Q ” 命令：退出 DEBUG 命令符模式

格式：-`Q` 

注意：Q 命令不存盘



<img src=".\media\标志位取值.webp" style="zoom:33%;" />



## 6. 子程序结构

###  `CALL` 调用指令

- 段内直接近调用：`CALL  DST`（DST 为子程序名）
  - 执行操作：
                                        **(SP) ← (SP) – 2           ;断点压入堆栈**
                                        **( (SP)+1,(SP) ) ← (IP) ; 主程序地址压栈**
                                        **(IP) ← (IP) + 16位位移量**
  - 注意：IP 为 Call 指令的下一条指令的地址，其与 DST 子程序的地址间的相对地址或位移量是固定的



- 段内间接近调用：`CALL  DST`（DST 为寄存器如 BX，或存储器地址 WORD PTR [BX]）
  - 执行操作：
                           **(SP) ← (SP) – 2**
                           **( (SP)+1,(SP) ) ← (IP)**
                           **(IP) ← (EA) (DST为内存地址)**



### `RET` 返回指令

- 段内近返回：`RET`
  - 功能：将堆栈中保存的2字节断点的偏移地址恢复 IP 中，CS 不变
  - 执行操作：
                        **(IP) ← ( (SP)+1,(SP) )** 
                        **(SP) ← (SP) + 2**



- 段内带立即数近返回：`RET  EXP`
  - 功能：EXP 表示，弹出断点之后，使 SP 内容再回退 EXP 个字节单元，作用是使断点之后的 EXP 个字节单元分数据失效



### 过程定义伪操作

格式：

```assembly
[过程名] PROC (NEAR/FAR)

……

[过程名] ENDP
```



#### `NEAR` 段内调用

调用程序和子程序在同一代码段中



#### `FAR` 段间调用

调用程序和子程序不在同一代码段中              

 

#### 使用场合

<img src=".\media\段内和段间调用.webp" style="zoom:50%;" />



### 子程序的调用与返回

子程序调用会隐含使用堆栈保存返回地址

- `call  near ptr  subp`
  - 保存返回地址：仅offset地址
  - 转子程序
- `call  far  ptr  subp`
  - 保存返回地址：seg + offset
  - 转子程序



#### 保存与恢复寄存器

```assembly
subt   proc    near（far）
        push    ax
        push    bx
        push    cx
        push    dx
        ……
        ……
        pop     dx
        pop     cx
        pop     bx
        pop     ax
        ret
subt   endp
```



### 子程序的参数传递方法



#### 通过寄存器传送参数

- 把参数存于 **约定的寄存器** 中，可以传值，也可以传址
- 子程序对带有出口参数的寄存器 **不能** 保护和恢复（主程序视具体情况进行保护）
- 子程序对带有入口参数的寄存器可以保护，也可以不保护，但最好一致
- 寄存器参数传递特点：
  - 简单方便，只需约定寄存器即可
  - 寄存器的个数和容量非常有限，适用于传递较少的参数信息



例：将给定的一组字数据X、Y代入Z=((X+Y)×2-X)×4 公式中，计算相应的Z值。假设Z的值不会超过16位。

```assembly
DATA SEGMENT
   X   DW 5,3,8,9,2,5,3,4,7,1
   Y   DW 1,5,7,0,4,3,1,4,8,1
   Z   DW 10 DUP (?) 
DATA ENDS 
CODE SEGMENT
    ASSUME CS:CODE, DS:DATA
START:
    MOV AX,DATA
    MOV DS,AX
    LEA SI,X
    LEA DI,Y
    LEA BX,Z
    MOV CX,Y-X   ; 字节数
    SHR CX,1     ; 字数/数组个数
REAPT:
    MOV AX,[SI]
    MOV DX,[DI]
    CALL SUBR
    MOV [BX],AX
    ADD SI,2
    ADD DI,2       
    ADD BX,2
    LOOP REAPT
EXIT:
    MOV AH,4CH
    INT 21H
    SUBR PROC NEAR
          PUSH BX 
          PUSH CX
          MOV BX,AX
          ADD AX,DX    ; AX=X+Y
          SAL AX,1     ; AX=(X+Y)×2
          SUB AX,BX    ; AX=(X+Y)×2-X
          MOV CL,2
          SAL AX,CL    ; AX=((X+Y)×2-X)×4 
          POP CX
          POP BX
          RET
    SUBR ENDP
CODE ENDS
     END START
```



#### 通过存储单元传送参数

- 约定存储单元交互信息，即主程序和子程序直接采用同一个变量名，共享同一个变量，实现参数的传递
- 可以在调用程序与子程序间传递大量数据



例：累加数组中的元素

```assembly
data  segment
    ary     dw   1,2,3,4,5,6,7,8,9,10
	count   dw   10
	sum     dw   ?

	ary1    dw   10,20,30,40,50,60,70,80,90,100
	count1  dw   10
	sum1    dw   ?
data  ends

code segment
    assume cs:code,ds:data
main:mov ax,data
    mov ds,ax

    lea si,ary
    mov cx,count
    call proadd
    mov sum,ax

    lea si,ary1
    mov cx,count1
    call proadd
    mov sum1,ax

    mov ax,4c00h
    int 21h
code ends
    end main

proadd proc near
	xor ax,ax
    next:  
        add ax,[si]
      	add si,2
      	loop next
	ret
proadd endp
```



#### 通过堆栈传送参数或参数地址

- 操作：
  - 主程序将子程序的入口参数压入堆栈，子程序从堆栈中取出参数；
  - 子程序将出口参数压入堆栈，主程序弹出堆栈取得它们；
- 适用于参数较多，子程序有多层嵌套、递归调用的情况
- 步骤：
  - 主程序把参数或参数地址压入堆栈；
  - 子程序使用堆栈中的参数或通过栈中参数地址取到参数（用 BP 访问堆栈段）；
  - 子程序返回时使用 RET n 指令，调整 SP 指针，以便删除堆栈中已用过的参数，保持堆栈平衡，保证程序的正确返回。



<img src="media/image-20211013113725823.webp" alt="image-20211013113725823" style="zoom:33%;" />

例：累加数组中的元素

```assembly
data  segment
      ary    dw 10,20,30,40,50,60,70,80,90,100
      count  dw 10
      sum    dw ?
data  ends

stack segment   
      dw   100    dup (?)    ; 首个字节地址为SS首地址；
      tos  label  word       ; 定义 tos 为栈底，其具体值相当于$
stack ends                   ; 因为使用到堆栈段来传递参数，所以要先定义STACK

code1 segment
main  proc far
      assume cs:code1,ds:data,ss:stack
start:
      mov ax,stack
      mov ss,ax    
      mov sp,offset tos  ; 初始时栈顶与栈底地址相同，为SS:SP
      mov ax,data
      mov ds,ax
      mov bx,offset ary  ; 通过堆栈传递参数时要先将参数地址压入栈中
      push bx
      mov bx,offset count
      push bx
      mov bx,offset sum
      push bx
      call far ptr proadd
      mov ax,4c00h
      int 21h
main  endp
code1 ends

code2    segment
  assume cs:code2

proadd   proc  far
  push  bp
  mov   bp, sp

  push  ax
  push  cx
  push  si
  push  di

  mov   si,[bp+0ah]
  mov   di,[bp+8]
  mov   cx,[di]
  mov   di,[bp+6]
  xor   ax, ax
next:
  add   ax, [si]
  add   si, 2
  loop  next
  mov   [di],ax

  pop   di
  pop   si
  pop   cx
  pop   ax

  pop   bp

  ret   6 ; (SP)<-(SP)+6,即废除压入栈中的ARY/COUNT/SUM,清空栈

proadd  endp

code2    ends
         end start
```



#### `LABEL` 伪指令

含义： 为本伪指令之后的标号/变量定义 **一个不同类型的别名**

用法： 变量/标号 LABEL 类型(byte, word, dword, near, far)

例：

```assembly
VAR LABEL WORD
X  DB  "AB"   ; 变量 VAR 和其后的 X 指向内存中的同一单元，但两者类型分别为 WORD 类型、BYTE 类型；

MOV AX, VAR   ; 等价于 MOV AX, 4241H
MOV AL,  X    ; 等价于 MOV AL, 41H
```



### 多模块之间的参数传递

在某一个模块中定义，而在另外一个模块中引用的符号称为外部符号；



#### `PUBLIC` 伪指令

- 格式：`PUBLIC 符号[,...]` 
- 说明：在一个模块中定义的符号（变量、标号、过程名）在提供给其他模块使用时，必须要用 PUBLIC 定义该符号为外部符号



#### `EXTRN` 伪指令

- 格式： `EXTRN 符号:类型[,...]` 
- 说明：在另一个模块中定义，而要在本模块中使用的符号，必须要用 EXTRN 说明
  - 若符号为标号或过程名，则类型near或far；
  - 若符号为变量，则类型为byte、word、dword等



例：

主程序（lie6d6.asm）

```assembly
public d1,d2,n1			；全局变量定义
extrn  Lie6d6a: far		；外部过程说明
extrn  Lie6d6b: far		；外部过程说明
dat   segment para ‘dat’	；数据段
	d1 db 98h,35h,54h,78h
	n1=$-d1
	d2 db 12h,34h,56h
dat   ends
stac  segment para ‘stack’	；堆栈段
	stal dw 100 dup(?)
stac  ends
code  segment para ‘code’	；代码段
	assume cs: code, ds: dat, ss: stac
sta   proc far
	…
	lea si,d1		      ；全局变量的引用
	lea di,d2
	mov cx,n1
	…
	call Lie6d6a	      ；外部过程的引用
      …
	call Lie6d6b	      ；外部过程的引用
      …
      ret
sta   endp
code  ends
	end sta
```



子程序1  lie6d6a.asm

```assembly
public  Lie6d6a		；全局过程
code    segment para ‘code’
	  assume cs: code
lie6d7a proc far
	  push ax
	  …
	  pop ax
	  ret
lie6d7a endp
   code ends
	  end
```



子程序2   lie6d6b.asm

```assembly
public  Lie6d6b		 ；全局过程
extrn   d1: byte, d2: byte
code    segment para ‘code’
	  assume cs: code
Lie6d7b proc far
	  …
	  lea si,d1		 ；全局变量
	  lea di,d2
	  …
	  ret
Lie6d7b endp
   code ends
	  end
```



<img src="media/image-20211013114605683.webp" alt="image-20211013114605683" style="zoom:50%;" />



## 7. BIOS 和 DOS 中断

### 预备知识

- BIOS（Basic Input/Output System 基本输入输出系统） 

<img src="media/image-20211013115057734.webp" alt="image-20211013115057734" style="zoom: 50%;" />

- 存储系统中从地址 0FE000H～0FFFFFH 的 8KB ROM 中装入的基本输入输出的例行程序，主要包括系统加电自检、引导装入、I/O设备的处理程序以及接口控制功能模块(最接近硬件);

- 包括：
  - 主要的I/O设备处理和接口控制程序
  - I/O设备硬件中断处理程序
  - I/O设备软件中断调用处理程序
  - 许多常用的系统例行程序
  - 系统加电自检、引导装入等功能模块
- 一般以中断处理程序的形式存在、被调用
- 例如：软件中断调用
  - 显示输出：10H号中断处理程序
  - 打印输出：17H号中断处理程序
  - 键盘输入：16H号中断处理程序



- DOS （Disk Operating System 磁盘操作系统）两个功能模块：

  - IBMBIO.COM：I/O 设备处理程序，完成设备到内存或内存到外设数据传送
    - 例如：DOS 调用 BIOS 显示输出程序完成显示输出，调用 BIOS 打印输出程序完成打印输出，调用BIOS键盘输入程序完成键盘输入等
  - IBMDOS.COM：作业管理与监控、文件管理程序、设备处理程序
    - 设备管理与监控：通过 IBMBIO.COM 形成一个或多个 BIOS 调用

  

- DOS 的两个功能模块与 BIOS 之间的关系 ：
  说明：大多数情况下用户调用 DOS 功能调用，少数情况直接调用 BIOS 功能； 



### BIOS 和 DOS 基本调用

调用方法：

1. 将调用参数装入指定的寄存器中；
2. BIOS 或 DOS 功能号装入 AH；
3. 如需子功能号，把它装入 AL；
4. 按中断号调用DOS或BIOS中断 (INT) ;
5. 检查或取得返回参数；



例：DOS调用：键盘输入，显示输出

```assembly
MOV AH, 01   ; DOS功能号:键盘输入 
INT 21H      ; DOS调用
MOV CHAR, AL ; 返回参数: 键入字符的 ASCII码(在AL中)

MOV DL, ’A’  ;调用参数: 输出字符
MOV AH, 02   ;DOS功能号: 显示输出
INT 21H      ;DOS调用
```



#### BIOS键盘中断 `INT 16H`

| **AH** | **功   能**        | **返回参数**                                               |
| ------ | ------------------ | ---------------------------------------------------------- |
| 0      | 从键盘读一字符     | AL = 字符码，AH = 扫描码（对应键盘的物理按键情况）         |
| 1      | 读键盘缓冲区的字符 | 如ZF = 0，AL = 字符码，AH = 扫描码；<br>如ZF = 1，缓冲区空 |
| 2      | 取键盘状态字节     | AL = 键盘状态字节                                          |



例：读取键盘状态字节，并以十六进制打印出来

```assembly
again：
	mov	ah，02h
	int       16h     ；读取键盘状态字节
	mov  	bx,ax
	call    binihex ；该子程序实现二进制和16进制转换

	mov     dl,0dh
	mov     ah,02h
	int       21h      ；显示
	jmp      again
```



#### DOS键盘中断 `INT 21H`

|**AH**|**功能**|**调用参数**|**返回参数**|
|------|--------------------------------------------|------------------------------------------------|-----------------------------------------------------|
|1|从键盘输入一个字符并回显在屏幕上||AL=字符|
|6|读键盘字符，不回显|DL=0FFH|若有字符可取，AL=字符，ZF=0若无字符可取，AL=0，ZF=1|
|7|从键盘输入一个字符，不回显||AL=字符|
|8|从键盘输入一个字符，不回显，检测 Ctrl_Break||AL=字符|
|A|输入字符到缓冲区|DS:DX=缓冲区首址||
|B|读键盘状态||AL=0FFH有键入，AL=00无键入|
|C|清除键盘缓冲区并调用一种键盘功能|AL=键盘功能号(1,6,7,8或A)||



例：DOS调用从键盘输入字符

```assembly
MOV AH, 01    ; DOS功能号:键盘输入 
INT 21H 	  ; DOS调用
MOV CHAR, AL  ; 返回参数:键入字符的ASCII码(AL)
```



例: 输入字符串到缓冲区 STRING

```assembly
DATA   SEGMENT
   MAXLEN   DB   32         ; 定义缓冲区存放字符的字节数
   ACTLEN   DB   ?          ; 预留一个字节，由系统填写实际键入的字符个数
   STRING   DB   32 DUP(?)  ; 32个字节空间存放键入的字符数
DATA   ENDS

CODE	SEGMENT
   ASSUME CS:CODE,DS:DATA
START:	MOV	AX,DATA
	MOV	DS,AX
	LEA	DX,MAXLEN ; 把MAXLEN所在地址赋值给DX；并且21H的0A号 功能规定了缓冲区的长度设置、存放的内容和顺序，回车符（0DH）表示输入结束，见右上图
	MOV	AH,0AH    ; 屏幕出现光标，让用户输入字符串！
	INT	21H
CODE	ENDS
	END	START
```



#### DOS显示功能调用中断 `INT  21H`
|**AH**|**功能**|**调用参数**|
|------|--------------------------------|------------------------------------------------------------|
|2|显示一个字符(检验 Ctrl-Break)|DL=字符<br/>光标跟随字符移动|
|6|显示一个字符(不检验 Ctrl-Break)|DL=字符<br/>光标跟随字符移动|
|9|显示字符串|DS:DX=串地址，**串必须以 `$` 结束**<br>光标跟随串移动|



例：显示字符串

```assembly
MESSAGE DB "Thesortoperationisfinished.",13,10,'$'
    MOV AH, O9H ; 09H功能号送AH
    MOV DX, SEGMESSAGE
    MOV DS, DX ; 输出缓冲区的段基址装入DS
    MOV DX,OFFSETMESSAGE; 输出缓冲区的偏移地址装入DX
INT 21H
```



# 接口部分



## 8.  I/O 端口地址译码技术

###  I/O 地址空间

- 与存储器空间一样，I/O 地址空间也是一片连续的地址单元，可供各种外设作为与CPU交换信息时存放数据、状态和命令代码之用
- 一个 I/O 地址对应的是接口电路中的一个寄存器或控制器，称为“端口”
-  I/O 地址分配给某个外设后就成为该外设的固有端口地址，其它外设不能使用，否则会发生冲突
  - 为了缓解端口资源紧张，后面也会学到“端口复用”，罕见情况下也有多个外设共用一个端口 
-  I/O 端口与存储器单元一样，以 **字节** 组织数据
- 实模式下， I/O 端口地址线是16位的，范围是 0000H-0FFFFH，共 64K 个可单独寻址的8位端口，2 个相邻的 8 位端口可构成 1 个 16 位端口，4 个相邻的 8 位端口可构成 1 个 32 位端口；16 位端口对应于偶数地址， 32 位端口对应于被 4 整除的地址，8 位端口的地址可以从任意地址开始
- IBM公司在规划微机接口卡时采用非完全译码方式，只考虑低 10 位地址线 A0-A9，所以端口的地址范围是0000H-03FFH 



### I/O 端口

- I/O端口（port) 是接口电路中能被 CPU 直接访问的寄存器的地址；
- CPU 通过这些端口向接口中的寄存器发送命令、读取状态和传送数据。因此，一个接口可以有几个端口，如命令端口、状态端口和数据端口，分别对应于命令(控制)寄存器、状态寄存器和数据寄存器；
- I/O 操作是对 I/O 端口的操作，而不是对 I/O 设备的操作。（同一 I/O 端口可能对应不同的 I/O 设备（共享的情况下），中间有一个选择过程-译码电路）；



<img src="media/image-20211020104128953.webp" alt="image-20211020104128953" style="zoom:50%;" />



<img src="media/image-20211020104212695.webp" alt="image-20211020104212695" style="zoom: 33%;" />



- 从CPU到接口电路中间有一个地址译码电路；
- 地址译码的结果就是产生一个片选信号/CS，/CS是一个低电平脉冲，不持续有效，只在脉冲期间CPU才可以读/写接口内的寄存器，其它时刻CPU并不控制接口电路；
- 另一方面，接口电路可以根据CPU之前写入的数值来独立工作，不依赖于/CS信号是否有效；



### I/O 端口地址编址方式

- 接口内部包含一个或多个CPU可进行读写的寄存器，这些寄存器称为 I/O 端口。数据端口、状态端口和控制端口。

- CPU对外设的各种操作，最终都归结为对接口中各端口的读/写操作，而不是直接对外设进行操作。

- 为了区分不同的端口，需为每个端口分配一个地址编号，称为 I/O 端口地址。

- 由于CPU地址总线既连接到存储器又连接到 I/O 端口，因此，需要一种机制来**区分和寻址**要操作的内存单元或 I/O 端口，这种机制称为编址方式。

- 常用的两种 I/O 编址方式：
  -  I/O 端口与内存独立编址
  -  I/O 端口与内存统一编址



#### 独立编址

<img src="media/image-20211020104955351.webp" alt="image-20211020104955351" style="zoom:33%;" />

- 端口地址单独编址，而不和存储空间合在一起，访问I/O端口使用专门的I/O指令
- IBM-PC系列采用该方式
- 优点：
  - I/O端口地址不占用存储器空间。
  - I/O指令短，执行速度快。
  - 由于专门I/O指令与存储器访问指令有明显的区别，使程序中I/O操作和存储器操作层次清晰，程序的可读性强。
- 缺点：需要专门访问I/O端口的指令。



#### 统一编址

<img src="media/image-20211020105200317.webp" alt="image-20211020105200317" style="zoom:33%;" />

- 从存储器空间中划出一部分地址空间给I/O设备，把I/O接口中的端口当作存储器单元一样进行访问，不设置专门的I/O指令。
- 优点：指令类型多，功能齐全。

- 缺点：
  - 端口占用了存储器的地址空间，使存储器容量减小；
  - 另外，指令长度比专门I/O指令要长，因而执行速度较慢



### 独立编址方式的I/O端口访问

#### I/O指令：`IN` 和 `OUT`

IN指令从I/O端口向AL(AX)输入字节(字）

OUT指令从AL(AX)向I/O端口输出字节(字）

指令格式为： 

```assembly
PORT EQU 0F4H
IN  AL,PORT	 ; 输入
IN  AX,PORT
OUT PORT,AL	 ; 输出
OUT PORT,AX
```

**只能用AX寄存器；**

通常所说的对端口的访问就是CPU对端口的读/写操作，即指I/O端口与CPU的累加器之间的数据传送，并不涉及数据是否传送到存储器的问题

```assembly
; 例如：输入时
      MOV  DX,300H    ; I/O端口
      IN  AL,DX       ; 从DX端口读数据到AL
      MOV  [DI],AL    ; 将数据从AL→存储器
; 例如：输出时   
      MOV  DX,301H    ; I/O端口
      MOV  AL,[SI]    ; 从内存取数到AL
      OUT  DX,AL      ; 数据从AL→端口
```





#### I/O端口寻址方式

- 直接寻址
  - I/O指令直接提供8位I/O地址
  - 只能寻址256个I/O地址（00～FFH）
  - 用i8表示I/O地址，表达形式上与立即数一样
- DX 寄存器间接寻址
  - 用DX寄存器保存访问的I/O地址
  - 可寻址全部I/O地址（0000～FFFFH）
  - 直接书写成DX，表示I/O地址



#### 独立编址方式的端口操作

- 端口地址范围：最多寻址多少个I/O端口
  - 直接寻址：端口地址8位，可寻址256个端口
  - 间接寻址：端口地址16位，可寻址216=64K个端口
  - 例如：MOV  DX, XXXXH      
                IN  AL, DX   ；间接寻址
                IN  AX, 60H ；直接寻址
- 传送数据的宽度：通过累加器所传输的数据位数
              IN AL, DX ；输入8位数据
              IN AX, DX ；输入16位数据

原则：传输字节数据时使用 AL，传输字数据时使用 AX

注意：与指令中的累加器有关，与端口地址范围无关



#### I/O指令与I/O读写控制信号的关系

程序执行IN指令时会在系统总线上产生有效的 $\overline{IOR}$ 信号（低电平有效），完成读(输入)操作； 

执行OUT指令时会在系统总线上产生有效的 $\overline{IOW}$ 信号（低电平有效），完成写(输出)操作

 

### I/O端口地址分配

I/O地址划分成两部分：

- 0000H-03FFH留给微机系统和ISA总线；
- 0400H-0FFFFH给用户应用、主板功能和PCI总线使用。

前者作为专用端口分配给相应的设备，后者由PNP即插即用机制和操作系统动态分配和管理。         



#### 实模式下I/O地址的分配

PC微机把I/O空间分成两部分：系统板上的可编程接口芯片端口地址和常规外设接口控制卡端口地址。

PC微机采用独立编址方式，I/O地址线有16根，对应的I/O端口编址可达64K。而IBM只用了低10位地址线（即A0-A9），所以I/O端口的地址范围是：0000H-03FFH，总共只有1024个端口。



<img src="media/image-20211020110914544.webp" alt="image-20211020110914544" style="zoom:33%;" />



<img src="media/image-20211020110927268.webp" alt="image-20211020110927268" style="zoom: 50%;" />



现代微机I/O地址的分配：windows操作系统具有即插即用的资源配置机制，因此I/O端口地址的分配是动态的

#### I/O端口地址选用的原则

- 凡是被系统配置占用了的地址一律不能使用
- 未被占用的地址，用户可以使用，但对计算机厂家申明保留的地址，不要使用
- 用户可使用的地址为：300H-31FH



### I/O端口地址译码

#### 基本概念

当执行I/O指令时，CPU首先在总线上发出要访问的端口地址和必要的控制信号，然后通过一个转换电路将这些信号转换为相应的I/O端口选通信号。

这个转换过程就是I/O端口地址译码，完成这个过程的转换电路称为I/O端口地址译码电路。



#### 译码信号

- 译码的实质：对地址线和控制信号进行逻辑组合，产生相应的选通信号 $\overline{CS}$ ，低电平有效。
- 参与译码的主要信号：地址信号线 A9~A0，控制信号 $\overline{IOR}$、 $\overline{IOW}$ 、$AEN$
  - $AEN=1$ 代表使用DMA传送，$AEN=0$ 代表不采用DMA；



#### 原理

把地址线分为高低两部分，分别用于片间寻址和片内寻址。

片间寻址：高位地址线与CPU的控制信号相结合，经译码电路产生I/O接口芯片的片选信号 $\overline{CS}$ ，实现片间寻址。
通常都由接口芯片外部的译码电路来完成。

片内寻址：低位地址线不参加片间寻址译码，而是直接连接到I/O接口芯片，实现芯片内部的片内端口寻址。
通常由接口芯片内部的地址译码电路来完成。

用于片内寻址的低位地址线条数取决于接口内端口的数目N

一般低位地址线数 =  $log_2N$ 取 cell() 



#### I/O地址译码方法

- ##### 全译码方法

  - 地址线A0-A9全部参加译码，10根地址线的译码结果只是产生一个片选信号 $\overline{CS}$ 
  - 一般用在单端口的I/O设备上。



- ##### 部分译码方法

  - 只有高位地址线参加译码，产生片选信号 $\overline{CS}$ ；
  - 而低位地址线直接接芯片，作为片内寻址
  - 一般用于具有多个接口芯片的系统。



- ##### 地址开关译码方法

  - 在部分译码方法的基础上，加上地址开关（如PC主板上的超频开关）来改变端口地址



- ##### 译码电路的输入信号

- I/O地址译码电路不仅仅与地址信号有关，而且与控制信号有关。例如：

  - $AEN$ 信号：当 $AEN=1$ 时，为DMA方式
  -  $\overline{IOR}$、 $\overline{IOW}$ 信号：控制对端口的读/写等
  - 在32位机中，I/O读写信号是IORC和IOWC



- ##### 译码电路的输出信号

- 产生一个片选信号 $\overline{CS}$ ，$\overline{CS}=0$ 有效，产生唯一低电平信号，选中芯片内的寄存器端口；否则芯片未被选中



### I/O端口地址译码电路设计

- 
  遵循I/O端口地址的选用原则
  - 选用合适的地址段，避免发生冲突。
- 正确选用地址译码方法
  - 一般情况下，单端口地址译码采用全译码法，多端口译码采用部分译码法。
- 灵活设计I/O地址译码电路
  - 产生同样端口地址的译码电路不是唯一的，电路的组成可以采用不同的元器件，参加译码的地址信号和控制信号之间的逻辑组合也可以不同。



#### I/O端口地址的固定式译码

- 特点：
  - 接口中的端口地址固定，不能修改。一般接口卡中大多采用该形式。
- 单端口地址译码
  - 接口中只有一个端口地址。
  - 多采用与、或、非门等基本门电路来实现。
- 多端口地址译码
  - 系统中有多个接口芯片，或有多个端口（连续范围）
  - 多采用集成的译码器来实现，如74LS138，74LS154等



<img src="media/image-20211020113632862.webp" alt="image-20211020113632862" style="zoom: 33%;" />



### 可用的元器件

<img src="media/image-20211020113946782.webp" alt="image-20211020113946782" style="zoom:50%;" />

<img src="media/image-20211020114010692.webp" alt="image-20211020114010692" style="zoom:50%;" />



### 课堂小测题

例1：

A0A1没有参与，部分地址线参与译码，所以是部分译码

留有2个地址线，可以片内寻址4个，地址范围 80H-83H 

| A9   | A8   | A7    | A6    | A5    | A4    | A3   | A2   | A1   | A0   |
| ---- | ---- | ----- | ----- | ----- | ----- | ---- | ---- | ---- | ---- |
| 0    | 0    | **1** | **0** | **0** | **0** | 0    | 0    | x    | x    |



<img src="media/image-20211025080124651.webp" alt="image-20211025080124651" style="zoom:33%;" />



例2：

留有2个地址线，可以片内寻址4个

使能端确定 A8-A5=1100，ABC=010

范围 188H-18BH

| A9   | A8   | A7    | A6    | A5    | A4    | A3   | A2   | A1   | A0   |
| ---- | ---- | ----- | ----- | ----- | ----- | ---- | ---- | ---- | ---- |
| 0    | 1    | **1** | **0** | **0** | **0** | 1    | 0    | x    | x    |

<img src="media/image-20211025080613389.webp" alt="image-20211025080613389" style="zoom:33%;" />





## 9. 并行接口

并行接口的特点

- 并行接口指接口电路与I/O设备之间采用多根数据线进行数据传输，一次可以传输多个二进制位的接口
- 在多根数据线上以数据字节（字）为单位与I/O设备或被控对象进行信息传送，因此传输速率快
- 除数据线外，还可设置握手联络信号线，以便进行异步互锁（即查询方式）通信，提高数据传输可靠性
- 并行传送不要求固定的格式，传送数据的格式、速率和工作时序由连接的I/O设备操作的要求决定，使用自由
- 并行传输一般不作差错检验和传输速率控制
- 并行接口通常用于近距离传送



并行接口电路结构形式

1. 一般的IC芯片：主要由三态缓冲器和锁存器组成
2. 可编程并行接口芯片：例如 82C55A 可编程器件
3. CPLD/FPGA器件：采用大规模或超大规模可编程逻辑阵列芯片



### 可编程并行接口芯片82C55A

外部特性：

|引脚名|方向|功能|
|-------|----|------------|
|D~0~ ~ D~7~|双向|数据线|
|$\overline{CS}$|入|片选|
|A~1~，A~0~|入|选寄存器|
|$\overline{RD}$|入|读|
|$\overline{WR}$|入|写|
|RESET|入|复位信号|
|PA~0~ ~ PA~7~|双向|A端口的I/O线|
|PB~0~ ~ PB~7~|双向|B端口的I/O线|
|PC~0~ ~ PC~7~|双向|C端口的I/O线|



#### 面向系统总线的信号线

- 面向数据总线DB的有：
  - D~0~ ~ D~7~：双向数据线，用于CPU向8255A发送命令、数据和8255A向CPU回送状态、数据等。
- 面向地址总线AB的有：
  - $\overline{CS}$：片选信号，低电平有效。
  - A~1~，A~0~：片内端口地址信号，可以形成4个端口地址。
- 面向控制总线CB的有：
  - $\overline{RD}$：读信号，低电平有效。
  - $\overline{WR}$：写信号，低电平有效。
  - RESET：复位信号，高电平有效。它清除控制寄存器，并将8255A的A、B、C三个8位端口均置为0方式输入，直到在初始化程序段中用方式命令才能改变，使其进入用户所选的状态。



#### 面向I/O设备的信号线

PA0～PA7：端口A的输入/输出线

PB0～PB7：端口B的输入/输出线

PC0～PC7：端口C的输入/输出线

- A口和B口只作输入/输出的数据口用；
- C口除了作数据口外，在1方式和2方式时，它的大部分引脚被分配用作专用联络信号；PC口可以进行按位控制；当读取8255A状态时，PC口又作1、2方式的状态口用，其功能如下：
  - 作数据口
  - 作状态口
  - 作专用（固定）联络（握手）信号
  - 作按位控制用



### 8255 的内部结构

- 数据总线缓冲器：是一个三态双向8位缓冲器，它是82C55A与CPU系统数据总线的接口。
- 读/写控制逻辑：读/写控制逻辑由读信号 $\overline{RD}$ 、写信号 $\overline{WR}$ 、选片信号 $\overline{CS}$ 以及端口选择信号A1，A0等组成。
- 输入/输出端口A、B和C：82C55A包括3个8位输入输出端口，提供给用户连接I/O设备使用。每个端口都有一个数据输入寄存器和一个数据输出寄存器。输入时端口有三态缓冲器的功能，输出时端口有数据锁存器的功能。
- A组和B组控制电路：控制A、B和C端口的工作方式。
- 三个端口均是I/O口，但结构和功能稍有不同：
  - A口：是一个独立的8位I/O口，具有对输出数据的锁存和输入数据缓存功能。
  - B口：是一个独立的8位I/O口，具有对输出数据的锁存和输入数据缓存功能。
  - C口：可以看作是一个独立的8位I/O口，也可以看作是两个独立的4位I/O口。具有对输出数据锁存和输入数据缓存功能。高4位与A端口统一由A组控制电路控制，低4位与B端口统一由B组控制电路控制



<img src="media/image-20211025081901962.webp" alt="image-20211025081901962" style="zoom: 50%;" />



### 8255A 基本操作与端口地址

PC机中的端口地址：60H～63H

用户扩展的82C55A端口地址：300H～303H
|/CS|A1|A0|/RD|/WR|读操作|内容|PC系统|
|-------|----------|----------|-------|-------|---------------------------------------|----------|--------------|
|0|0|0|0|1|PA口→数据总线（→CPU）|数据|60H|
|0|0|1|0|1|PB口→数据总线（→CPU）|数据|61H|
|0|1|0|0|1|PC口→数据总线（→CPU）|数据|62H|
||||||**写操作**|||
|0|0|0|1|0|PA口←数据总线（←CPU）|数据|60H|
|0|0|1|1|0|PB口←数据总线（←CPU）|数据|61H|
|0|1|0|1|0|PC口←数据总线（←CPU）|数据|62H|
|0|1|1|1|0|控制寄存器←数据总线|**控制字**|63H|
||||||**无操作情况**|||
|**1**|×|×|×|×|总线悬浮（三态）|||
|0|×|×|**1**|**1**|总线悬浮|||
|0|1|1|0|1|控制口不能读||63H|



### 82C55A的工作方式

#### （只讲过）方式0：基本输入/输出方式

- 单向I/O，一次初始化只能指定端口（PA、PB和PC）作输入或输出，不能指定端口同时即作输入又作输出
- 不要求固定的联络（应答）信号，无固定工作时序和工作状态字
- 适用于无条件或查询方式传送，**不能用中断方式交换数据**
- 功能：
  - A端口：数据端口，8位并行
  - B端口：数据端口，8位并行
  - C端口：数据端口，4位并行(分高4位和低4位)，或作位控，按位输出高/低电平



#### 方式1：选通输入/输出方式

- 一次初始化只能指定端口（PA、PB和PC）作输入或输出，即单向输入/输出
- 要求固定的联络（应答）信号，有固定工作时序和工作状态字
- 适用于查询或中断方式传送数据，不适用于无条件数据传送
- 功能：
  - A端口：数据端口，8位并行
  - B端口：数据端口，8位并行
  - C端口：
    - a.作A口和B口的固定联络信号线
    - b.剩余未分配的引脚做数据线
    - c.作状态口，读A口和B口的状态字
    - d.作按位，按位输出逻辑1或逻辑0



#### 方式2：双向选通输入/输出方式

- 一次初始化可将端口A置成既输入又输出，即双向输入/输出
- 要求固定的联络（应答）信号，有固定工作时序和工作状态字
- 适用于查询或中断方式传送数据，特别适用于与I/O设备进行双向数据传输
- 功能：
  - A端口：双向数据端口，8位并行
  - B端口：单向数据端口，8位并行
  - C端口：
    - a. 作A口的固定联络信号线
    - b. 剩余未分配的引脚做数据线
    - c. 作状态口，读A口和B口的状态字
    - d. 作按位，按位输出逻辑1或逻辑0



## ※ 82C55A的编程命令：方式命令

- 方式命令又称初始化命令，应出现在82C55A开始工作之前的初始化程序段中
- 作用：指定82C55A的工作方式及其方式下的三个并行端口的输入/输出功能；
- 82C55A的工作方式与端口有关：PA口有三种方式（0方式、1方式、2方式），PB口和PC口只有两种方式（0方式、1方式)
- 方式命令字的最高位（特征位）必须是1



#### 工作方式命令

命令字最高位为1：

<img src="media/image-20211025084200262.webp" alt="image-20211025084200262" style="zoom: 50%;" />



例：要把A口指定为1方式，输入，C口上半部为输出；B口指定为0方式，输出，C口下半部定为输入，则工作方式命令代码是： 10110001B=B1H

初始化的程序段为：

```assembly
MOV  DX, 303H    ; 8255A 命令口地址(假设)
MOV  AL, 0B1H    ; 初始化命令
OUT  DX, AL      ; 送到命令口
```

难点一般在译码电路分析和方式命令字



#### C端口按位置位/复位命令

指定PC口的某一位（某一个引脚）输出高电平或低电平。

命令字最高位是0：

<img src="media/image-20211025085014918.webp" alt="image-20211025085014918" style="zoom:50%;" />



例：若要把C口的PC2引脚置成高电平输出，则命令字应该为：00000101B=05H

其程序段为：

```assembly
MOV  DX，303H    ; 8255A命令口地址(假设)
MOV  AL，05H     ; 使PC2=1的命令字
OUT  DX，AL      ; 送到命令口
```

如果要使引脚PC2输出低电位，则程序段为：

```assembly
MOV  DX，303H    ; 8255A命令口地址(假设)
MOV  AL，04H     ; 使PC2=0的命令字
OUT  DX，AL      ; 送到命令口
```



例：利用8255A的PC7产生负脉冲，作打印机接口电路的数据选通信号：

<img src="media/image-20211025090809065.webp" alt="image-20211025090809065" style="zoom:33%;" />

其程序段为：

```assembly
MOV  DX，303H           ; 8255A命令口
MOV  AL，00001110B      ; 置PC7=0
OUT  DX，AL
NOP  ; 延长机器周期，维持低电平
NOP    
MOV  AL，00001111B      ; 置PC7=1
OUT  DX，AL
```



#### 关于两个命令的使用

- 方式命令是对8255A的3个端口的工作方式及功能进行指定，即初始化，要在使用8255A之前进行；
- 按位置位/复位命令只是对PC口的输出进行控制，使用它不会破坏已经建立的3种工作方式，而是对它们实现动态控制的一种支持，它可放在初始化程序以后的任何地方；
- 两个命令的最高位（D7）都分配作了特征位，设置特征位是为了识别两个不同的命令（写到同一地址）；
- 按位置位/复位的命令代码只能写入命令口，而不能写到数据口（因为复位命令是命令）；



#### A口和B口另一个使用方法

- A口、B口也可以按位输出高低电平，但它与C口的按位置位/复位命令有本质的差别，并且实现的方法也不同：A口、B口按位输出是以 **送数据** 到A口、B口来实现的。
- 具体作法是：若要使某一位置高电平，则先对端口进行读操作，然后“或”上一个字节，此字节中的对应位为1，其它各位为0，最后再写回同一端口。
- 说明：对输出口先读再写的前提是8255的输出 **有锁存能力**。
  - 例：若定义A口为输出，而对其执行IN指令，那么读到的内容就是A口在上次输出时锁存的数据。 



例：若要使PA7位输出高/低电平，而其它位不变，则用下列程序段：

```assembly
; 使PA7输出高电平
MOV  DX，300H   ; PA数据口地址
IN  AL，DX      ; 读入A口原输出内容
OR  AL，80H     ; 使PA7=1
OUT  DX，AL     ; 输出PA7
```

```assembly
MOV DX，300H    ; PA数据口地址
IN  AL，DX      ; 读入A口原输出内容
AND AL，7FH     ; 使PA7=0
OUT DX，AL      ; 输出PA7
```

<img src="media/image-20211025091943429.webp" alt="image-20211025091943429" style="zoom: 33%;" />



例：若要使PB0和PB1位同时输出高/低电平，则用下列程序段：

```assembly
MOV  DX，301H   ; PB数据口地址
IN  AL，DX      ; 读入B口原输出内容
OR  AL，03H     ; 使PB1PB0 =11
OUT  DX，AL     ; 输出PB1 PB0
AND AL, 0FCH    ; 使PB1PB0 =00
OUT DX, AL
```



### 0方式应用

特点：

- 0方式是一种基本输入/输出工作方式。通常不用联络信号，或不使用固定的联络信号。基本I/O方式是指查询方式传送，也包括无条件传送。
- 在0方式下，彼此独立的两个8位和两个4位并行口，都能被指定作为输入或者输出口用，共有16种不同的使用状态。
- 在0方式下不设置专用联络信号线，需要联络时，可由用户任意指定C口中的哪一根线完成某种联络功能
  - 这与1方式、2方式下设置固定的专用联络信号线不同。
- 0方式是单向I/O，一次初始化只能指定端口（PA、PB和PC）作输入或输出，不能指定端口同时即作输入又作输出。



#### 例：并行打印机接口设计

要求为某应用系统配置一个并行打印机接口，CPU采用查询方式把存放在BUF缓冲区的256个字（ASCII码）送去打印。

分析：由于打印接口直接面向的对象是打印机接口标准，而不是打印机本身，因此打印机接口要按照接口标准的要求进行设计。

<img src="media/image-20211025092439840.webp" alt="image-20211025092439840" style="zoom: 50%;" />

采用查询方式时，打印机与CPU之间传送数据的过程是：

- 首先查询BUSY：
  - 若BUSY=1，打印机忙，则等待；
  - 若BUSY=0，打印机不忙，则送数据。
- 通过并行接口把数据送给标准插座的数据线DATA1~DATA8上，此时数据并未送入打印机。
- 再送出一个数据选通信号STROBE，把数据打入到打印机的内部缓冲器中。
- 打印机在收到数据后，发出“忙”（BUSY=1）信号，表明打印机正在处理输入的数据。



设计：接口包括硬件接口电路和软件驱动程序。

打印机硬件接口电路

- 按照Centronics标准，打印机接口信号应包括8根数据线（DATA1～8），1根控制线（ $\overline{STB}$ ），1根状态线（BUSY）和1根地线。
- 选用8255A的PA口作数据口输出8位打印数据（工作在0方式），PC7（C口上半区）作控制线（ $\overline{STB}$ ），PC2（C口下半区）作状态线（BUSY）



接口驱动程序：

```assembly
; …
BUF  DB  ? ;256个ASCII字符代码
; …

CODE SEGMENT
ASSUME  CS:CODE, DS:CODE
    ORG 100H
START: 
    MOV  AX, CODE
    MOV  DS, AX
    MOV  DX, 303H      	; 8255A命令口
    MOV  AL, 10000001B 	; 工作方式字
    OUT  DX, AL       	; A口0方式, 输出,  
                   	    ; PC4～PC7 输出, PC0～PC3输入
    MOV  AL, 00001111B 	; PC7位置高, 使STB=1, 低电平有效
    OUT  DX, AL
    MOV  SI, OFFSET BUF 	; 打印字符的内存首址
    MOV  CX, OFFH       	; 打印字符个数
    L:
       MOV  DX, 302H        ; PC口地址
       IN  AL, DX          	; 查BUSY=0？（PC2=0）
       AND  AL, 00000100B   ; 用 PC 口地址数据与一下0000 0100B 来确定 BUSY 口情况
       JNZ  L       		; 忙, 则等待; 不忙, 则向A口送数
       MOV  DX, 300H       	; PA口地址
       MOV  AL, [SI]       	; 从内存取数
       OUT  DX, AL         	; 送数据到A口
       MOV  DX, 303H       	; 8255A命令口
       MOV  AL, 00001110B  	; 置STB信号为低（PC7=0）
       OUT  DX, AL
       MOV  AL, 00001111B	; 置STB为高（PC7=1）
       OUT  DX, AL
       INC  SI           	; 内存地址加1
       DEC  CX              ; 字符数减1
       JNZ  L               ; 未完, 继续
    MOV  AX, 4C00H     ; 已完, 退出
    INT  21H  
CODE ENDS
     END  START
```



#### 例：声-光报警器接口设计

要求：

- 设计一个声-光报警器，要求按下SW开关开始报警，喇叭SPK发声，LED灯同时闪光。当拨通8位DIP的0位开关，结束报警，喇叭停止发声，LED熄灭。

分析：

- 该报警器包括4种外设：喇叭、8个LED、8位DIP开关、按钮SW；
- 它们通过接口电路与CPU连接，接受CPU的控制，实现相应功能；



设计：

- 4种I/O设备，其中按钮SW和8位DIP开关为输入设备，喇叭和LED灯为输出设备。
- 采用82C55A进行接口设计：

- 硬件设计：
  - 采用82C55A设计接口。使用3个端口：
  - A端口：输出，连接8个LED灯LED0-LED7
  - B端口：输入，连接8位DIP开关DIP0-DIP7
  - C端口PC6：输出，连接喇叭SPK控制74LS373的开关
  - C端口PC2：输入，连接开关SW

<img src="media/image-20211027104557417.webp" alt="image-20211027104557417" style="zoom:50%;" />

- 软件设计

```assembly
; 主要代码
MOV   DX, 303H  ; 初始化82C55A  命令口
MOV   AL, 83H   ; 0方式, A端口和PC4-7输出; 
                ; B端口和PC0-3输入
OUT   DX, AL
MOV   DX, 300H  ; PA数据口地址
MOV   AL, 00H   ; 熄灭LED灯, PA0-7全部置0
OUT   DX, AL
MOV   DX, 303H  ; 关闭喇叭, PC6=0
MOV   AL, 00001100B
OUT   DX, AL

WAIT1:  
    MOV  DX, 302H       ; 查SW按下？（PC2=0?) 	
	IN	 AL, DX
	AND  AL, 00000100H
    JNZ  WAIT1        ; SW未按下, 等待
    
BEGIN:   
    CALL  LED_FLASH       ; 调用LED发光子程序
	MOV	 BX, 200	     
	MOV	 T, 0FFFH	      ; 延时变量
    SPEAK_H: CALL OUTSPK  ; 调用喇叭发声（高频）子程序
	    DEC  BX
        JNZ	 SPEAK_H
	MOV	 DX, 300H	      ; LED全灭, PA0-7全部置0
	MOV	 AL, 00H
    OUT  DX, AL
	MOV  BX, 200
    MOV  T, 09FFFH
    
SPEAK_L: 
    CALL OUTSPK	    ; 调用喇叭发声（低频）子程序
    DEC	 BX
    JNZ	 SPEAK_L		
    CALL DELAY2
    MOV	 DX, 301H	; 查DIP0按下？（PB0=0?)
    IN	 AL, DX
    AND	 AL, 01H       	  
    JNZ	 BEGIN      ; DIP0未按下, 继续
    
    MOV	DX, 300H    ; DIP0已按下
    MOV	AL, 00H     ; LED全灭, PA0-7全部置0
    OUT  DX, AL
    MOV  DX, 303H   ; 关闭SPK, PC6置0
    MOV  AL, 00001100B
    OUT  DX, AL		
    MOV  AH,4CH
    INT  21H 

; 延时子程序2
DELAY2 PROC  
    PUSH  BX
    PUSH  CX
    MOV   CX，04FFFH
    DL2:     
        MOV  BX, 0FFFFH    
        DL3:	 
            DEC   BX
            JNZ    DL3    
	    DEC   CX
        JNZ    DL2
    POP   CX
    POP   BX
    RET
 DELAY2 ENDP 
 
; 喇叭发声子程序，PC6输出方波
OUTSPK  PROC
   MOV	 DX，303H
   MOV   AL, 00001101B  ; PC6置1，发出方波
   OUT   DX, AL
   CALL  DELAY1         ; 维持高电平
   MOV   DX, 303H
   MOV   AL, 00001100B  ; PC6置0
   OUT   DX, AL
   CALL  DELAY1         ; 维持低电平
   RET
 OUTSPK  ENDP 
 
; 延时子程序1 
DELAY1 PROC  
    PUSH BX
    MOV  BX，T	
    DL1: 
        DEC   BX
        JNZ   DL1    
    POP   BX
    RET
DELAY1  ENDP 

; LED发光子程序
LED_FLASH PROC
    MOV DX, 300H
    MOV AL, 0FFH   ; PA0-7全部置1
    OUT  DX, AL
    RET
 LED_FLASH ENDP 
```



并行接口82C55A自学内容：

1、82C55A的1方式及其应用

-  1方式下联络信号线的设置
  -  掌握输入和输出联络信号线的设置（每根信号线的含义）
-  1方式的工作时序
  -  掌握输入和输出的工作时序（接口与设备之间的握手方法）
-  1方式的状态字
  -  状态字的内容和含义（状态字与信号线、信号时序的关系）
-  1方式并行接口设计
  -  采用选通方式的并行接口设计（对打印机接口的控制方法）

2、82C55A的2方式及其应用

-  2方式下联络信号的设置及时序
-  2方式的应用实例

3、理解82C55A的3种工作方式的主要区别

4、掌握查询方式和中断方式的应用方法



### 8255 上机实验：LED流水

这脑瘫实验箱必须把 ASSUME 语句写开头……

数码管位码是1,2,4,8这样的（就是 0000 0001, 0000 0010 ... 

#### 数码管字型代表码

<img src="media/image-20211029172530491.webp" alt="image-20211029172530491" style="zoom: 33%;" />



## 10. 定时/计数技术

定时与计数本质上都是计数，但它们所计的数来源是不同的

### 微机系统中的定时类型

- 内部定时
  - 内部定时产生运算器、控制器等CPU内部的控制时序，如取指周期、读/写周期、中断周期等，主要用于CPU内部指令执行过程的定时，计时单位一般是ns级。
- 外部定时
  - 外部定时是外设在实现某种功能时所需要的一种时序关系。例如，打印机接口标准Centronics，就规定了打印机与CPU之间传输信息应遵守的工作时序。    



外部定时和内部定时是相互独立的两个定时系统。内部定时固定不变，外部定时随外设而变。以内部定时为依据设计外部定时结构，即“时序配合”。



### 外部定时方法及硬件定时器

#### 定时方法

（1）软件定时：是利用CPU内部定时机构，运用软件编程去循环执行一段程序而产生的等待延时。

  例：       

```assembly
MOV BX, 0FFH
DELAY: 
   DEC BX      ; BX称为“延时常数”
   JNZ DELAY
```

（2）硬件定时：采用可编程的定时/计数器或单稳延时电路产生定时或延时。

优点：

- 不占用CPU的时间，定时时间长，使用灵活；
- 定时准确，定时时间不受主机频率影响，定时程序具有通用性，故得到广泛应用。
- 缺点：设置定时电路，增加额外硬件开销。



#### 外部硬件定时器

- 不可编程定时器
  - 不可编程定时器的定时间隔和定时范围固定，采用中小规模集成电路器件构成的定时电路。常见的定时器件有单稳触发器和555、556定时器等，利用其外接电阻、电容的组合，可实现一定范围的定时。	
- 可编程定时器
  - 可编程定时器的定时间隔和定时范围可由程序进行设定和改变，使用方便灵活。可编程定时电路一般都是采用可编程定时/计数器外围支持芯片，如Intel 82C54A（8254是8253的改进型）。



#### 计数器/定时器的工作原理

<img src="media/image-20211104162813039.webp" alt="image-20211104162813039" style="zoom:50%;" />



### 可编程定时/计数器 82C54A

8254  是 8253 的升级版（

#### 82C54的外部连接特性与内部结构

<img src="media/image-20211104163205273.webp" alt="image-20211104163205273" style="zoom:50%;" />

#### 外部特性

- 面向CPU的信号线

  - 数据线：D0-D7
  - 地址线：片选 $\overline{CS}$ ，片内地址A0、A1
  - 控制线： $\overline{WR}$ 、 $\overline{RD}$ 

- 面向I/O设备的信号线

  - 时钟信号：CLK0-CLK2
  - 门控信号：GATE0-GATE2
  - 输出信号：OUT0-OUT2

  

##### 面向CPU的信号线

- 数据总线 D0-D7：三态输出输入线。用于将8254与系统数据总线相连
- 片选线 $\overline{CS}$ ：输入信号，低电平有效
  - 当为低电平时，CPU选中82C54，并可以对82C54进行读/写操作；
  - 当为高电平时，CPU没有选中82C54；
  -  $\overline{CS}$ 由CPU输出的地址码经译码产生。
- 读信号 $\overline{RD}$ ：输入信号，低电平有效
- 写信号 $\overline{WR}$ ：输入信号，低电平有效
- 地址线 A1, A0  : 这两根线接到系统地址总线的 A1, A0 上，用于片内寻址
  -  8254有4个I/O端口地址，按从低到高地址的字节顺序为：通道0、1、2、方式字
  - 各占一个字节宽度的I/O地址
  - 如果要向方式字所在I/O地址传送两个字节，那么需要连续两次向该IO地址传输内容



##### 面向I/O设备的信号线

- 计数器时钟信号 CLK：输入的计时脉冲信号
- 计数器门控选通信号 GATE：输入的计时启动信号
- 计数器输出信号 OUT：定时结束时的输出信号 



#### 内部组成

完成CPU和8254之间命令、数据、地址和数据的交换

<img src="media/image-20211104164246353.webp" alt="image-20211104164246353" style="zoom:50%;" />

- 数据总线缓冲器：它是一个三态、双向8位寄存器，用于将8254与系统数据总线D0-D7 相连
  - 解决内设外设速率不一致的问题
- 读/写逻辑：用于读/写控制和片选。
- 控制命令寄存器：它接收CPU送来的控制字。
- 计数器：8254有3个独立的计数器，其内部结构完全相同，每个计数器由16位的计数初值寄存器、减法计数器和当前计数值锁存器组成。



##### 计数器通道的组成

<img src="media/image-20211104164922734.webp" alt="image-20211104164922734" style="zoom: 50%;" />

- 计数初值寄存器（16位）
  - 用于存放计数初值（定时常数、分频系数），其长度为16位，故最大计数值为65536（64KB）
  - 在初始化时同减1计数器的初值一起装入
  - 计数初值寄存器的计数初值在计数过程中保持不变
    - **8254 的数据线是8位**，读和写都需要装2次，操作时**先送低位后送高位**
- 减1计数器（16位）
  - 用于进行减1计数操作，每来一个时钟脉冲，它就作减1运算，直至将计数初值减为零
- 当前计数值锁存器（16位）
  - 用于锁存减1计数器的内容，以供读出和查询



#### 8254读写操作及端口地址表
|/CS|/RD|/WR|A1|A0|操作|
|-------|-------|-------|----------|----------|------------------------------------------------------------|
|0|1|0|0|0|加载T/C0，即向计数器0写入计数初值|
|0|1|0|0|1|加载T/C1，即向计数器1写入计数初值|
|0|1|0|1|0|加载T/C2，即向计数器2写入计数初值|
|0|1|0|1|1|向**控制器寄存器**写方式控制字|
|0|0|1|0|0|读T/C0，即从计数器0读出当前计数值|
|0|0|1|0|1|读T/C1，即从计数器1读出当前计数值|
|0|0|1|1|0|读T/C2，即从计数器2读出当前计数值|
|0|0|1|1|1|无操作三态|
|1|×|×|×|×|禁止三态|
|0|1|1|×|×|无操作三态|



## ※ 82C54A 的方式命令字

82C54有3个命令字和1个状态字，3个命令字分别是方式命令、锁存命令和读回命令。

其中方式命令是必须的，其它两个命令根据需要使用。

注意：这3个命令字使用同一个端口，按方式命令在先，其它命令在后的顺序写入端口



#### 方式命令

初始化82C54A，包括选定计数通道、设定工作方式、确定字节读写顺序以及计数值码制

方式命令的格式：

<img src="media/image-20211104170129252.webp" alt="image-20211104170129252" style="zoom:50%;" />

| 位数  | 功能       | 功能选择                                                     |
| ----- | ---------- | ------------------------------------------------------------ |
| D7-D6 | 计数器选择 | D7D6 = 00，选择0号计数器；<br/>D7D6 = 01，选择1号计数器；<br/>D7D6 = 10，选择2号计数器；<br/>D7D6 = 11，无效； |
| D5-D4 | 读写字节数 | D5D4 = 00，锁存命令，计数器值复制到锁存器，D3～0无效；<br/>D5D4 = 01，仅读/写一个低字节，高字节为0；<br/>D5D4 = 10，仅读/写一个高字节，低字节为0；<br/>D5D4 = 11，读/写2个字节，先低字节，后高字节<br/>                       影响对锁存器的读和对初值寄存器写操作； |
| D3-D1 | 工作方式   | D3D2D1 = 000，选择0方式；<br/>D3D2D1 = 001，选择1方式；<br/>D3D2D1 = X10，选择2方式；<br/>D3D2D1 = X11，选择3方式；<br/>D3D2D1 = 100，选择4方式；<br/>D3D2D1 = 101，选择5方式； |
| D0    | 码制       | D0 = 0，选择二进制计数；<br/>D0 = 1，选择十进制BCD计数；     |



#### 计数码制

- 若按二进制计数
  - 计数范围：16位二进制数
  - 最大计数值：216 = 65536，对应计数初值0000H
  - 注：需要将计算得到的十进制计数初值n转换成二进制，然后写入指定端口
- 若按BCD码计数
  - 计数范围：4位十进制数
  - 最大计数值：104 = 10000，对应计数初值0000
  - 注：BCD常用于用户输入，计数值应由16进制转换为BCD码才行



例：使用计数器T1工作在4方式，且时间常数为3F8H；

设307H是整个8254的命令寄存器的地址，305H是8254中定时器1的数据口地址，则初始化程序段为：

```assembly
MOV  DX, 307H        ; 命令口地址
MOV  AL, 01111000B   ; 方式字
OUT  DX, AL         ; 写入控制命令字寄存器

MOV  DX, 305H        ; 倒退T1数据口是305H
MOV  AL, 0F8H        ; 低8位计数值             
OUT  DX, AL         ; 送低字节到计数器1初值寄存器

MOV  AL, 03H         ; 高8位计数值
OUT  DX, AL         ; 送高字节到计数器1初值寄存器
```



#### 锁存命令

将减1寄存器的内容锁存到输出寄存器中以供CPU读取。执行锁存命令指示把计数器的当前值锁存到暂存寄存器。

锁存命令的格式：

<img src="media/image-20211104172338267.webp" alt="image-20211104172338267" style="zoom:50%;" />

<img src="media/image-20211104172357772.webp" alt="image-20211104172357772" style="zoom:45%;" />



例：要求在计数器通道1的计数过程中读取当前的计数值，并把读取的计数值装入到AX寄存器中。设4个端口的地址为：304H（通道0），305H（通道1），306H（通道2），307H（命令寄存器）

```assembly
MOV  DX, 307H
MOV  AL, 0100XXXXB    ; 锁存计数器1, X处可以取任何数
OUT  DX, AL
MOV  DX, 305H
IN   AL, DX	          ; 读低字节
MOV  BL, AL
IN   AL, DX	          ; 读高字节
MOV  AH, AL
MOV  AL, BL
```



#### 读回命令（8253不具有这种功能）

读回命令与前面的锁存命令不同，它即能锁存计数值又能锁存状态信息，而且一条读回命令可以锁存3个计数通道的当前计数值与状态。

读回命令的格式：

<img src="media/image-20211104173020126.webp" alt="image-20211104173020126" style="zoom:50%;" />

D3-D1用于选择3个计数器，1：选中，0：未选中；

D5-D4用于选择读当前状态还是当前计数值，0：要读取，1：不读取

注意：读回命令只是一个锁存的功能，要读回计数值和状态还要发一条读命令。



例：

读取计数器2的当前计数值和状态，读回命令=11001000B

读取全部计数器的当前计数值和状态，读回命令=11001110B



#### 状态字（8253没有此状态字）

<img src="media/image-20211104173542195.webp" alt="image-20211104173542195" style="zoom:50%;" />

状态字中的低6位D0-D5与方式字中的低6位是相同的；

- D6 表示计数器的输出状态：
  - 1：输出引脚为逻辑1
  - 0：输出引脚为逻辑0
- D7 表示是否有空计数值：
  - 1：空计数值
  - 0：计数值有效



### 8254 编程流程

- 先写控制字，再写计数初值；
  - 计数初值必须遵循控制字设定的格式；
  - 如果初值是两个字节，那么在载入初值期间则不允许发送控制字命令，否则会载入错误的计数器。

- 当减1计数器为0时，OUT端上输出一个脉冲。
  - GATE=1时允许开始计数；
  - GATE=0时计数值保持不变。
- 只有当CPU向8254控制字寄存器中写入控制字后，8254才开始定时/计数过程；

- 写入控制字后，所有的控制逻辑电路将立即复位，输出端OUT立即进入初始状态
  - 不同的工作方式下OUT的初始状态是不同的
- GATE=1时，在写入计数初值后，需要经过一个时钟脉冲之后，计数器才开始在脉冲下降沿进行减1计数。



### 82C54的工作方式

82C54有6种工作方式，不同的工作方式主要体现在输出波形、启动方式、初值装入，以及GATE信号的控制作用的不同，由方式控制字确定

每种工作方式的过程类似：

1. 设定工作方式
2. 设定计数初值
3. （硬件启动）
4. 计数初值进入减1计数器
5. 每输入一个时钟计数器减1的计数过程
6. 计数过程结束



<img src="media/image-20211104174445709.webp" alt="image-20211104174445709" style="zoom:50%;" />



#### 定时器方式0：计数结束中断

0方式特点：

- 0方式的典型应用是做事件计数器，计数器的大小就是计数初值（初值+1）
- 改变计数初值就可以改变计数器的大小
- 0方式当写入计数初值后，启动计数器开始计数，OUT信号变为低电平，并维持低电平
- 至减法计数器的内容减到0时，停止工作，OUT信号变为高电平，并维持高电平到再次写入新的计数值
  - 可见，0方式输出单次波
- 0方式的计数过程由写信号软启动，写入计数初值后开始计数，不需外加启动信号；计数结束，自动停止，不需外加停止信号



注意：

- 当向计数器写完计数值后，开始计数，计数一旦开始，输出端OUT就变成低电平，并在计数过程中一直保持低电平，当计数器减到零时，OUT立即变成高电平。

- 门控信号GATE为高电平时，计数器工作；当GATE为低电平时，计数器停止了工作，其计数值保持不变。如果门控信号GATE再次变高时，计数器从中止处继续计数。

- 在计数器工作期间，如果重新写入新的计数值，计数器将按新写入的计数初值重新工作。
- 小细节：
  - CLK上升沿启动，（正脉冲）n+1次（负脉冲则是n+2）变成高电平
  - 程序写完计数初值只是写入初值寄存器，之后到来的第一个CLK输入脉冲（先由低电平变为高电平，再由高电平变为低电平）才将初值送入减1计数器。
  - 从第二个CLK的下降沿才开始减1计数。



- ##### 方式0过程特点

|控制特征|OUT和计数值的变化|
|--------------------------------|------------------------------------------------------------|
|1控制字写入|当控制字写入后，OUT变为低电平，并在计数值为0前一直保持低电平|
|2计数值写入|OUT=0|
|3启动方式|**写入非0计数值即可启动；**<br>在写入计数值N后的下一个时钟脉冲时开始减1计数（所以是N+1个CLK宽度）。|
|4计数期间|OUT=0|
|5计数为0时|OUT=1，一直保持到有新计数值或控制字为止|
|6计数期间写入新的计数值|如果计数值为1个字节，在其写入后的下一个时钟脉冲时开始减1计数；如果为2个字节，则写入第一个字节时中止计数，写入第2个字节后的下一个时钟脉冲时，按新的计数值开始减1计数；|
|7GATE的作用|GATE=0时，计数器暂停减1；GATE=1时，计数器继续减1；|
|8计数值有效期|一次有效|



#### 定时器方式1：可编程单稳脉冲

1方式特点：

- 1方式的典型应用是作可编程单稳态触发器，单稳延迟时间=计数初值×时钟脉宽，延时期间输出的是低电平，低电平的宽度可以由程序控制，即改变计数初值就可以改变延时时间。  
- 1方式在写入计数初值后，再由GATE门信号硬启动计数，OUT变为低电平，每来一个CLK，计数器减1直到计数值减到0时，停止工作，OUT输出高电平，并维持高电平到GATE门信号再次启动。
- 1方式由GATE门信号每触发1次仅输出一个波形，故1方式也是输出单次波。



- 情况一：
  - 写入计数初值后，计数器并不立即开始工作；
  - 门控信号GATE有效，才开始工作，使输出OUT变成低电平；
  - 直到计数器值减到零后，输出才变高电平。
- 情况二：
  - 在计数器工作期间，当**GATE又出现一个上升沿**时，计数器重新装入原计数初值并重新开始计数
  - 如果工作期间对计数器写入新的计数初值，则要等到门控信号再次出现上升沿后，才按新写入的计数初值开始工作



- ##### 方式1过程特点

|控制特征|OUT和计数值的变化|
|--------------------------------|------------------------------------------------------------|
|1控制字写入|当控制字写入后，OUT=1|
|2计数值写入|OUT=1|
|3启动方式|**GATE上升沿可启动；**<br>在GATE上升沿后的下一个时钟脉冲时OUT=0|
|4计数期间|OUT=0|
|5计数为0时|OUT=1，一直保持到有GATE上升沿为止|
|6计数期间写入新的计数值|不影响原计数过程，只有当下一个GATE上升沿时才使用新计数值|
|7GATE的作用|GATE=0或1期间，不影响计数器减1动作；但若出现GATE上升沿，则按新计数值重启计数器，无论原计数过程如何。|
|8计数值有效期|多次有效；未写入新计数值时，每次GATE上升沿都自动重载原计数值|


- 负脉冲宽度为计数初值N和GATE出现的时机共同决定。
- 不必重写同样的计数初值，只要GATE重新触发即可按上一次的计数初值重计数。
- 与方式0相比，方式1下的GATE不会暂停计数减1过程，只会重新启动计数过程【即硬件启动计数方式】，新启动的计数过程将按最新输入的计数初始值进行计数！
- 方式0和方式1的作用都是产生单个负脉冲，负脉冲宽度可编程，但一个是软件启动计数且脉冲宽度为N+1，另一个是硬件启动计数且脉冲宽度为N。 两种方式下计数值都有为0的时候。



#### 定时器方式2：频率发生器（分频器）

具体过程：当写入计数初值后，启动计数器开始减1计数，直到减到1时，OUT输出一个宽度为时钟CLK周期的低电平，接着又变回高电平，且计数初值自动重装，开始下一轮计数，如此往复，不停地输出连续的负脉冲。



- ##### 方式2过程特点

|控制特征|OUT和计数值的变化|
|:-------------------------------|------------------------------------------------------------|
|1控制字写入|当控制字写入后，OUT=1|
|2计数值写入|OUT=1|
|3启动方式|GATE上升沿可启动，或者GATE=1时写入计数值也可以启动。|
|4计数期间|OUT=1，但计数值为1时，OUT输出一个时钟周期的负脉冲|
|5计数为0时|OUT=1，开始下一个周期的计数|
|6计数期间写入新的计数值|影响随后的脉冲周期|
|7GATE的作用|GATE=0时，OUT=1，停止计数；GATE上升沿时，按新计数值重启计数器，无论原计数过程如何；GATE=1时不影响计数过程；|
|8计数值有效期|计数值重复有效；当值减到0时，计数初值自动重载N(N可以在值变为0之前被更新)，此时0就被看做是N，实现循环计数。也可以认为计数值没有0！|



2方式特点：

- 不用重新设置计数值，能够连续工作，输出固定频率的负脉冲；
- 计数过程可以由GATE信号控制，GATE变低时立即暂停现行计数，变高后从计数初值开始重新计数；
- 如果在计数过程中，CPU重新写入计数初值，则对现在正在进行的计数过程无影响，而是从下一个操作周期开始按新的计数值改变输出脉冲的频率。



#### 定时器方式3：方波发生器

- 该方式产生占空比为1:1（N为偶数）或接近1:1（N为奇数）的连续方波
- 方波的周期=计数初值×时钟脉冲的周期。改变计数初值就可以改变输出方波的频率
- 具体过程：当写入计数初值后，计数器自动开始计数，保持OUT为高，当计数到N/2或者（N+1）/2时，输出变低，直至计数到0。计数结束后，计数初值自动重装，开始下一轮计数，如此往复，不停的工作，因此，3方式连续输出方波



- ##### 方式3过程特点：


|控制特征|OUT和计数值的变化|
|--------------------------------|------------------------------------------------------------|
|1控制字写入|当控制字写入后，OUT=1|
|2计数值写入|OUT=1|
|3启动方式|GATE上升沿可启动，或者GATE=1时写入计数值也可以启动。在启动后的下一个时钟脉冲时OUT=1|
|4计数期间|若计数值N为偶数，则在前N/2计数期间，OUT=1；后N/2计数期间OUT=0；<br>如为奇数，则前(N+1)/2期间，OUT=1；后(N-1)/2期间，OUT=0|
|5计数为0时|OUT=1，完成一个周期；然后计数值自动装入减1计数器，开始下一周期|
|6计数期间写入新的计数值|不影响当前输出周期；当计数值为0或者GATE有上升沿后，在当前输出周期结束以后时钟下降沿以新计数周期输出方波|
|7GATE的作用|GATE=0时，OUT=1，停止计数；GATE上升沿时，下一周期按新计数值重启计数器；GATE=1时不影响计数过程；|
|8计数值有效期|计数值重复有效；计数值可以看做没有0|



3方式特点：

- 若计数初值N为偶数，则输出波形是周期为N个CLK周期的对称方波；
- 若计数初值N为奇数，则输出波形是周期为N个CLK周期的基本对称波形，其高电平持续时间比低电平持续时间多一个CLK周期；
- 如果在计数过程中，GATE信号变低，则暂停现行计数过程，直到GATE再次有效，将从计数初值开始重新计数；
- 如果要求改变输出方波的频率，则CPU可在任何时候重新写入新的计数初值，并从下一个计数操作周期开始改变输出方波的频率。



#### 定时器方式4：软件触发选通信号

具体过程：当写入计数初值后，计数器自动开始计数，保持OUT为高，当计数值减到0时，在OUT端输出一个宽度等于时钟CLK脉冲周期的负脉冲，并停止工作。然后OUT信号变为高电平，并维持到再次写入新的计数值。



- ##### 方式4过程特点：

|控制特征|OUT和计数值的变化|
|--------------------------------|------------------------------------------------------------|
|1控制字写入|当控制字写入后，OUT=1|
|2计数值写入|OUT=1|
|3启动方式|写入计数值后再过一个时钟周期开始根据计数初值减1计数|
|4计数期间|OUT=1|
|5计数为0时|输出一个负脉冲，其宽度为1个时钟周期，然后自动变为高电平并保持下去。|
|6计数期间写入新的计数值|立即有效；在写入新计数值之后，在下一个时钟周期时以新计数值计数减1；<br>如果写入的计数值是2个字节，在写入第一个字节时，计数不受影响；<br>在写入第二个字节时，下一个时钟周期以新计数值计数减1。|
|7GATE的作用|GATE=0时，OUT=1，停止计数；<br>GATE=1时开始计数；<br>GATE状态不影响OUT的值。|
|8计数值有效期|计数值一次有效；|



4方式特点：

- 若设置计数初值为N，则在写入计数初值后的N个CLK脉冲，才输出一个负脉冲，负脉冲宽度为1个CLK周期；

- GATE为高时，允许计数，GATE为低时，禁止计数；

- 若在计数过程中改变计数值，则按新的计数值重新开始计数，即改变计数值是立即有效的。

- 4方式不具备计数初值重装能力，故输出单次波形。



#### 定时器方式5：硬件触发选通信号

具体过程：当写入计数初值后，由GATE门信号启动计数，OUT输出高电平，当计数值减到0时，在OUT端输出一个宽度等于时钟CLK脉冲周期的负脉冲，并停止工作。然后OUT信号变为高电平，并维持到再次写入新的计数值。



- ##### 方式5过程特点：

|控制特征|OUT和计数值的变化|
|--------------------------------|------------------------------------------------------------|
|1控制字写入|当控制字写入后，OUT=1|
|2计数值写入|OUT=1|
|3启动方式|**GATE上升沿启动**，GATE上升沿之后的**下一个时钟周期开始对计数初值减1计数。**|
|4计数期间|OUT=1|
|5计数为0时|输出一个负脉冲，其宽度为1个时钟周期，然后OUT自动变为高电平并保持下去。|
|6计数期间写入新的计数值|不影响本次计数。当GATE重新启动后，将按新的计数值计数。|
|7GATE的作用|GATE=0或1期间，不影响计数器减1动作；但若出现GATE上升沿，则按新计数值重启计数器，无论原计数过程如何。|
|8计数值有效期|计数值多次有效；当计数值减到0后，将重新装入计数值，但不计数，直到出现GATE上升沿。|



5方式特点：

- 若设置计数初值为N，则在门控信号GATE上升沿触发后，经过N个CLK脉冲，才输出一个负脉冲，负脉冲宽度为1个CLK周期。选通脉冲宽度等于时钟脉冲的周期。改变计数初值就可以改变选通脉冲产生的时间。

- 若在计数过程中再次出现门控GATE触发信号，则将使计数器从计数初值开始重新计数，但OUT输出的高电平不受影响；

- 若在计数过程中改变计数值，只要在计数到0之前不出现新的门控触发信号，则原计数过程不受影响，等计数到0并出现新的门控触发信号后，再按照新的计数值计数；若在写入了新的计数值后，在未计到0之前有门控触发信号出现，则立即按照新的计数值重新开始计数。

- 5方式不具备计数初值重装能力，也是输出单次波形。



### 小结：6 种工作方式的比较 

- 0方式和1方式：这两种方式的输出波形类似，均为单次波。区别在于计数启动方式不同，前者为软启动，后者是硬启动。  
- 2方式和3方式：这两种方式共同的特点是具有自动再加载（装入）功能能力。二者的区别在于：2方式连续输出宽度为1个CLK的负脉冲（(或占空比为N-1:1的方波)），3方式连续输出占空比为1:1的方波或近似方波。  
- 4方式和5方式：这两种方式的OUT输出波形相同，两者的区别是计数启动的触发信号不同，前者由写信号软启动计数，后者由GATE信号硬启动计数。 



<img src=".\media\8255的6种工作方式小结.webp" style="zoom: 50%;" />



### 计数初值

计数初值分两种情况：若作计数器用时，则无须计算，将计数的次数直接装入；若作定时器用时，则计数初值需要经过换算才能得到。

其换算方法如下：

- 产生时间间隔 𝜏 的时间常数T~c~

<img src="media/image-20211108091857843.webp" alt="image-20211108091857843" style="zoom: 67%;" />

- 产生频率为 𝑓 的信号波形的时间常数T~c~

<img src="media/image-20211108091911900.webp" alt="image-20211108091911900" style="zoom:67%;" />



#### 计数初值的范围

- 计数初值寄存器和减法计数器是16位，故计数初值的范围

  - 以二进制数表示为0000H～FFFFH；
  - 以十进制数（BCD）表示为0000～9999；

  

#### 计数初值的装入

由于82C54A内部的减法计数器和计数初值寄存器是16位，而82C54A外部引脚数据信号线只有8位，故16位计数初值要分两次装入，并且按先装低8位、后装高8位的顺序写入计数器的数据口。

只有2方式和3方式具有自动重装计数初值的功能，其他方式都需要用户通过程序人工重装计数初值。



### 82C54A的初始化

- 向命令寄存器写入方式命令字，包括选择计数器（3个计数器之一）、确定工作方式（6种方式之一）、指定计数器计数初值的长度、装入顺序、计数值的码制（BCD或二进制码）
- 向已选定的计数器按方式命令的要求写入计数初值
  - RW1RW0=01：只写入低8位，高位自动置0
  - RW1RW0=10：只写入高8位，低位自动置0
  - RW1RW0=11：先写低8位后写高8位



例：选择2号计数器，工作在3方式，计数初值为533H（2个字节），采用二进制计数

```assembly
MOV DX,307H    ; 命令口
MOV AL,10110110B    ; 2号计数器的方式命令字
OUT DX,AL
MOV DX,306H    ; 2号计数器数据口
MOV AX,533H    ; 计数初值
OUT DX,AL      ; 先送低字节到2号计数器
MOV AL,AH      ; 取高字节送AL
OUT DX,AL      ; 后送高字节到2号计数器
```



## 11. 中断技术

> 大多数比较新的处理器上都用不了 `HLT` 指令



计算机主机有多种与外设传送数据的方式：

- 通过处理器执行I/O指令完成
  - 无条件传送
  - 查询传送
  - 中断传送
- 以硬件为主，加快传输速度
  - 直接存储器存取（DMA）
  - 使用专门的I/O处理机



### 处理器的传送方式



#### 无条件传送

- IN/OUT指令就是无条件传送
- 处理器与慢速变化的设备交换数据
- 外设总是处于“就绪”状态，随时可以进行数据传送
- 无条件传送的接口电路只考虑数据缓冲 
- 无条件传送的软件编程十分简单



#### 程序查询传送

查询传送有查询和传送两个环节

- 首先查询外设工作状态
- 检测、等待外设准备就绪
- 进行数据传输



#### 查询过程

- 设计实现查询功能的电路
  - 连接外设的状态输入信号
  - 保存在状态寄存器中
  - 通过状态端口读取
- 外设的工作状态在状态寄存器中使用一位或若干位表达，查询通过输入指令来实现
- 有多个状态，按照一定原则轮流查询，先检测到就绪的外设先开始数据传送
- 实际中常引入超时判断



例：读取状态端口查询外设状态，若已就绪，读取数据端口得到外设提供的数据

```assembly
	mov dx,5001h	;DX指向状态端口
status:  
	in al,dx	    ;读状态端口
	test al,01h     ;测试状态位D0
	jz status     	;D0＝0，未就绪，继续查询
	
	dec dx          ;D0＝1，就绪，DX改指数据端口
	in al,dx	    ;从数据端口输入数据
```



### 中断的概念

- 中断是指CPU在正常运行程序时，由于内部/外部事件或由程序预先安排的事件，而转到为中断事件服务的程序中去，服务完毕再返回执行原程序，这一过程称为中断。
- 硬件中断： 由外部硬件产生的中断。
- 软件中断： 由程序预先安排的中断。
- 中断的特征：具有随机性。



<img src="media/image-20211110110803751.webp" alt="image-20211110110803751" style="zoom:50%;" />





中断类型：

- 硬中断

  - 可屏蔽中断 INTR：通过中断控制器用中断请求线 INTR 向微处理器申请而产生的中断，它可以用指令屏蔽与开放，CLI
  - 不可屏蔽中断 NMI：通过另一根中断请求线 NMI 向微处理器申请而产生的中断，它不可以用指令屏蔽与开放，且不受中断允许标志位(IF)的影响，所以是不可屏蔽中断

- 软中断

  - 发出中断指令 INT nH 产生：由软件中断指令引起的中断，例 INT n 等。无中断响应周期，中断号由指令中给出；该中断无法屏蔽。
    - DOS 功能调用
    - BIOS 功能调用
  - 内部突发事件引起：指令执行发生错误而引起的中断，这种情况下必须启动一个处理程序以解决问题，并恢复这条指令或下条指令的执行，如除以0的问题，32位CPU的取指令异常问题等。

  

### 中断号与中断号的获取

#### 中断号概念

系统分配给每个中断源的代号，以便识别与处理。16位微机支持256个中断号，统一编号为0-255号。向量中断中，CPU通过中断号n*4找到中断向量表中存放中断服务程序入口地址的位置，并转移到中断服务程序转移。



#### 中断号的获取

可屏蔽中断：在中断响应周期从中断控制器获取

软中断：由中断指令直接给出

不可屏蔽中断：预先设置



#### 中断号的分配

系统对外部中断和内部中断一律统一编号，共有256个号，微机系统的中断号分配如后表所示。表中两块灰色区域的中断号分别是系统分配给PC微机系统中的中断控制器主片与从片的中断号，用户可以采用修改其中断向量的方法进行应用。



### 中断触发方式

中断触发方式是指外部设备以什么逻辑信号向中断控制器申请中断，中断控制器允许用边沿或电平信号申请中断，即边沿触发和电平触发两种方式。触发方式在中断控制器初始化时设定。



### 中断排队方式

PC微机中断优先级的顺序：软件中断>不可屏蔽中断> 可屏蔽中断

中断排队的方式：

- 按优先级排队（使用最多）
  - 根据任务的轻重缓急，给每个中断源指定CPU响应的优先级，任务紧急的先响应，可以暂缓的后响应。
- 循环轮流排队
  - 不分级别高低，CPU轮流响应各个中断源的中断请求，并为其服务。



#### 中断嵌套

当CPU正处理某个中断时，出现更高级中断源的申请，CPU必须暂停该中断服务，转而去处理更高级中断的服务，待处理完后，再返回到被中断的服务程序继续执行。



### 中断入口地址

当发生中断，就意味着要发生程序的转移，即由主程序转移到服务程序去。那么，如何才能进入中断服务程序，即如何找到中断服务程序的入口地址是解决问题的关键。

为此，采用向量中断方式（不是查询中断方式），设置中断向量及中断向量表，通过中断向量表中的中断向量查找中断服务程序的入口地址。



### 中断向量

- CPU响应中断后，中断源提供中断号，再由中断号生成地址信息，由此地址信息对程序的执行进行导向，引导到中断服务程序中去，故把这个地址信息称为中断向量（存储单元）。

- 中断服务程序是预先设计好并存放在程序存储区的，因此，中断服务程序的入口地址由服务程序的段基址CS和偏移地址IP两部分共4个字节组成。中断向量包括中断服务程序的段基址CS，偏址地址IP共4个字节。
  - 中断发生时，从中断向量表中取出相应的值赋值给CS和IP的过程是由系统硬件自动完成的，程序员不可见！ 
  - 程序员能够做的就是修改中断向量表中存储的值。



### ※ 中断向量指针与中断类型号

**中断向量指针：指出中断向量存放在中断向量表的位置(或地址）**

- **中断类型号×4 = 中断向量最低字节的指针**

- **中断号×4 = 偏移地址IP**
- **中断号×4+2 = 段基址CS**

例如，8号中断中断源的中断向量在存储器中的地址：

- IP8 = 8×4 = 20H~21H       
- CS8 = 8×4+2 = 22H~23H

在PC系列中由中断类型号提供的，即向量地址 = 0000：类型号×4

- 如：硬盘“1NT13H”
  - 它的向量地址=0000：13H×4
    0000：004CH
- 004CH开始连续4个单元中用来存放“INT 13H”的中断向量

<img src="media/image-20211117103438362.webp" alt="image-20211117103438362" style="zoom:50%;" />



### 中断向量表

- 所有的中断向量集中存放到存储器的某一区域，这一区域称之为中断向量表。
- 在实模式下，规定存储器的000H-03FFH作为中断向量存储区（共1024个字节），这表明中断向量表的起始地址是固定的，并且从存储器的物理地址0开始。
- 每个中断向量包含4个字节，这4个字节在中断向量表中的存放规律是向量的偏移量（IP）存放在两个低字节单元中，向量的基址（CS）存放在两个高字节单元中。可容纳256个中断向量，即可处理256个中断服务程序。
- 中断向量号n*4=中断向量的地址指针

<img src="media/image-20211117103746944.webp" alt="image-20211117103746944" style="zoom:67%;" />



#### 中断向量表的填写

- 系统设置的中断服务程序，由系统负责填写中断向量。
  - 系统加电后BIOS填写其提供的服务程序中断向量；
  - 启动DOS时填写其提供的服务程序中断向量;
- 用户开发的中断服务系统，用户负责填写中断向量



### 中断处理过程

#### 可屏蔽中断 INTR 处理过程

包括4个阶段：

- **中断申请与响应握手(硬件自动完成，程序员不可见)**
  - 当外部设备要求CPU服务时，需向CPU发出中断请求信号，申请中断。
  - CPU若发现有外部中断请求，并且处在开中断条件（IF=1），又没有DMA申请，则CPU在当前指令执行结束时，进入中断响应总线周期，响应中断请求，并且通过中断回答信号，从中断控制器读取中断源的中断号，完成中断申请与中断响应的握手过程。
  - 这一阶段的主要目标是获取外部中断源的中断号。
- **标志位的处理与断点保存(硬件自动完成，程序员不可见)**
  - 微处理器获得外部中断源的中断号后，CPU把标志寄存器FLAGS压入堆栈，并置IF=0，关闭中断；
  - 置TF=0，防止单步执行。然后将当前程序的代码段寄存器CS和指令指针IP压入堆栈，这样就把断点（返回地址）保存到了堆栈的栈顶。
  - 这一阶段的主要目标是完成由主程序向服务程序转移前的准备工作。
- **向中断服务程序转移，并执行中断服务程序**
  - 将已获得的中断号乘以4得到地址指针，在中断向量表中，读取中断服务程序的入口地址CS:IP，再把它写入代码段和指令指示器，实现程序控制的转移。
  - 这一阶段的主要目标是完成主程序向中断服务程序的转移，或称为中断服务程序的加载。	
- **返回断点**
  - 中断服务程序执行完毕后，要返回主程序，因此，一定要恢复断点和标志寄存器的内容，否则，主程序无法继续执行。
  - 为此，在中断服务程序的末尾，执行中断返回指令IRET，将栈顶的内容依次弹出到IP、CS和FLAGS，就恢复了主程序的执行。
  - 这一阶段的主要目标是完成中断服务程序向主程序的转移。



#### 不可屏蔽中断、软件中断的处理过程

由于它们的不可屏蔽性，并且其中断号的获取方法与可屏蔽中断不一样，所以其中断处理过程也有所差别。其主要差别是：

- 不需通过中断响应周期获取中断号，是由系统分配的；
- 中断服务程序结束，不需发中断结束命令EOI，是自动结束方式。



### 82C59A 中断控制器

- Intel 82C59A是一种可编程中断控制器，可协助CPU对系统的中断进行管理。
- 82C59A的功能：
  - 接受和扩充外设的中断请求
  - 中断优先级排队
  - 提供中断类型号
  - 屏蔽或打开中断
  - 接受CPU命令或返回当前工作状态
- 一片82C59A可直接管理8级中断，通过级联可扩展至64级中断。
- 通过对82C59A进行编程，可设置多种工作方式，以满足不同中断系统的需要。



#### 外部特性和内部寄存器

外部特性：有三组信号线

- 面向CPU的信号
- 面向外设的8根中断请求线
- 面向同类芯片的中断请求级联线



#### 8259引脚功能

<img src="media/image-20211117104937680.webp" alt="image-20211117104937680" style="zoom:67%;" />

- INTA：对于8259是输入信号，对于CPU是输出信号

- 8086 CPU的INTA（Interrupt Acknowledge）是中断响应信号输出引脚，低电平有效；
  - 该引脚是CPU响应中断请求后，向8259发出的认可信号，用以通知8259作出相关准备，比如提供中断号、对内部寄存器做相关操作等。
    - 8259无外部时钟



#### 8259的总线连接方式和SP/EN

- 缓冲方式：8259A的数据线引脚设计是可与系统数据总线直接相连，但有时有一片或多片8259A希望有自己的局部数据总线，这时需要在8259A的数据线与系统数据总线之间加一个缓冲器。

- 双向控制：因为数据传送是双向的，所以该缓冲器也应是双向的。在缓冲器方式下，SP/EN为输出信号，用作控制缓冲器是接收方向还是发送方向。

- 主从区分：当不处于缓冲方式时，SP/EN为输入信号，用来指明该8259A是主片(SP=1)还是从片(SP=0)。

- 级联方式下，CAS0-CAS2：
  - 主、从8259的级联线，传送从片识别码，仅使用主片工作时不用这三根线。 
  - 在一主多从的级联方式下，主8259的CAS2-CAS0与所有从8259的CAS2～CAS0联在一起，主8259的CAS2～CAS0作为输出，从8259的CAS2～CAS0作为输入，3-8译码选择。
  - 当第一个INTA信号到来时，主8259根据自身优先级排列结果进行判断，
    - 若认为当前优先级最高的中断请求是来自从片x，那么主片的CAS2～CAS0输出从片x的编码ID2～ID0，用于从多个从片中选出从片x出来。
    - 每一个从片从8259收到该编码后，与其自身的ID2～ID0（在ICW3中设置）比较，如果相等，则该从片x根据自身的中断源优先级排队情况选出一个优先级最高的中断源y，在第二个INTA到来时，该从片x在总线上发出y对应的中断类型号。

<img src="media/image-20211117110118554.webp" alt="image-20211117110118554" style="zoom: 50%;" />



#### 内部寄存器

- **IRR：中断请求寄存器（Interrupt Request Register）**
  - 8位，以逻辑1记录已经提出中断请求的中断级，等待CPU响应。
  - 当提出中断请求的外设产生中断时，由82C59A置位，直到中断被响应才自动清零。
  - IRR的内容可以由CPU通过OCW3命令读出。
- **IMR：中断屏蔽寄存器（Interrupt Mask Register）**
  - 8位，对中断请求IRi起屏蔽作用
  - 哪一级中断被屏蔽，哪一位就置“1”，即禁止IRi提出中断请求
    - Di=0：开中断
    - Di=1：关中断
  - 该寄存器不可读
- **ISR：中断服务寄存器（Interrupt Service Register）**
  - 8位，以逻辑1记录已经已被响应并正在服务的中断级，包括尚未服务完中途被挂起的中断级，以便与后面新来的中断请求的级别进行比较。
  - 当中断请求 IRi 获得中断响应时， $\overline{INTA_1}$ 将 ISRi 置1，表明 IRi 正处于中断服务，此时控制逻辑不会产生 INT 信号，其它中断请求不会被响应。因此中断服务结束后必须对 IRi 清零。
  - 清零有两种方法：
    - 由 $\overline{INTA_2}$ 将该位自动清零；
    - 在中断服务程序中用中断结束命令 EOI 强制清零。
- **PR：优先级分析器（Priority Resolver）**
  - 中断请求的判优电路。PR把新中断请求的优先级与ISR寄存器中记录在案优先级进行比较，谁的优先级高就让谁申请中断。
  - 其操作过程全部由硬件完成，因此用户是不可访问的，它不属于82C59A的编程模型之内。
- ICW：初始化命令字（Initialization Command Word）
- OCW：操作命令字（Operation Command Word）



## ※ 82C59A端口地址

- 主片端口地址：20H 和 21H 
- 从片端口地址：0A0H 和 0A1H 
  - 具体使用哪个端口地址，由初始化命令ICW，和操作命令OCW的标志位A0指示



### 82C59A的工作方式

<img src="media/image-20211117113847406.webp" alt="image-20211117113847406" style="zoom:50%;" />

- ##### 中断触发方式

  - 确定中断请求的启动方式
    - 边沿触发方式：IR0-IR7线上出现由低到高的跳变，表示有中断请求。
    - 电平触发方式：IR0-IR7线上出现高电平时，表示有中断请求。

- ##### 中断级联方式

  - 82C59A可以单片使用，也可以多片使用，级联方式应用时有主片和从片的问题。
  - 最大级联方式为1主片8从片，64个外部中断。

- ##### 中断屏蔽方式

  - 允许还是不允许外设提出中断请求，而不是对已经提出的中断申请响不响应的问题
    - 常规屏蔽方式：通过屏蔽寄存器写入8位屏蔽码来屏蔽或开放8个中断申请线IR0-IR7上的中断请求。
      屏蔽哪个中断申请则将屏蔽码的相应位置为1，反之则置为0。
    - 特殊屏蔽方式：用于开放低级别的中断申请，允许比正在服务的中断级别低的中断申请。
      该方式很少使用。

- ##### 中断优先级排队方式

  - 完全嵌套方式：只能高优先级中断低优先级的中断
  - 特殊完全嵌套方式：同级优先级的中断可以相互中断
  - 优先级轮换方式：被服务完的中断源优先级将自动变为最低，而其后的中断源的优先级将变为最高。
  - 优先级轮换方式有两种：
    - 优先级自动轮换方式：当一个中断被服务后，自动降为最低，初始顺序是：IR0，IR1，…
    - 优先级指定轮换方式：差别是初始轮换的优先级可以由程序指定

- ##### 中断结束方式

  - 自动结束方式 （少用）
    - 在中断响应周期，就自动清零了该中断源的ISR寄存器中被置1的位。这常用于没有中断嵌套的系统。
  - 非自动结束方式 （常用）
    - 在中断服务程序后，必须使用中断结束命令 EOI 才能清除ISR中的相应位。
    - 指定中断结束命令：即要指定结束中断请求IRi的编号，代码 6XH (X=0-7) 
    - 常规中断结束命令：不指定IRi的编号，用于支持中断嵌套功能的系统，代码 20H



## ※ 82C59A的编程命令

8259A有两类编程命令，初始化命令字ICW和操作命令字OCW，都是通过D0-D7传输的。

- **ICW** 
  - 在初始化里完成，必须按一定的顺序
  - 在PC机中已有系统软件完成，不需要也**不允许**由用户自己去设置
  - 一般只对于没有配置完善操作系统的单板微机上进行
- **OCW** 
  - 没有一定的顺序，一般也不安排在程序的开头
  - 在初始化后的任何时候进行动态控制



### 初始化命令字 ICW 

- 设置中断屏蔽方式是默认常规屏蔽方式，如要改动，可以执行操作命令OCW3
- 注意：必须在对82C59A初始化时完成；
- 需要**按顺序发送**ICW 1 – ICW4；



#### ICW1：进行中断触发和单片/多片设置

<img src="media/image-20211117114805533.webp" alt="image-20211117114805533" style="zoom: 50%;" />



#### ICW2：进行中断号设置

只需要写高5位；

<img src="media/image-20211117114914182.webp" alt="image-20211117114914182" style="zoom: 50%;" />

<img src="media/image-20211117114952127.webp" alt="image-20211117114952127" style="zoom:50%;" />



#### ICW3：进行级联设置

<img src="media/image-20211117115559879.webp" alt="image-20211117115559879" style="zoom: 50%;" />



例：从片A和从片B的请求线INT连到主片的IR3和IR6

则初始化程序：

```assembly
; 主片的ICW3=01001000B=48H
MOV AL, 48H	    ; 主片的ICW3
OUT 21H, AL

; 从片A的ICW3=00000011B=03H
MOV  AL, 03H 	; 从片A的ICW3, 写入3
OUT  0A1H, AL	
      
; 从片B的ICW3=00000110B=06H
MOV  AL, 06H 	; 从片B的ICW3, 写入6
OUT  0A1H, AL 
```



#### ICW4：进行优先级和结束方式设置

一般选红色的；

<img src="media/image-20211117115925543.webp" alt="image-20211117115925543" style="zoom:50%;" />



例：某计算机的CPU为8086，8259A与系统总线之间采用缓冲器连接，非自动结束方式，只用1片8259A，正常完全嵌套。

解：可得ICW4=00001101B=0DH，初始化程序段：

```assembly
MOV   AL, 0DH
OUT  21H, AL
```



### 操作命令字 OCW 

- 初始化后，使用OCW命令对中断控制器进行动态控制
- 不需要按顺序发送，在程序中任意安排



#### OCW1：进行常规的屏蔽开放操作

<img src="media/image-20211117120400141.webp" alt="image-20211117120400141" style="zoom:50%;" />

例：要使中断源IR3开放，其余被屏蔽；

OCW1=11110111B=F7H

如果不想影响其它中断，应该写成下列程序段：

```assembly
IN   AL, 21H       ; 回读21H端口的内容
AND  AL, 11110111B
OUT  21H, AL
```



#### OCW2：进行中断结束和优先级轮换排队操作

<img src="media/image-20211117121026553.webp" alt="image-20211117121026553" style="zoom:50%;" />



- 中断结束控制（OCW2格式中的D6）
  - 当初始化命令ICW4选用非自动结束方式时（即AEOI=0） ，就利用OCW2来控制中断结束：
  - SL（D6）=0 ，结束当前中断  
    - OCW2=00100XXXB (XXX=任意值，常用000）      
  - SL（D6）=1，结束指定中断  
    - OCW2=01100L2L1L0

例：指定IR5的中断结束，则 OCW2=01100**101**B=65H



- 作中断优先级排队控制（OCW2格式中的D7）

<img src="media/image-20211117121109876.webp" alt="image-20211117121109876" style="zoom: 50%;" />

注意：中断结束方式和中断排队方式都用OCW2命令来实现，因此它的某些位功能相互交叉显然比较复杂，但其作用只有两个：

1. 控制中断结束方式
2. 控制中断优先权轮换方式



##### OCW2 总结

<img src="media/image-20211117121300163.webp" alt="image-20211117121300163" style="zoom:50%;" />



例1：要对IR3中断指定中断结束方式，OCW2=01100011B=63H。

在中断服务程序中, 中断返回指令IRET前, 写相应的程序段： 

```assembly
MOV  AL, 63H
OUT  20H, AL   ; 写入OCW2端口(A0=0)
```



例2：对IR3中断采用不指定中断结束方式，OCW2=00100000B=20H。

在中断服务程序中，中断返回指令IRET前, 写相应的程序段： 

```assembly
MOV  AL, 20H
OUT  20H, AL   ; 写入OCW2端口(A0=0)
```



#### OCW3：设定屏蔽方式和读取状态

- 读取8259A的IRR、ISR寄存器的内容
- 设置特定屏蔽方式
- 查询中断方式

<img src="media/image-20211121223909362.webp" alt="image-20211121223909362" style="zoom:50%;" />



##### 读状态操作（OCW3格式中的D1-D0 ）

- 8259A内部有3个寄存器IRR、ISR、IMR可供CPU读出当前的内容。
- 读IRR和ISR的方法：
  - CPU先指定读哪个寄存器，然后再发IN指令，才能读取ISR和IRR中的内容
  - 当8259A初始化后，自动指向读IRR寄存器
- 读IMR的方法：
  - 不需要先发指定命令，只要**读奇地址端口**
  - OCW1的例子中的 `IN  AL, 21H` 读了21H端口的内容



例1：读ISR寄存器的内容

步骤：

- 通过OCW3指定被读的寄存器
- OCW3为00001**011**B, 表示下个RD要读ISR
- 用IN指令读出ISR寄存器的内容

程序段如下：

```assembly
MOV  AL, 0BH    ; OCW3表示读ISR
OUT  20H, AL    ; 20H为OCW3的端口地址
IN   AL, 20H    ; 读ISR寄存器  
```



例2：读IRR寄存器的内容

步骤：

- 通过OCW3指定被读的寄存器
- OCW3为00001**010**B, 表示下个RD要读IRR
- 用IN指令读出IRR寄存器的内容

程序段如下：

```assembly
MOV  AL, 0AH    ; OCW3表示读IRR
OUT  20H, AL    ; 20H为OCW3的口地址
IN   AL, 20H    ; 读IRR寄存器
MOV  AH, AL     ; 保存IRR->AH
```



例3：读查询字(读回中断状态)

步骤：

- 通过OCW3发送出查询命令
- OCW3为00001**100**B, 表示下个RD要读查询字
- 用IN指令读出查询字的内容

程序段如下：

```assembly
MOV  AL, 0CH    ; 用 OCW3 发送查询命令
OUT  20H, AL    ; 20H 为 OCW3的口地址
IN   AL, 20H    ; 读查询字
MOV  AH, AL     ; 保存查询字 ->AH 
```



##### 查询字的格式

当有中断请求时，8259A将IRR中的相应位置1，同时将查询字送到数据总线上供CPU读取；

查询中断前CPU先关闭中断申请，再发查询命令；

<img src="media/image-20211121225611698.webp" alt="image-20211121225611698" style="zoom:50%;" />





#### 8259A 的同一端口如何区分 ICW 和 OCW 

A0=0 (偶地址端口) 写入：

- D4=1 → ICW1
- D4=D3=0 → OCW2
- D4=0, D3=1 → OCW3

A0=1 (奇地址端口) 写入：

- 按顺序写 ICW2 → （ICW3 → ICW4） → OCW1 



### 8259工作原理小结

两个阶段：初始化阶段和工作阶段



<img src="media/image-20211122081116830.webp" alt="image-20211122081116830" style="zoom:50%;" /> 



<img src="media/image-20211122081127484.webp" alt="image-20211122081127484" style="zoom:50%;" /> 



### 可屏蔽中断系统

对系统的82C59A初始化编程不是由用户设定，而是在微机启动后由处理器按初始化设置要求自动完成。

用户的工作是：

- 修改中断向量
- 发中断屏蔽/开放及中断结束命令
- 编写中断服务程序

<img src="media/image-20211122081247205.webp" alt="image-20211122081247205" style="zoom:67%;" />



#### 系统对中断控制器初始化程序段

82C59A主片初始化程序段如下：

```assembly
INTA00 EQU 020H       	;82C59A主片端口(A0=0)
INTA01 EQU 021H       	;82C59A主片端口(A0=1)

MOV AL,11H           	;ICW1：边沿触发，多片，要ICW4（A0=0）
OUT INTA00,AL
JMP SHORT$+2          	;I/O端口延时要求（下同）
MOV AL,8H             	;ICW2：中断号的高5位（A0=1）
OUT INTA01,AL
JMP SHORT$+2
MOV AL,04H           	;ICW3：主片的IR2上接从片（A0=1）
OUT INTA01,AL
JMP SHORT$+2
MOV AL,01H           	;ICW4：非缓冲，全嵌套，16位的CPU，非自动结束
OUT INTA01,AL
```



82C59A从片初始化程序段如下：

```assembly
INTB00 EQU 0A0H      	;82C59A从片端口(A0=0)
INTB01 EQU 0A1H      	;82C59A从片端口(A0=1)

MOV AL,11H          	;ICW1：边沿触发，多片，要ICW4
OUT INTB00, AL
JMP SHORT$+2
MOV AL,70H          	;ICW2：中断号的高5位
OUT INTB01, AL
JMP SHORT$+2
MOV AL,02H          	;ICW3：从片接主片的IR2（ID2ID1ID0=010）
OUT INTB01,AL
JMP SHORT$+2
MOV AL,01H              ;ICW4：非缓冲，全嵌套，16位的CPU，非自动结束
OUT INTB01,AL
```



### 修改中断向量

中断向量修改的方法是利用DOS功能调用INT21H的35H号功能（获取）和25H号功能（设置）

INT21H系统功能调用为用户程序修改中断向量提供了两个读/写中断向量的功能号

<img src="media/image-20211122090135013.webp" alt="image-20211122090135013" style="zoom:50%;" />



#### 中断向量修改与恢复的步骤

1. 调用35H号功能，从向量表中读取某一中断号的原中断向量，并保存在双字节变量中；

2. 调用25H号功能，将新中断向量写入中断向量表中原中断向量的位置，取代原中断向量；

3. 新中断服务程序完毕后，再用25H号功能将保存在双字节变量中的原中断向量写回去，恢复原中断向量；



```assembly
CLI   ; 修改中断向量时要关中断！
MOV	AH, 35H
MOV	AL,	N			 
INT	    21H

MOV	OLD_SEG，ES  ; 保存原中断向量
MOV	OLD_OFF，BX
MOV	DX,  SEG INTRnew     ; 取新中断向量段基地址
MOV	DS,  DX
MOV	DX,  OFFSET INTnew   ; 取新中断向量偏移地址
MOV	AL,	 N			     ; 中断类型号为N
MOV	AH,  25H
INT	     21H

; 新中断程序服务 ...

MOV	DS,  OLD_SEG
MOV	DX,  OLD_OFF					
MOV	AL,	 N
MOV	AH,  25H
INT	     21H 
```



#### 发中断屏蔽/开放和中断结束指令

- 主程序中写OCW1执行中断屏蔽与开放
- 中断服务程序中写OCW2，发中断结束信号EOI和使用IRET中断返回。

一般格式：

```assembly
NEW_INT PROC FAR
; 寄存器进栈，保护现场
CLI    ; 关中断

...	; 服务程序主体
			
; 向主/从82C59A发中断结束命令	
	MOV  AL, 20H
	OUT  20H, AL
; 寄存器出栈，恢复现场(注意顺序对称)

STI    ; 开中断
IRET   ; 中断返回
NEW_INT ENDP
```



### 中断服务程序设计

#### 注意事项

实验箱用不了INT 21 AL=35和AL=25，得手动改地址

微机需要在中断程序里手动发EOI



##### 例1  利用82C59A主片设计中断服务程序

<img src="media/image-20211122091930905.webp" alt="image-20211122091930905" style="zoom:67%;" />

- 要求：电路如图所示。微动开关SW中断请求连接到IRQ7。每按下一次申请1次中断。按8次后显示“OK!”，程序结束。
- 分析：IRQ7的中断号为0FH，系统分配给打印机中断。当打印机空闲不用时，可以通过修改中断向量加以利用



程序：

```assembly
; 堆栈段定义
STACK SEGMENT
     DW 200 DUP(?)
STACK ENDS

; 数据段定义
DATA SEGMENT
     OLD_IV DD ?    ; 保存原中断向量的双字单元
     MK_BUF DB ?    ; 保存原屏蔽字的字节单元
     BUF DB 'OK!',ODH,OAH,$   ; 提示符
DATA ENDS

CODE SEGMENT
ASSUME CS:CODE, DS:DATA, SS:STACL
; 发中断开放指令
START: 
    MOV AX,DATA
    MOV DS,AX
    IN AL,21H               ; 保存原屏蔽字
    MOV MK_BUF,AL
    CLI                     ; 关中断
    AND AL,01111111B  ; 开放0FH号中断(OCW1), (01111111B=7FH)
    OUT 21H,AL

; 修改中断向量
      CALL GET_IV    ; 获取原中断向量，并保存
      CALL SET_IV    ; 设置用户程序新中断向量
; 主程序主体
      XOR DX,DX      ; 清空计数器 DX 
L1: 
      STI            ; 开中断
      CMP DX,8       ; 计数是否到8
      JNZ L1         ; 未到，继续等待微动开关中断
      
; 中断8次结束，恢复原来的中断向量和屏蔽字    
      CLI              ; 已到，关中断
      CALL RENEW_IV    ; 恢复原中断向量
      MOV AL,MK_BUF    ; 恢复原屏蔽字(OCW1)
      OUT 21H,AL
      STI              ; 开中断
      
; 中断结束，显示“OK!”
      MOV AX, SEG BUF
      MOV DS, AX
      MOV DX, OFFSET BUF
      MOV AH,09H
      INT 21H
      
; 返回DOS 
      MOV AX,4C00H
      INT 21H

; 中断服务程序SW_INT
SW_INT PROC FAR             
    PUSH AX
    CLI           ; 关中断
    INC DX        ; 计数加1
    MOV AL,67H    ; 发中断结束命令（OCW2）
    OUT 20H,AL
    POP AX
    STI           ; 开中断
    IRET          ; 中断返回
SW_INT ENDP

; 获取原中断向量子程序
GET_IV PROC NEAR
      MOV AX,350FH
      INT 21H
      MOV WORD PTR OLD_IV, BX
      MOV	BX，ES
      MOV WORD PTR OLD_IV+2,BX
      RET
GET_IV ENDP

; 设置新中断向量子程序
SET_IV PROC NEAR
       PUSH DS
       MOV AX,SEG SW_INT
       MOV DS,AX
       MOV DX,OFFSET SW_INT
       MOV AX,250FH
       INT 21H
       POP DS
       RET
SET_IV ENDP

; 恢复原来的中断向量子程序
RENEW_IV PROC NEAR
         PUSH DS
         MOV DX,WORD PTR OLD_IV
         MOV AX,WORD PTR OLD_IV+2
         MOV DS,AX
         MOV AX,250FH
         INT 21H
         POP DS
         RET
RENEW_IV ENDP
```



##### 例2  利用82C59A从片设计中断服务程序

- 要求：电路如图所示。微动开关SW中断请求连接到IRQ10。每按下一次申请1次中断,显示“OK!”，程序结束
- 
  分析：IRQ10是从片的IR2引脚上的中断请求，中断号为72H，是系统保留的，用户可以使用。由于是从片，在执行屏蔽开放和中断结束命令时，要考虑主片的相应操作。		

```assembly
; 数据段定义
DATA SEGMENT
     INT_OFF DW ?
     INT_SEG DW ?
     BUF DB 'OK!',ODH,OAH,$
DATA ENDS

; 段地址定义
STACK SEGMENT
     DW 200 DUP(?)
STACK ENDS

START: MOV AX, DATA
       MOV DS, AX
       MOV ES, AX
       MOV AX, STACK
       MOV SS, AX
; 获取原中断向量
      MOV AX,3572H
      INT 21H  
      MOV INT_OFF,BX
      MOV BX,ES
      MOV INT_SEG,BX
      
; 装入新中断向量
      CLI
      MOV DX,SEG SW_INT
      MOV DS,DX
      MOV DX,OFFSET SW_INT
      MOV AX,2572H
      INT 21H
      MOV AX,DATA
      MOV DS,AX
; 开放主片IRQ2的中断屏蔽
      IN AL,21H
      AND AL,11111011B(FBH)
      OUT 21H,AL
; 开放从片IQR2的中断屏蔽
      IN  AL,0A1H
      AND AL,11111011B(FBH)
      OUT 0A1H,AL
; 主程序
      STI
      HLT

; 中断结束恢复原中断向量
      CLI
      MOV DX,INT_SEG
      MOV DS,DX
      MOV DX,INT_OFF
      MOV AX,2572H
      INT 21H
      MOV AX,DATA
      MOV DS,AX
; 中断结束屏蔽主片IRQ2
       IN AL,21H
       OR AL,00000100B(04H)
       OUT 21H,AL
; 中断结束屏蔽从片IQR2
       IN  AL,0A1H
       OR AL,00000100B(04H)
       OUT 0A1H,AL
       STI
; 中断结束，显示“OK!”
      MOV AX, SEG BUF
      MOV DS, AX
      MOV DX, OFFSET BUF
      MOV AH,09H
      INT 21H
; 返回DOS 
      MOV AX,4C00H
      INT 21H


; 中断服务程序SW_INT
SW_INT PROC FAR             
       PUSH AX
       CLI 
       MOV AL,20H ; 主片发EOI命令
       OUT 20H,AL
       MOV AL,62H ; 从片发EOI命令
       OUT 0A0H,AL
       STI     
       POP AX
       IRET
SW_INT ENDP
```



##### 例3 中断方式数据传输

<img src="media/image-20211124105511290.png" alt="image-20211124105511290" style="zoom:67%;" />

<img src="media/image-20211124105449470.png" alt="image-20211124105449470" style="zoom: 67%;" />

<img src="media/image-20211124105459432.png" alt="image-20211124105459432" style="zoom:67%;" />





## 12. A/D 与 D/A 转换器接口 

### 概念

#### A/D转换器：模拟量 → 数字量的转换

- 简称 ADC
- 数据采集和过程控制是连续变化的物理量（温度等）而计算机处理的是离散的数字量，需要对连续变化的物理量进行采样、保持，将模拟量转换为数字量交给计算机处理、保存等。
- 分类：按分辨率可分为4位/6位/8位/10位/14位/16位和BCD码的312位、512位等 ；按照转换速度可分为超高速、高速、中速及低速等；按转换原理可分为直接ADC（有逐次逼近型、并联比较型等 ）和间接ADC （有电压／时间转换型（积分型）、电压／频率转换型、电压／脉宽转换型等 ）
- ADC的数字量输出位数越多，其分辨率就越高。
  ADC的分辨率反映在它的输出数据线的宽度上，如ADC0809的分辨率是8位，它的数据线也是8根。当分辩率大于微机系统数据总线宽度时，每次转换都需要两次数据的传输。



#### D/A转换器：数字量 → 模拟量的转换

- 计算机输出的数字量需要转换为模拟量去控制某些执行元件（如声卡播放音乐等）。



### A/D转换器

#### A/D转换器的技术指标

##### 分辨率

- 指ADC能够把模拟量转换成二进制的位数；
- ADC的数字量输出位数越多，其分辨率就越高。
- ADC的分辨率反映在它的输出数据线的宽度上，如ADC0809的分辨率是8位，它的数据线也是8根。
- 当分辩率大于微机系统数据总线宽度时，每次转换都需要两次数据的传输。



例：用1个10位ADC转换一个满量程为5V的电压，则能分辨的最小电压为5000mV/210≈5mV。若模拟输入值小于5mV，则ADC无反映，输出保持不变。

若用12位ADC转换，则能分辨的最小电压为5000mV/212≈1mV



##### 转换时间

- 指从输入转换启动开始到转换结束，得到稳定的数字量输出为止所需要的时间。
- 转换时间的快慢将会影响ADC接口与CPU交换数据的方式：
  - 对于低中速的ADC一般采用查询或中断方式；
  - 对于高速的ADC应采用DMA方式；



#### A/D转换器的外部特性

A/D转换器内部一般没有设置供用户访问的寄存器，也没有命令字。

它的转换操作是由其内部硬件逻辑电路完成的，而不是它执行内部的命令完成的，因此，它不好用可编程特性的编程模型来表述。在分析A/D转换器芯片时，主要是看它的外部连接特性，其中转换启动信号是CPU对A/D转换器唯一的控制信号。



从外部特性来看，无论是哪种ADC芯片，都必不可少地设置有4种基本外部信号线。这些信号线是实现A/D转换操作的条件，也是设计ADC接口硬件电路的依据。

1. **模拟信号输入线**：来自被转换对象的模拟量输入线，有单通道输入与多通道输入之分。
2. **数字量输出线**：ADC的数字量数据输出线，数据线的根数表示ADC的分辨率。
3. **转换启动线**：外部控制信号，此信号一到，A/D转换才能开始，启动转换信号不到，ADC不会自动开始转换，并且是发一次启动信号只能转换一次，采集一个数据。
4. **转换结束线**：转换完毕后由ADC发出A/D转换结束信号，利用它以查询或中断方式向微处理器报告转换已经完成。只有转换结束信号出现时，微处理器才可以开始读取数据。



#### A/D转换器与CPU的连接

##### 启动信号

ADC的转换启动方式有脉冲启动和电平启动之分。

- 若是脉冲启动，则只需接口电路提供1个宽度满足启动要求的脉冲信号即可。一般采用 $ \overline{IOW}$ 或 $ \overline{IOR}$ 脉宽。
- 若是电平启动，则要求启动信号的电平在转换过程中保持不变。为此，就应增加附加电路（如D触发器/单稳电路）或采用可编程并行I/O接口芯片来锁存这个启动信号，使之在转换过程中维持不变。

ADC的转换启动信号有单个信号启动和由多个信号组合起来的复合信号启动之分。

- 若是由单个信号启动，如 ADC0809 的 START，则只需接口电路提供1个START正脉冲信号。
- 若是由复合信号启动，如 AD574A 的 $ \overline{CE} ·  (R/\overline{C}=0) ·  \overline{CS}$ ， 则  $ \overline{CE}$，$ R/\overline{C}=0$，$ \overline{CS}$ 三个信号要同时满足要求才能启动。



##### 模拟量输入的控制信号

ADC的模拟信号输入信号有多通道和单通道之分。

- 若是多通道，则要求接口电路提供通道地址线及通道地址锁存信号线，以便选择与确定输入模拟量的通道号。
- 若是单通道，则不需要处理。



##### 数字量输出的控制信号

ADC的数据输出是否是三态锁存器？

- 若是，则ADC的输出数据线可直接挂在CPU的数据总线上；
- 否则，必须在ADC的输出数据线与CPU的数据总线之间外加三态锁存器才能连接。

ADC的分辨率与系统数据总线宽度是否一致？

- 若一致，则数据只需1次传输，数据线可直接连接；
- 若不一致，则数据需分批传输，应增加附加电路（缓冲寄存器）。



##### 转换结束信号

A/D转换结束后，用转换结束信号通知CPU，转换已经结束，请求读取数据。

转换结束信号的逻辑定义，有的是高电平有效，有的是低电平有效。

转换结束信号可用于查询方式、中断方式、DMA方式的申请信号。



##### A/D转换器数据传输

A/D采集的速度取决于：A/D 转换器的转换时间 T 、将数据存入内存所需要的数据传输时间 τ

则采集速率的上限为： $f0 =1/(T+τ)$

数据的传送可采用查询、中断和DMA方式，不同的方式的电路组成和编程方法不同。

上述几种方法采集数据的速度是：查询＜中断＜DMA



### D/A转换器

#### D/A转换器的技术指标

##### 分辨率

- 指DAC能够把多少位二进制数转换成模拟量。
- 分辨率体现在DAC的数据输入线的宽度，因此，不同的分辨率将影响DAC与CPU的数据线连接。
- 当分辨率大于数据总线宽度时，数据分几次传输，需增加附加电路（缓冲寄存器）。

例：DAC0832能够把8位二进制数转换成电流，所以DAC0832的分辨率是8位。

AD390能够把12位二进制数转换成电流，所以AD390的分辨率是12位。



##### 转换时间

- 从数字量输入到DAC完成转换所需要的时间。
- DAC的转换时间很快，一般为μs级和ns级。



#### D/A转换器的外部特性

DAC的外部信号线包括：

**基本信号：**

- 数字信号输入线
- 模拟信号输出线
- $ \overline{CS}$ 信号线和 $ \overline{WR}$ （或 $ \overline{WR_1}$ ， $ \overline{WR_2}$ 信号线）
  - 用于形成DAC的启动转换信号

**附加信号线：**

- 数据输入锁存控制线
- 模拟量输出通道地址线



说明：

- 附加信号线有时也集成在DAC芯片内部。

- 当DAC芯片内部设置了三态输入锁存器，则在外部就有输入锁存允许信号线。
  - 有的芯片（如DAC0832）设置了两级输入锁存器，相应地在外部就有两级输入锁存允许信号线。
  - 如果有的芯片（如AD390）设置了输出模拟量开关，则在外部就有模拟量输出通道地址选择信号。
- DAC的没有像ADC那样专门的“转换启动”信号线，也没有“转换结束”信号线；



#### D/A转换器与CPU的连接

DAC与CPU的接口包括硬件连接和软件编程，DAC与CPU之间的数据传输是无条件传输。 

DAC接口电路的结构形式也有下列几种： 

- 采用中小规模逻辑芯片
- 利用可编程并行I/O接口芯片
- 采用GAL器件





DAC一般不需要专门的控制信号去触发，也不提供转换结束状态信号；只要CPU把数据送到它的输入端，DAC就开始转换。

DAC有时需要增加锁存缓冲器，提供锁存控制信号

启动方式只有脉冲触发一种，无专门的转换启动信号，利用 $CS$ 和 $IOW$ 共同进行假写操作实现脉冲启动；

数据传输方式只有无条件传输一种。 



因此DAC需要解决的是

1. CPU与DAC之间的数据缓冲问题；
2. 当D/A转换器的分辩率大于数据总线的宽度时，CPU必须分两次传送和同时选通这些锁存器。



## ※ DAC0832 D/A转换器

引脚及内部结构：

<img src="media/image-20211201194119522.png" alt="image-20211201194119522" style="zoom:67%;" />



#### DAC0832 的工作方式

DAC0832 有两个独立的缓冲器，要转换的数据先送到第一级缓冲器，但不进行转换，只有数据送到第二级缓冲器时才能开始转换，因而称为双缓冲。

DAC0832 设置了5个信号控制这两个缓冲器进行数据的锁存：

- 其中，$ILE$（输入锁存允许）、 $ \overline{CS}$ （片选）和 $ \overline{WR_1}$ （写信号1）组合控制第一级缓冲器的锁存
- $ \overline{WR_2}$ （写信号2）和 $ \overline{XFER}$ （传递控制）两个信号组合控制第二级缓冲寄存器的锁存



- ##### 直通方式

  - LE1＝LE2＝1
  - 输入的数字数据直接进入D/A转换器

<img src="media/image-20211201194838709.png" alt="image-20211201194838709" style="zoom:50%;" />

- ##### 单缓冲方式

  - LE1＝1 或 LE2＝1
  - 两个寄存器之一始终处于直通状态
  - 另一个寄存器处于受控状态（缓冲状态）

<img src="media/image-20211201194914706.png" alt="image-20211201194914706" style="zoom:50%;" />

- ##### 双缓冲方式

  - 两个寄存器都处于受控（缓冲）状态
  - 能够对一个数据进行D/A转换的同时输入另一个数据
    - 典型用法：多目标的同时控制，把各片的 $ \overline{WR_2}$ 和 $ \overline{XFER}$ 连在一起作为公共控制点。

<img src="media/image-20211201194930496.png" alt="image-20211201194930496" style="zoom:50%;" />



#### 例：DAC0832接口电路设计

<img src="media/image-20211201195307195.png" alt="image-20211201195307195" style="zoom:50%;" />



以下程序是产生锯齿波的程序

```assembly
; 8255初始化
MOV DX, 303H 	   ; 8255的命令口
MOV AL, 10000000B    ; 8255的方式字
OUT DX, AL     	   
; 指定B口控制DAC的转换
MOV DX, 301H    	  ; 8255A的B口地址
MOV AL, 00010000B    ; 置DAC0832为直通工作方式
;ILE置为1, CS/WR1/WR2/XFER均置为0  
OUT DX, AL  

MOV AL, 0H   ; 输出数据从0开始
 
; 生成锯齿波的循环  
LOP:  
    MOV DX, 300H ; 8255A的A口地址
    OUT DX, AL   ; AL的值送DAC0832
    MOV BL, AL   ; 保存AL→BL
    MOV AH, 0BH  ; 检查是否有任意键按下
    INT 21H
    CMP AL, 0FFH
    JE  STOP     ; 有, 则停止输出波形
    MOV AL, BL   ; 无, 恢复AL的值
    INC AL  ; 输出数据加1
    JMP LOP ; 继续循环输出波形
STOP: 
    MOV AX,4C00H
    INT 21H 
```



以下程序是产生三角波的程序

```assembly
; 生成三角波的循环
    MOV DX, 300H    ; 8255A的A口地址
    MOV AL, 0H      ; 输出数据从0开始
L1: 
    OUT  DX, AL     
    MOV  BL, AL     ; 保存AL→BL
    MOV  AH, 0BH    ; 检查是否有任意键按下
    INT  21H
    CMP  AL,0FFH    
    JE   STOP       ; 有, 停止
    MOV  AL,BL      ; 无, 恢复AL的值
    INC  AL	      ; AL加1
    JNZ  L1	      ; AL是否加满？未满, 继续
    MOV  AL,0FFH    ; 已满, AL全置1
L2: 
    OUT  DX, AL 
    MOV  BL, AL    ; 保存AL→BL
    MOV  AH, 0BH   ; 检查是否有任意键按下
    INT  21H
    CMP  AL,0FFH
    JE   STOP      ; 有, 则停止
    MOV  AL,BL     ; 无, 则恢复AL的值
    DEC  AL		 ; 输出数据减1
    JNZ  L2        ; AL是否减到0？不为0, 继续
    JMP  L1        ; 为0, AL加1
```



## ※ ADC0809 多通道 A/D 转换器

#### 外部特性

- 多通道（8通道）
- 片内带三态输出锁存器
- 8位分辨率
- 转换时间：100μs
- 供电：单5V电源供电
- 封装：DIP24
- 参考电压：外接0-5VDC
- 时钟：外接不大于2MHz



#### 内部逻辑示意图

<img src="media/image-20211201111024913.png" alt="image-20211201111024913" style="zoom:67%;" />

- ADC0809有8个模拟量输入端（IN0～IN7），相应设置3根模拟量通道地址线（ADDA～ADDC），用以编码来选择8个模拟量输入通道。
  - 还设置1根通道地址锁存允许信号ALE，高电平有效。
  - 当选择通道地址时，需使ALE变高，锁存由ADDA～ADDC编码所选中的通道号，将该通道的模拟量接入ADC。
- ADC0809的分辨为8，有8根数字量输出线（D7～D0），带有三态输出锁存缓冲器。
  - 还设置了1根数据输出允许信号OE，高电平有效。
  - 当读数据时，要使OE置高，打开三态输出缓冲器，把转换的数字量送到数据线上。
- ADC0809的启动信号是START，正脉冲（下降沿）。转换结束信号为EOC，转换过程中为低电平，转换完毕变为高电平，可以利用EOC的上升沿申请中断，或作查询用。



#### ADC0809 的时序图

<img src="media/image-20211201111346039.png" alt="image-20211201111346039" style="zoom: 50%;" />

- **启动转换**：先通过ADD引脚选择通道号后，使ALE和START的引脚都为高电平；
- **读取数据**：等待转换结束信号EOC变为高电平后，在OE引脚加高电平，才能从数据线上读取数据。



### 例：中断方式 ADC 数据采集

#### 接口电路结构形式

采用可编程接口芯片82C55A，并把转换结束信号EOC连到系统总线的IRQ4实现中断传送。



#### 中断处理

本例题是利用系统的中断资源，故不需做中断系统的硬件连接和82C59A的初始化，只需做两件事：

- 中断向量的修改，修改对象是IRQ4的中断向量。
- 对82C59A两个命令的使用：在主程序中用命令OCW1屏蔽/开放IRQ4的中断请求；
  - 在服务程序中用OCW2发中断结束EOI，清除IRQ4在中断控制器内部ISR寄存器中置1的位。



#### 硬件设计

接口电路应能提供如下信号:

- ADC0809模拟量通道号选择信号
- 启动转换信号
- 读数据允许信号
- EOC的中断请求：直接连到系统总线的IRQ4上

<img src="media/image-20211201111722537.png" alt="image-20211201111722537" style="zoom:67%;" />

- 此处82C55A的4个端口地址：300H（A口）、301H（B口）、302H（C口）、303H（命令口）
- 对于A口，涉及到写通道地址和读转换结束的数据，所以A口的工作方式是输出输入交替工作, 8255需要被2次初始化

<img src="media/image-20211201111757487.png" alt="image-20211201111757487" style="zoom:67%;" />



<img src="media/image-20211201111807931.png" alt="image-20211201111807931" style="zoom:67%;" />



#### 通道7的数据采集相关程序段

```assembly
CODE SEGMENT 
 MOV DX, 303H   ; 82C55初始化
 MOV AL, 80H    ; 10000000B, 方式命令字, A口出, C口出
 OUT DX, AL     ; 书上有误, A口在地址选择时为输出, 在获取采样数据时为输入, 8255需要被两次初始化才行。
 
 MOV AL, 0EH  ; 置PC7=0, 使START和ALE无效
 OUT DX, AL
 
 MOV AL, 0CH  ; 置PC6=0, 使OE无效
 OUT DX, AL
 
 MOV AX, 350CH ; 获取IRQ4的中断向量并保存
 INT 21H
 
 MOV OLD_OFF, BX
 MOV BX, ES
 MOV OLD_SEG, BX
 
 CLI
 
 MOV AX, 250CH  ; 设置新中断向量
 MOV DX, SEG A_D
 MOV DS, DX
 MOV DX, OFFSET A_D
 INT 21H
 
 MOV AX, DATA  ; 恢复数据段
 MOV DS, AX
 
 STI                ; 开放中断请求
 
 IN AL, 21H   ; 开放IRQ4
 AND AL, 0EFH
 OUT 21H, AL
 
 MOV CX, 100   ; 设置采集字节数
 MOV AX, OFFSET BUFF ; 设置内存指针
 MOV PRT, AX
 MOV DX, 300H  ; 82C55A的A端口
 MOV AL, 07H         ; 选通道号
 OUT DX, AL
 
BEGIN： 
 MOV DX, 303H ; 启动转换
 MOV AL, 0FH  ; 产生START启动脉冲信号,置PC7=1
 OUT DX, AL
 
 NOP   ; 适当延时, 维持一定的脉宽
 NOP
 
 MOV AL, 0EH  ; 置PC7=0
 OUT DX, AL
 
 STI   ; 开中断
 HLT   ; 等待中断
 DEC CX  ; 采样次数减1
 JNZ BEGIN  ; 没完, 继续
 
 CLI   ; 已完, 关中断
 
 MOV AX, 250CH ; 恢复IRQ4的原中断向量
 MOV DX, OLD_SEG
 MOV DS, DX
 MOV DX, OLD_OFF
 INT 21H
 MOV AX, DATA ; 恢复数据段
 MOV DS, AX
 
 STI   ; 屏蔽中断请求
 
 IN AL, 21H
 OR AL, 10H  ; 屏蔽IRQ4
 OUT 21H, AL
 
 MOV AX, 4C00H ; 返回DOS
 INT 21H
 
 

; 中断服务程序
A_D PROC FAR  
 PUSH AX  ; 保护现场, 寄存器进栈
 PUSH   DX
 PUSH   DI
 
 CLI   ; 关中断
 
 MOV DX, 303H 
 MOV AL, 90H    ; 书上缺这一句：8255重新初始化, 0方式, A口入, C口出
 OUT DX, AL
 
 MOV DX, 303H ; 82C55A命令端口
 MOV AL, 0DH        ; 产生OE信号, 打开三态锁存器, 准备输出
 OUT DX, AL  ; 置PC6=1
 
 NOP   ; 适当延时, 维持一定的脉宽
 NOP
 
 MOV AL, 0CH 
 OUT DX, AL  ; 置PC6=0低
 
 MOV DX, 300H ; 82C55A的A端口
 IN AL, DX  ; 从PA口读数据
 
 NOP
 MOV DI, PRT
 MOV [DI], AL ; 存取数据
 INC DI  ; 内存地址指针加1
 MOV PRT, DI
 MOV AL, 20H        ; 发中断结束命令
 OUT 20H, AL
 
 POP DI  ; 恢复现场
 POP DX
 POP AX
 
 STI   ; 开中断
 
 IRET   ; 中断返回
A_D ENDP
ENDS
END START
```



## 13.  串行通信接口

### 基本概念

串行通信的特点：

- 1根线上按位传输，该线既作数据线又作联络线
- 数据传输的格式有固定要求，分为异步和同步
- 需要进行逻辑关系和逻辑电平的转换
- 要求双方约定传输的波特率、控制传输速率
- 串行通信易受干扰，需要进行差错检测与控制
- 适用于远、近距离传送（需要外加MODEM）



串行通信需要解决的问题：

- 怎么才能知道数据传输的开始和结束；
- 怎么判断接收到的数据的正确性；
- 如何进行传输速度控制；
- 如何进行电平和逻辑的转换；
- 如何进行通信双方的外部连接；
- 如何进行串/并转换。



### 串行通信的工作方式

#### 全双工（Full Duplex）

<img src="media/image-20211208112231976.png" alt="image-20211208112231976" style="zoom:50%;" />

全双工是通信双方同时进行发送和接收操作。数据的发送和接收分别由两根可以在两个不同的站点同时发送和接收的传输线进行传送，通信双方都能在同一时刻进行发送和接收操作，这种传送方式称为全双工制。全双工方式在通信过程中，无须进行接收/发送方向的切换，因此，没有切换操作所产生的时间延迟，有利于远程实时监测与控制。

特点：每一端都有发送器和接收器，有二条传送线

应用：交互式应用、电话、远程监测控制



#### 半双工（Half Duplex）

<img src="media/image-20211208113113945.png" alt="image-20211208113113945" style="zoom:50%;" />

半双工只设置1根传输线，是通信双方分时进行发送和接收操作，即双方都可发可收，但不能在同一时刻发送和接收。在半双工通信过程中，需要进行接收/发送方向的切换，会有延时产生。可用于对讲机、单向传送设备等。



#### 单工（Simplex）

<img src="media/image-20211208113335014.png" alt="image-20211208113335014" style="zoom:50%;" />

使用一个单向传输介质，一方只能接收，另一方只能发送，如图所示。

特点：发送方可以以广播方式传输数据到多个接收方

应用：电视台，广播站，卫星定位等。



### 串行通信中的差错检测

误码率：数据传输后发生错误的位数与总传输位数之比，一般要求在 10^-6^ 数量级

检错：发现传输中的错误，称为检错。

纠错：发现并消除传输中的错误，称为纠错。

可以使用奇偶校验检错、循环冗余码（CRC）检错，错误检测只在接收方通过软件方法进行



##### 奇校验（odd parity）

- 让传输的数据（包含校验位）中1的个数为奇数。
- 即：如果传输字节中1的个数是偶数，则校验位为“1”；
  如果传输字节中1的个数是奇数，则校验位为“0”；



##### 偶校验（even parity）

- 让传输的数据（包含校验位）中1的个数为偶数。
- 即：如果传输字节中1的个数是偶数，则校验位为“0”；
  如果传输字节中1的个数是奇数，则校验位为“1”；



#### 错误状态

一般存放在接口电路的状态寄存器中供CPU分析和处理。常见的错误有：

1. 奇偶校验错：接收到的数据中1的个数与奇偶校验位不符合。接收方可要求发送方重发
2. 溢出错：接收方没来得及处理收到的数据，发送方已经送来下一个数据，造成数据丢失
3. 帧格式错：接收到的数据与约定的格式不符
4. 查询方式的通信中有超时错，一般由于接口硬件电路速度跟不上产生



### 串行通信的同步方式

#### 接收方判断数据传输的开始

同步问题包括字符同步和位同步：

1. 字符同步：约定特定字符作为数据的开始
2. 位同步：接收器通过时钟信号接收每一位数据



#### 串行通信的基本方式

- **异步串行通信**
  - 以字符为单位传送。即：传送同一字符的每一位时是同步的，位与位之间有严格而精确的定时，而字符与字符之间是异步的，即发送端发出的每个字符在通信线上出现的时间是任意的。
  - 异步通信不要求在收双方之间使用同一根时钟线。
- **同步串行通信**
  - 以数据块为单位传送。字符内部位与位之间传送是同步的，字符与字符之间传送也是同步的。
  - 收/发两端必须使用同一时钟来控制数据块内部位与位之间的定时，因此同步通信要求双方之间必须设置一根时钟线。



通信双方采用调制解调器(MODEM)进行数字信号与模拟信号转换



### 传输速率控制

串行通信时，要求双方的传输速率严格一致，并在传输开始之前预先设定，否则会发生错误

在数字通信中，传输速率的控制是通过波特率时钟发生器和设置波特率因子或波特率除数来实现的



#### 波特率

每秒钟传送的二进制位数。用波特率表示：即1波特Baud=1b/s (位/秒，也可写为bps)

常用的标准波特率：110、150、300、600、1200等。



#### 发送和接收时钟

- 移位脉冲：执行数据的发送和接收
  - 发送时，发送端在发送时钟脉TxC的作用下，将发送寄存器的数据按位串行移位输出，送到通信线上；
  - 接收时，接收端在接收时钟脉冲RxC的作用下，对来自通信线上的串行数据，按位串行移入接收寄存器；
- 进行位同步



#### 波特率因子

发/收时钟的频率一般是波特率的整数倍。

这个倍数称为波特率因子或波特率系数Factor，发送/接收1位数据所需要的时钟脉冲个数，单位是个/位。

发/收时钟脉冲频率与波特率之间的关系是：$TXC = Baud × Factor$ 

例如：要求传送速率为1200 Baud，则
当Factor=1时， 发/收时钟=1200\*1=1.2kHz；
当Factor=16时，发/收时钟=1200\*16=19.2kHz；
当Factor=64时，发/收时钟=1200\*64=76.8kHz；



#### 波特率时钟发生器

不包含波特率时钟发生器的串行接口芯片需要自行设计波特率时钟发生器



#### 波特率时钟的使用

例1：甲乙两机进行串行通信。Factor=16个/位。第一次采用TXC1=38400Hz通信，第二次采用TXC2 = 19200Hz 通信。这两次通信的波特率各为多少？
答：Baud1=TXC1÷Factor=38400÷16=2400 b/s
Baud2=TXC2÷Factor=19200÷16=1200 b/s

例2：甲乙两机进行串行通信。甲机的TXC=38400Hz， Factor1=16个/位。乙机的Factor2=64个/位。双方的波特率要保持一致，乙机的RXC应为多少？
答：Baud=TXC÷Factor1=38400÷16=2400 b/s
RXC=Baud×Factor2=2400×64=153600 Hz



### 串行通信的数据格式

异步通信是以字符为单位进行传输的。

#### 起止式异步通信

起止式是在每个字符的前面加起始位，后面加停止位，中间可以加奇偶校验位，空闲位，形成一个完整的字符帧格式。每个字符帧由4个部分组成：

- 1位起始位，低电平，逻辑值0。
- 5～8位数据位，紧跟在起始位后，是要传输的有效信息。规定从低位至高位依次传输。
- 1位校验位（也可以没有校验位）。
- 1位，或1位半，或2位停止位，高电平（逻辑值1)。
  - 停止位后面是不定长度的空闲位。
  - 停止位和空闲位都规定为高电平，这样就保证起始位开始  处一定有一个下跳变。

<img src="media/image-20211222101447770.png" alt="image-20211222101447770" style="zoom:50%;" />

起/止位的作用：起始位和停止位是作为联络信号而附加进来的，当起始位由高电平变为低电平的下跳变时，告诉接收方数据的传输开始。它的到来，表示下面接着是数据位来了，要接收方准备开始接收。而停止位标志一个字符的结束，它的出现，表示一个字符传输结束。这样，就为通信双方提供了何时开始收发、何时结束的标志。



#### 面向字符的同步通信

同步通信一次传送若干个字符组成的数据块。并规定了10个特殊字符作为这个数据块的开头标志、结束标志以及整个传输过程的控制信息；

<img src="media/image-20211222101539219.png" alt="image-20211222101539219" style="zoom:50%;" />

- 单同步：指在传送数据之前先传送一个同步字符 `SYNC`；
- 双同步：先传送两个同步字符 `SYNC` ，接收端检测到该同步字符后开始接收数据。
- 外同步：通信的数据格式中没有同步字符，而是用一条专用控制线来传送同步字符，使接收方及发送端实现同步。当每一帧信息结束时均用两个字节的循环控制码CRC为结束。



### 通用同步/异步接收发送器 8251A 

<img src="media/image-20211222102052475.png" alt="image-20211222102052475" style="zoom: 67%;" />



外部特性：<img src="media/image-20211222102111444.png" alt="image-20211222102111444" style="zoom:67%;" />



## ※ 8251 命令字

- 方式命令：指定8251A的通信方式 (同步、异步)及其约定的数据帧格式。初始化时使用。

- 工作命令：指定8251A进行何种操作(发送、接收、内部复位、检测同步字符等)；
  设置某种工作状态，以便接收和发送数据。
- 状态字：报告8251A何时可发送和接收数据，以及接收的数据有无错误。



#### 方式字、命令字和状态字间的关系

- 方式字：约定双方通信的方式、数据格式、传送速率等参数。
- 命令字：控制是发送数据，还是接收数据。
- 状态字：何时发/收、取决于状态字。

使用的顺序：

- 因方式字和命令字无特征位，且送到同一个端口，所以要按一定的顺序写入。
  复位→方式字→命令字1→命令字2 ……



### 8251A方式命令

复位后写到命令端口的第一个字节；

<img src="media/image-20211222102358216.png" alt="image-20211222102358216" style="zoom:50%;" />



例1：在异步通信中，采用8位数据位，1位起始位，2位停止位，奇校验，波特率因数是16，则方式字是：
11011110B=0DEH 

```assembly
MOV  DX, 309H   ; 8251A命令口
MOV  AL, 0DEH   ; 异步工作方式字
OUT  DX, AL          
```

例2：同步通信中，若帧数据格式为：字符长度8位，双同步字符，内同步方式，奇校验，则方式字是：
00011100B=1CH 

```assembly
MOV  DX, 309H   ; 8251A命令口
MOV  AL, 1CH    ; 同步工作方式字
OUT  DX, AL 
```



### 8251 工作命令

8251A复位后写到命令端口的第二个字节；

<img src="media/image-20211222102733963.png" alt="image-20211222102733963" style="zoom:50%;" />



- EH位：让8251搜索同步字符，只在同步方式下用
- IR位：当工作命令字中的IR=1，则进行内部复位，使得8251可以重新设置方式命令字；如果无复位操作(包括reset复位)，则第一个方式命令字之后所有的命令字都是工作字！
- ER位置1时，状态寄存器中的3个错误标识位被清零；
- SBRK位：发送断缺字符位。设为1时，TxD线一直发送“0”信号。正常通信过程中该位应当保持为“0”。
- RTS位：请求发送位。CPU将其设为1时，8251A的RTS管脚有效，向Modem表示CPU已经做好发送数据的准备。
- DTR位：数据接收端准备好位。CPU将其设为1时，8251A的DTR管脚有效，向Modem表示CPU已经做好接收数据的准备。



例3：使8251A内部复位，并且允许接收，又允许发送，则程序段为：

```assembly
MOV  DX, 309H       ; 8251命令口
MOV  AL, 01000000B  ; 置D6=1, 使内部复位
OUT   DX, AL       
    ……
    …….      ;重新设置方式命令字; 
    …….
MOV  AL, 00000101B  ; 置D2=1, D0=1
                    ; 允许接收和发送
OUT   DX, AL 
```



### 状态字

8251A复位后从状态端口读到的状态字。CPU通过读出状态字进行分析和判断以决定下一步的操作。       

<img src="media/image-20211222103358637.png" alt="image-20211222103358637" style="zoom:50%;" />

- 只有TxRDY=1才能发送字符，RxRDY=1才能接收字符；

- 三个错误状态位：在编写接收程序时，要先对其进行检测，如果没有错误，再检查RxRDY是否准备好。如果有错误，则先处理错误。



例4：若查询8251A接收器是否准备好，即查RXRDY=1？则用下列程序段：

```assembly
L:
	MOV  DX, 309H    ; 状态口
	IN   AL, DX      ; 读状态字
	AND  AL, 02H     ; 查D1=1？（RXRDY=1?）
	JZ   L           ; 未准备好, 则等待
```



例5：检查出错信息，则用下列程序段

```assembly
MOV   DX, 309H  ; 状态口
IN    AL,  DX 
TEST  AL, 38H   ; 检查D5D4D3三位（FE, OE, PE）
JNZ   ERROR     ; 若其中有一位为1, 则出错
```



## 15. PCI 总线接口（未完成）

### PCI总线的特点

- 独立于微处理器 
- 传输速率高 
- 多总线共存 
- 支持突发传输 
  - PCI总线的基本传输是突发传输；
  - 单次传输要求每传输一个数据之前都要在总线上先给出数据的地址；
  - 而突发传输只要求在第一个数据传输之前将首地址发到总线上，然后每次只传送数据而地址是自动加1。这样就减少了地址的开销，加快了数据传输的速度。
- 支持即插即用 
  - 不需要用户做资源选择和配置，配置软件会自动扫描和识别新插入的设备，自动进行配置
- 支持多总线间并行操作 
- 支持总线主设备 
- 支持多达256个PCI总线 
- 支持三类地址空间访问 
  - PCI总线的访问支持存储器地址空间、I/O地址空间和配置地址空间三类地址空间，不同的地址空间有不同的总线读/写命令
- 总线信号较少 
  - 一个PCI目标设备只有47个引脚，主设备只有49个引脚



### PCI总线的信号定义

PCI总线标准信号线分成必需和可选两大类：

- 必需信号线：主设备有49条，目标设备有47条
- 可选信号线有51条：主要用于64位扩展、中断请求、高速缓存支持等。

功能：传输数据、地址，实现接口控制、仲裁及系统的功能

主设备：指取得了总线控制权的设备；
从设备（目标设备）：被主设备选中进行数据交换的设备。

下面的信号线输入/输出方向的定义是从PCI设备（包括主设备和从设备）的立场而言的。

<img src="media/image-20211222104515848.png" alt="image-20211222104515848" style="zoom:67%;" />

信号类型的符号含义如下:

- IN：单向标准输入信号。
- OUT：单向标准输出信号。
- T/S：双向三态输入/输出信号 for 双向总线
- S/T/S：持续的且低电平有效的三态信号for 控制信号。
  - 该信号一次只能由一个拥有着驱动。
- O/D：漏极开路，允许多个设备以线或形式共享该信号。 
- #：指明信号是低电平有效，即低电平激活该信号。

- **系统信号** 
  CLK IN：PCI总线时钟信号，为所有PCI传输提供时序，并且对于所有的PCI设备都是输入。
  RST# IN：复位信号。使PCI专用的寄存器、定序器和信号复位到初始状态。 

- **地址和数据信号** 
  AD[31∷00] T/S：地址和数据复用的输入/输出信号。
  C/BE#[03∷00] T/S：总线命令和字节允许复用信号。
  PAR T/S：奇偶校验信号，针对AD[31∷00]和C/BE#[03∷00] 进行奇偶校验，可被所有的PCI设备使用。

- **接口控制信号** 

  FRAME# S/T/S：帧周期信号，由当前主设备驱动，表示一次传输的开始和持续；

  - 先传地址，后传数据。在FRAME# 有效期间，数据传输继续进行；
    当FRAME# 无效时，预示总线传输结束，并在IRDY# 有效时进入最后一个数据期。

  IRDY# S/T/S：主设备准备好信号。
  TRDY# S/T/S：从设备准备好信号。

  - IRDY# 与TRDY# 联合使用，只有两者同时有效时，数据才能传输，否则进入等待周期。
    数据传输在时钟的上升沿进行。

  STOP# S/T/S：从设备要求主设备停止当前的数据传输的信号。
  LOCK# S/T/S：锁定信号，要求独占资源，以便进行可能需要的多次传输才能完成的操作。
  IDSEL IN：初始化设备选择信号。在参数配置读/写传输期间，用作片选信号。
  DEVSEL# S/T/S：设备选择信号，由被选的从设备发出。

  - 该信号有效时，说明总线上某处的某个设备已被选中，并作为当前访问的从设备。 

- **仲裁信号** 
  REQ# T/S：总线占用请求信号。该信号有效时，表明驱动它的设备要求使用总线。
  GNT# T/S：总线占用允许信号。该信号有效时，表明申请占用总线的设备的请求已获得批准。

- **中断信号** 

  PCI有4条中断线，它们是INTA#、INTB#、INTC#和INTD#。
  中断信号是电平触发，低电平有效，使用漏极开路方式驱动，此类信号的建立和撤销与时钟不同步。
  单功能设备只有一条中断线，并且只能使用INTA#，其它三条中断线没有意义。
  多功能设备（将几个独立的功能集中在一个设备中）最多可以使用4条中断线，且任何一个功能都可以连接到4个中断线中的之一。



### PCI总线命令

PCI总线命令不能由用户在自己的用户程序中使用，它是供系统对PCI总线进行操作时使用的。
PCI总线命令由获得总线控制权的主设备发出，确定主从设备之间进行数据传输的类型。
总线命令出现于地址期的C/BE#[03∷00]线上

<img src="media/image-20211222105627360.png" alt="image-20211222105627360" style="zoom:50%;" />



### 总线协议

第一阶段：多个主设备争用PCI总线控制权阶段

第二阶段：占据PCI总线控制权的主设备选择从设备的阶段：

第三阶段：主设备与从设备之间的数据传输阶段（重点）

一个杂项：设备中断



#### 多个主设备争用 PCI 总线控制权 

在有多个主设备争用同一PCI总线的情况下，PCI仲裁器采用集中式的同步仲裁方法

它的每个主设备有独立的请求(REQ＃)和允许(GNT＃)信号。这些信号线连到中央仲裁器上，如下图所示。

<img src="media/image-20211222110005651.png" alt="image-20211222110005651" style="zoom:50%;" />

仲裁器能够使用先到先服务的方法、循环优先法等，允许仲裁器根据不同的请求对象而设置优先权的灵活性。 它用简单的请求/允许握手信号允许对总线的访问。主设备使用它的REQ# 信号有效来请求占用总线，仲裁器若同意请求，则以GNT# 信号有效作为应答。







## 16. 通用串行总线 USB（未完成）


















































# 附录

这里放一些外部资料笔记或者暂时没法归类的内容：



## 补充资料：MASM 宏指令

来自：[宏指令(MASM)](https://www.cnblogs.com/alwaysking/p/12261894.html)

### 结构

  说明：

　　　　是一堆数据的定义的集合

  基本格式：

　　　　结构名称    STRUC

　　　　　　字段的定义

　　　　结构名称    ENDS

​    

　　　　举例：

　　　　STUDENT  STRUC

　　　　　　ID　　　　　 DW     ?

　　　　　　SCORE　　　DB     1

　　　　　　NAME　　　 DB     'STUDENTNAME'

　　　　STUDENT  ENDS

​    

  定义变量：

　　　　变量名     结构类型  < 参数表 >

​    

　　　　举例：  

　　　　　　S1   STDUENT    <1，50，'zhao'>

　　　　　　S2   STDUENT    <1，60，'zhang'>

　　　　　　S3   STDUENT    <1，70，'wang'>

​    

  结构使用：

　　　　1. MOV AX, P1.ID

​    

　　　　2. MOV BX, OFFSET P1

​    　　　MOV AL, [BX].SCORE

  总结：

　　　　使用起来还是和C/C++ 的结构比较类似的，实际上 P1.ID 和 [BX].SCORE 的两种引用方式本质上是汇编器帮我们转换了地址。

​    

### 记录

  说明：

　　　　结构是将将一堆定义结合起来，方便管理，那么记录就是讲一个字或者一个字节拆分成各种按照位的定义

　　　　实际上记录就是一个字或者字节的按位定义，所以长度最长不超过16位，右对齐。

​    

  基本格式：

　　　　记录名称    RECORD      字段1:位宽=初始值，字段2:位宽=初始值，….

​    

　　　　举例：

　　　　　　ABCD  RECORD   AA:5=12, BB:3=6, CC:4=3

​      

　　　　内存结构：

​      

　　　　　　15 14 13 12 11 10 9  8  7  6  5  4  3  2  1  0

　　　　　　0  0  0  0  aa aa aa aa aa bb bb bb cc cc cc cc

​    

  定义变量：

　　　　变量名     结构类型  < 参数表 >

​    

　　　　举例：  

​      　　S2   ABCD    <1，2，3>

​      　　S1   ABCD    <1，2，3>

​      　 S3   ABCD    <3，2，1>

​    

  记录使用：

　　　　**WIDTH**

　　　　　　返回一个记录整体的位宽或者一个字段的位宽

　　　　　　MOV AX, WIDTH ABCD

　　　　　　MOV AX, WIDTH AA

​    

​    

　　　　**MASK**

　　　　　　返回对应字段的掩码

　　　　　　MOV BX, MASK AA;    BX = 0001111100000000B

  

  总结：

　　　　和结构的功能有点类似，相当于在字节尺度尺度上的结构定义，相当于定义 标志位， 而MASK 就是提取标志位的掩码。

​    



### 宏定义

  说明：

　　　　宏定义的本质和C/C++ 一样就是字符替换，用定义的内容替换掉宏标识符

​    

  基本格式：

　　　　宏名称   MACRO   参数1，参数2，………

　　　　　　　　local   标号1， 标号2 ……

　　　　　　　　标号1： xxxxx

　　　　　　　　　　　　xxxxx

　　　　　　　　　　　　xxxxx

　　　　　　　　ENDM

​    举例：

　　　　　　M1  MACRO   OPR, X, Y

　　　　　　　　 LOCAL     P1, P2

　　　　　　　　 P1:     OPR  AX, BX

　　　　　　　　　　　　 MOV AX, X

　　　　　　　　　　　　 MOV BX, Y

 　　　　　　　　　　　　TEST  AX, BX

　　　　　　　　　　　　 JNZ  P1

　　　　　　　　　　　　 JMP P2

　　　　　　　　 P2:     MOV AX, BX

​        　　　 ENDM

​    

  宏的使用：

　　　　M1   MOV, 5, 1

　　　　这条指令会被展开如下结果大致上就是字符替换

​    

　　　　??0001:  MOV  AX, BX

​                MOV  AX, 5

​        　　　　 MOV  BX, 1

​        　　　　TEST  AX, BX

​        　　　　JNZ  ??0001

​        　　　　JMP  ??0002

　　　　??0002:  MOV AX, BX

​    

　　　　其中值得注意的是标号被替换成了 ??0001 ??0002  这是因为 宏如果在同一段代码里多次展开，标号也会跟着被多次展开，那么就会出现一段代码里同一个标号被多次定义，就会报错，所以如果在宏定义里面有标号定义，那么在 开头要使用 LOCAL 指令声明本地标号，这样汇编器会自动累加数字来代替标号

　　　　另外，使用的时候参数多传少传都可以，多传了就舍弃，少传了就默认用空代替，之后介绍的命令 IFB 可以判断参数是否为空

​    

#### 参数传递的说明:

　　**&**  　连接参数用的，应该与C中的用法差不多，通常用于字符拼接以及字符串中

　　　　　  定义：

　　　　　　　　JUMP  MACRO  CON,LAB

　　　　　　　　　　　 J&CON   LAB      ;; 这里就是将 字符 J 和 CON 的传入的内容拼接起来

　　　　　　　　　　    ENDM

　　　　　　使用：

　　　　　　　　JUMP   NZ, EXIT

　　　　　　展开为

　　　　　　　　JNZ EXIT

　　　　　　同理如果是定义在'' 字符串中页需要用& 表明是参数

　　　　　　定义：

　　　　　　　　MSG MACRO A,B

　　　　　　　　　　A  DB 'MR.&B'

　　　　　　　　　　ENDM

　　　　　　使用

​        　　 MSG  A1,HELLO

　　　　　　展开为

​        　　　A1   DB 'MR.HELLO'

​    

​    **<>** 字符串原样传递，如果字符串中报个各种字符，比如空格 特殊字符等，就用 <> 包起来，

​         汇编就会把他们统统当成一个完整字符串而不会去解析含义了 

​         比如  < 包含各种内  容的字符，串--//123!@#$%^ > 中间有逗号，如果不用<> 汇编器会以为是两个参数

​    

​    **!**  转义符号在上面的, 相当于c在字符串中的 \ , 这里比如 有一段字符串  1>2  ，如果用<> 包起来 就变成  <1>2>, 那就不对了，

​       汇编器会以为到1后边的> 就结束了，所以要用 <1!>2>, 用！来个后面的 > 转义.

​    

​    **%** 在参数传递的时候是可以传入表达式的, 用%() 包起来，就是告诉汇编器闯入的是表达式的值而不是标的是本身。

​       比如

　　　　　　定义：

　　　　　　　　MSG MACRO A,B

​          　　　　　　A  DB 'MR.&B'

​          　　　　　ENDM

　　　　　　使用

　　　　　　　　MSG  A1, 1+2

　　　　　　展开为

　　　　　　　　A1   DB 'MR.1+2'

​        

　　　　　　使用 

​        　　　　MSG  A1, %(1+2)

​        　展开为

​        　　　 A1   DB 'MR.3'



#### 其他说明：

　　　　**PURGE**  消除宏定义

　　　　　　比如前面定义了 宏 MSG, 那么在使用 PURGE MSG 之后的代码里，MSG这个宏就不能使用了，但是之前还是能使用的。

　　　　**EXITM**  终止宏的展开

　　　　　　这个伪指令用在宏定义里面，当宏展开的时候遇到这个命令就停止展开了，相当于阶段宏的内容。



总结：

　　　　宏的功能有点像子过程调用，但是由于它是在汇编阶段就展开的，没有像CALL 一样的压栈转跳等的开销，所以实际上他比CALL高效，实际上就有点像C++ 中的 INLINE 函数。

　　　　宏中可以使用宏，宏定义中页可以嵌套定义宏，但是嵌套定义的宏，需要使用一次宏才会生效，比如

　　　　　　DEF   MACRO  A

　　　　　　　　A  MACRO  

​                  push  ax

​              　　ENDM

​        　　　 ENDM

​      

　　　　如果不使用DEF宏定义，那么DEF宏定义不会被展开，那么根本就没有 A的宏定义，如果顺序是这样的

​    

　　　　　　DEF  DEF2

　　　　　　被展开为

　　　　　　DEF2 MACRO

　　　　　　　　　　PUSH AX

　　　　　　　　　ENDM

　　　　这个使用宏定义中的宏定义才被真正定义

　　　　之后才可以使用DEF2的宏定义

​    



### 重复汇编

  说明：

　　　　用途就是相当于写了个循环

　　　　如下场景

　　　　　　db   0

　　　　　　db   0

　　　　　　.

　　　　　　20 个这样的内容，目的是定义20个byte变量，或者说就是定义  BYTE  LIST[20]

　　　　　　.

　　　　　　db   0

　　　　　　db   0

　　　　　　那就可以用 重复汇编 宏指令了

​    

  基本格式：

　　**RPET**

　　　　**格式** 

　　　　　　REPT  NUM

　　　　　　　　　　XXXXXX

​                 ENDM

　　　　**说明**  

　　　　　　功能就是将里面的内容直接复制粘贴多少遍

　　　　**比如**

　　　　　　　　rept  5

　　　　　　　　　　db 0

　　　　　　　　endm

　　　　　　展开为

​           　db 0

​           　db 0

​           　db 0

​           　db 0

​          　　 db 0

 

　　　　　 可以用来定义数据  比如 BYTE LIST[20], 直接就是

　　　　　　　　rept 20

　　　　　　　　db 0

　　　　　　　　endm

​        

​    **IRP**

　　　　**格式**

　　　　　　IRP  待替换参数<参数表1,参数表2,参数表3,参数表4,参数表5,参数表6>

　　　　　　　　xxxxxxx

　　　　　　　　endm

​      **说明**

　　　　　　本质还是一样的，但是功能丰富了一点，在复制的时候，会逐一使用参数表内容替换待替换参数

​      **比如**

　　　　　　IRP  P1<1,2,3,4,5,6>

　　　　　　　　DB  P1

　　　　　　　　ENDM

　　　　　　展开为

　　　　　　　　DB 1

​           　　DB 2

​           　 DB 3

​           　 DB 4

​           　 DB 5

​           　 DB 6

​      

​    **IRPC**

​      **格式**

　　　　　　IRPC  待替换参数,字符串

　　　　　　　　　　xxxxxxx

　　　　　　　　endm

​      **说明**

　　　　　　其实和IRP 是一样的，就是用参数表逐一替换，不同的是给出这里给出的参数是字符串，这个伪指令会用字符串的字符来逐一代替

​      **比如**

　　　　　　IRP  P1 abcdef

　　　　　　　　DB  P1

　　　　　　　　ENDM

　　　　　　展开为

​           　DB 'a'

​           　DB 'b'

​           　DB 'c'

​           　DB 'd'

​           　DB 'e'

​           　DB 'f'

　总结：

​    这三个伪指令只要是在定义数据的时候使用的

  

### 条件汇编

  说明：

　　　　和C/C++ 中的

　　　　#Ifxxx 

　　　　#else 

　　　　#endfi 

　　　　是一样的东西

  基本格式：

　　　　IFXXX

　　　　ELSE

　　　　ENDIF

  IF/IFE

　　　　判断标的是的值，用法和LINUX SHELL中的用法蛮相似的

　　　　IF  (表达式)

　　　　　　表达式 ！= 0 的时候内容有效

　　　　ELSE

　　　　　　表达式 == 0 的时候内容有效

　　　　ENDIF

​    

　　　　 表达式的计算使用 https://www.cnblogs.com/alwaysking/p/7623781.html 中介绍的内容

  IFDEF/IFNDEF

　　　　和C/C++ 中的#ifdef 与#ifndef 意义完全相同

  IFB

　　　　用在宏定义中的，用于判断某个参数 是否为空的

　　　　比如

　　　　MSG MACRO A,B

　　　　　　ifb  <B>

　　　　　　　　A  DB 'MR.&B'

　　　　　　else

　　　　　　　　A   DB 'MR.UNKNOW'

　　　　　　endif

　　　　　ENDM

 

### INCLUDE

  说明

　　　　没错与C/C++ 中的含义一致，就是在INCLIDE 的位置直接将INCLUDE的文件的拼接(复制粘贴)进来

  用法

　　　　INCLUDE A.ASM

  说明

　　　　include后面可以跟路径，和C/C++ 一样，汇编器会首先在当前目录找，之后会在编译参数指定的寻找路径查找文件





## 补充资料：8086 汇编语言初学者教程

- 这部分内容来自 [8086汇编语言初学者教程](https://www.cnblogs.com/QuLory/archive/2012/11/07/2758048.html)；
- 用于 **快速入门** 编写汇编语言；

（目前不太确定这部分放在哪，因为在教师课件那里 **8086的指令系统** 安排太靠后，但在课件介绍具体功能前，就已经出现了很多指令，暂时先放在这）



### `MOV` 指令

- 功能：将第二个操作数（源）拷贝到第一个操作数（目的）指定位置；
- 源操作数可以是立即数，通用寄存器或者内存单元；
- 目的寄存器可以是通用寄存器或者内存单元；
- 源和目的必须是同样大小，要么都是字节要么都是字；



#### `MOV` 指令的操作类型

- **REG**：AX, BX, CX, DX, AH, AL, BL, BH, CH, CL, DH, DL, DI, SI, BP, SP；
- **memory**：[BX], [BX+SI+7], 变量等；
- **immediate**：5, -24, 3Fh, 10001101b 等；
- **SREG**：DS, ES, SS, 注意 **CS 只能作为操作源**（意思是 MOV CS, AX 会报错，MOV AX, CS 可以）；

```assembly
MOV REG, memory
MOV memory, REG
MOV REG, REG
MOV memory, immediate
MOV REG, immediate

; MOV 只支持如下段寄存器：
MOV SREG, memory
MOV memory, SREG
MOV REG, SREG
MOV SREG, REG
```



### 声明变量

编译器支持两种变量： **BYTE**（字节） 和 **WORD**（字）；

- name 可以是任何字母与数字构成，但是必须由字母开头；
- 可以通过不命名来声明一个没有名称的的变量（这个变量只有地址，没有名称）；
- value 可以是任何数值，支持三种进制（十六进制、二进制、十进制），可以使用 `?` 符号表示初始值没有确定；

```assembly
name DB value ; 名称 DB 值, DB = stays for Define Byte.
name DW value ; 名称 DW 值, DW = stays for Define Word.
```

例：（COM 文件）

```assembly
#MAKE_COM#
ORG 100h

MOV AL, var1
MOV BX, var2

RET    ; stops the program.

VAR1 DB 7
var2 DW 1234h
```



### 声明常量

常量同变量很相似，但是它一直存在。定义一个变量之后，它的值不会改变；

使用 `EQU` 语句定义常量；

格式：**name equ <任意表达式>**

```assembly
k EQU 5
MOV AX, k    ; 等价于 MOV AX, 5
```



### `ORG` 伪指令

`ORG` 是一个编译指令，它告诉编译器如何处理源代码；

`ORG 100` 通知编译器，可执行程序将被调入偏移量是 100h（256 字节）的位置，从而可以计算出所有变量的正确地址，然后用这些地址（偏移量）来代替变量名称；

- 这些指令不会真正的编译为任何机器代码，本身也不占内存空间；

- 可执行程序总是被装入偏移量 **100h**；

- EXE文件调入在偏移量 0000 的位置，它使用特定的段保存变量

#### `ORG` 的使用

- `ORG 100` 用在 COM 文件的开头；
- 还可以用于指明下一条汇编语句的偏移地址 ：


```assembly
SEG1    SEGMENT
        ORG   10         ; 设置$为10，此段目标代码从偏移地址10开始
        VAR1  DW  1234H  ; VAR1的偏移地址为10
        ORG   20         ; 在10和20地址之间是没有指令的
        VAR2  DW  5678H
        ORG   $+8        ; $增加8，即在5678H之后空出8个字节
        VAR3  DW  1357H
SEG1    ENDS

        ORG  100H
START:  ……
```



### 数组

- 数组可以看作是变量链，一个字符串本质是一个字节数组；
- 对于字符串，字符串是 byte 的数组，byte 是最小单位；
- 对于双字节整数，word 是最小单位



#### 定义数组

```assembly
a DB 48h, 65h, 6Ch, 6Ch, 6Fh, 00h
b DB 'Hello', 0
```



### `DUP` 指令：重复

- 格式：**number DUP ( value(s) )** 
- 其中 number 为重复的数量（任意常数），value 为将要复制的表达式

```assembly
c DB 5 DUP(9)    ; 等价于 c DB 9, 9, 9, 9, 9 
d DB 5 DUP(1, 2) ; 等价于 d DB 1, 2, 1, 2, 1, 2, 1, 2, 1, 2 
```



### `LEA` 指令或 `OFFSET` 指令：取得变量地址

```assembly
#MAKE_COM#
ORG 100h
  
MOV AL, VAR1
LEA BX, VAR1  			; 等效于 MOV BX, OFFSET VAR1  

RET    ; stops the program.
   
VAR1 DB 12H
```



### `INT` 指令：软件中断

中断是一系列功能调用。比如，在打印机上输出一个字符，只需要简单的调用中断，它将完成所有的事情；

这些功能调用称作软件中断；

需要使用 INT 指令触发一个软件中断；

格式：**INT value**

其中 value 的取值范围是从 0 到 255 （或者 0 到 0FFH），通常使用十六进制写法；

每一个中断都有子功能，在调用一个中断的子功能之前，需要设置  AH 寄存器（通常使用 AH）；


每一个中断最多可以拥有 256 个子功能（因此，总共可以有 256*256＝65536 个功能调用）；



例：使用中断 **0Eh** 子功能输出字符串 ‘Hello!' 

```assembly
#MAKE_COM# ; 生成com文件的指令

ORG 100h

MOV AH, 0Eh ; 选择子功能 int 10h/0Eh，输出放在 AL 寄存器中的 ASCII 码对应的字符

MOV AL, 'H' ; ASCII码: 72
INT 10h ; 输出

MOV AL, 'e' ; ASCII 码: 101
INT 10h ; 输出

MOV AL, 'l' ; ASCII 码: 108
INT 10h ; 输出

MOV AL, 'l' ; ASCII 码: 108
INT 10h ; 输出

MOV AL, 'o' ; ASCII 码: 111
INT 10h ; 输出

MOV AL, '!' ; ASCII 码: 33
INT 10h ; 输出

RET ; 返回操作系统
```



#### 中断功能表（全英文）

有些可能是 emu8086 模拟器或者 DOSBOX 不支持的，没全部测试，请以运行结果为准；

| 指令及其功能                                                 | 输入                                                         | 输出                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **INT 10h** / **AH = 00h** \- set video mode.                | **AL** = desired video mode.<br>**00h** - Text mode 40x25, 16 colors, 8 pages. |                                                              |
| **INT 10h** / **AH = 01h** - set text-mode cursor shape.     | **CH** = cursor start line (bits 0-4) and options (bits 5-7). <br>**CL** = bottom cursor line (bits 0-4).<br>When bits 6-5 of CH are set to **00**, the cursor is visible, to hide a cursor set these bits to **01** |                                                              |
| **INT 10h** / **AH = 02h** - set cursor position.            | **DH** = row.<br/>**DL** = column.<br/>**BH** = page number (0..7). |                                                              |
| **INT 10h** / **AH = 03h** - get cursor position and size.   | **BH** = page number.                                        | **DH** = row.<br/>**DL** = column.<br/>**CH** = cursor start line.<br/>**CL** = cursor bottom line. |
| **INT 10h** / **AH = 05h** - select active video page.       | **AL** = new page number (0..7).                             |                                                              |
| **INT 10h** / **AH = 06h** - scroll up window.<br/>**INT 10h** / **AH = 07h** - scroll down window. | **AL** = number of lines by which to scroll (00h = clear entire window).<br/>**BH** = [attribute](https://www.cnblogs.com/QuLory/archive/2012/11/07/2758054.html#attrib) used to write blank lines at bottom of window.<br/>**CH, CL** = row, column of window's upper left corner.<br/>**DH, DL** = row, column of window's lower right corner. |                                                              |
| **INT 10h** / **AH = 08h** - read character and [attribute](https://www.cnblogs.com/QuLory/archive/2012/11/07/2758054.html#attrib) at cursor position. | **BH** = page number.                                        | **AH** = [attribute](https://www.cnblogs.com/QuLory/archive/2012/11/07/2758054.html#attrib).<br/>**AL** = character. |
| **INT 10h** / **AH = 09h** - write character and [attribute](https://www.cnblogs.com/QuLory/archive/2012/11/07/2758054.html#attrib) at cursor position. | **AL** = character to display.<br/>**BH** = page number.<br/>**BL** = [attribute](https://www.cnblogs.com/QuLory/archive/2012/11/07/2758054.html#attrib).<br/>**CX** = number of times to write character. |                                                              |
| **INT 10h** / **AH = 0Ah** - write character only at cursor position. | **AL** = character to display.<br/>**BH** = page number.<br/>**CX** = number of times to write character. |                                                              |
| **INT 10h** / **AH = 0Eh** - teletype output.                | **AL** = character to write.<br>This functions displays a character on the screen, advancing the  cursor and scrolling the screen as necessary. <br>The printing is always  done to current active page. |                                                              |
| **INT 10h** / **AH = 13h** - write string.                   | **AL** = write mode:<br/>  **bit 0**: update cursor after writing;<br/>  **bit 1**: string contains [attributes](https://www.cnblogs.com/QuLory/archive/2012/11/07/2758054.html#attrib).<br/>**BH** = page number.<br/>**BL** = [attribute](https://www.cnblogs.com/QuLory/archive/2012/11/07/2758054.html#attrib) if string contains only characters (bit 1 of AL is zero).<br/>**CX** = number of characters in string (attributes are not counted).<br/>**DL,DH** = column, row at which to start writing.<br/>**ES:BP** points to string to be printed. |                                                              |
| **INT 10h** / **AX = 1003h** - toggle intensity/blinking.    | **BL** = write mode:<br/>  **0**: enable intensive colors.<br/>  **1**: enable blinking (not supported by emulator!).<br/>**BH** = 0 (to avoid problems on some adapters). |                                                              |
| **INT 11h** - get BIOS equipment list.                       | **AX** = BIOS equipment list word, actually this call returns the contents of the word at 0040h:0010h. |                                                              |
| **INT 12h** - get memory size.                               | **AX** = kilobytes of contiguous memory starting at  absolute address 00000h,	this call returns the contents of the word at  0040h:0013h. |                                                              |
| **INT 13h** / **AH = 00h** - reset disk system               | (currently this call doesn't do anything).                   |                                                              |
| **INT 13h** / **AH = 02h** - read disk sectors into memory.<br/>**INT 13h** / **AH = 03h** - write disk sectors. | **AL** = number of sectors to read/write (must be nonzero)<br/>**CH** = cylinder number (0..79).<br/>**CL** = sector number (1..18).<br/>**DH** = head number (0..1).<br/>**DL** = drive number (0..3 , depends on quantity of FLOPPY_? files).<br/>**ES:BX** points to data buffer. | **CF** set on error.<br/>**CF** clear if successful.<br/>**AH** = status (0 - if successful).<br/>**AL** = number of sectors transferred. |
| **INT 15h** / **AH = 86h** - BIOS wait function.             | **CX:DX** = interval in microseconds                         | **CF** clear if successful (wait interval elapsed),<br/>**CF** set on error or when wait function is already in progress. |
| **INT 16h** / **AH = 00h** - get keystroke from keyboard (no echo). |                                                              | **AH** = BIOS scan code.<br/>**AL** = ASCII character.<br>(if a keystroke is present, it is removed from the keyboard buffer). |
| **INT 16h** / **AH = 01h** - check for keystroke in keyboard buffer. |                                                              | **ZF = 1** if keystroke is not available.<br/>**ZF = 0** if keystroke available.<br/>**AH** = BIOS scan code.<br/>**AL** = ASCII character.<br/>(if a keystroke is present, it is not removed from the keyboard buffer). |
| **INT 19h** - system reboot.                                 |                                                              |                                                              |
| **INT 1Ah** / **AH = 00h** - get system time.                |                                                              | **CX:DX** = number of clock ticks since midnight.<br/>**AL** = midnight counter, advanced each time midnight passes. |
| **INT 20h** - exit to operating system.                      |                                                              |                                                              |
| **INT 21h** / **AH=09h** - output of a string at DS:DX.      | **DS:DX** = 要输出的字符串<br>例：MOV DX, OFFSET MSG<br/>MOV AH, 09H<br/>INT 21H<br/>RET<br/>MSG DB "HELLO$" |                                                              |
| **INT 21h** / **AH=0Ah** - input of a string to DS:DX, fist byte is buffer size, second byte is number of chars actually read. | （待补充，使用时能弹出输入框，但没观测到 DS:DX 和其他寄存器有什么变化，可能是调用方式不对……） |                                                              |
| **INT 21h** / **AH=4Ch** - exit to operating system.         |                                                              |                                                              |
| **INT 21h** / **AH=01h** - read character from standard input, with echo, result is stored in AL. |                                                              | **AL** = 读入字母的 ascii 值                                 |
| **INT 21h** / **AH=02h** - write character to standard output. | **DL** = 要输出的字符                                        | 运行后 **AL** = DL                                           |



#### 颜色表

字符属性为 8 位值，低 4 位设置前景色，高 4 位设置背景色；

但是，不支持背景色闪烁；

```assembly
HEX    BIN       COLOR
-----------------------
0      0000      black
1      0001      blue
2      0010      green
3      0011      cyan
4      0100      red
5      0101      magenta
6      0110      brown
7      0111      light gray
8      1000      dark gray
9      1001      light blue
A      1010      light green
B      1011      light cyan
C      1100      light red
D      1101      light magenta
E      1110      yellow
F      1111      white
```



例：emu8086 中 1_sample.asm 的闪烁 Hello World!

```assembly
; color all characters:
mov cx, 12  ; number of characters.
mov di, 03h ; start from byte after 'h'

c:  mov [di], 11101100b   ; light red(1100) on yellow(1110)
    add di, 2 ; skip over next ascii code in vga memory.
    loop c
```



### 常用函数库 `emu8086.inc`

编译器会自动在你源程序所在的文件夹中查找你引用的文件，如果没有找到，它将搜索 `Inc` 文件夹；

使用 **emu8086.inc** 头文件需要在程序开头加上：

```assembly
include 'emu8086.inc'
```

**emu8086.inc** 定义了一些方便的输入输出宏：

```assembly
PUTC char ; 将一个ascii字符输出到光标当前位值，只有一个参数的宏

GOTOXY col, row ; 设置当前光标位置，有两个参数

PRINT string ; 输出字符串，一个参数

PRINTN string ; 输出字符串，一个参数。与 PRINT 功能相同，不同在于输出之后自动回车

CURSOROFF ; 关闭文本光标

CURSORON ; 打开文本光标

PRINT_STRING ; 在当前光标位置输出一个字符串字符串地址；由DS:SI 寄存器给出；使用时，需要在 END 前面声明 DEFINE_PRINT_STRING

PTHIS ; 在当前光标位置输出一个字符串（同 PRINT_STRING一样，不同之处在于它是从堆栈接收字符串。字符串终止符应在 call 之后定义；例如:
CALL PTHIS;  
db 'Hello World!', 0
; 使用时，需要在 END 前面声明 DEFINE_PTHIS  

GET_STRING ; 从用户输入得到一个字符串，输入的字符串写入 DS:DI 指出的缓冲，缓冲区的大小由 DX 设置；回车作为输入结束；使用时，需要在 END 前面声明 DEFINE_GET_STRING 

CLEAR_SCREEN ; 清屏过程(滚过整个屏幕)，然后将光标设置在左上角。使用时，需要在 END 前面声明DEFINE_CLEAR_SCREEN
　
SCAN_NUM ; 取得用户从键盘输入的多位有符号数，并将输入存放在 CX 寄存器；使用时，需要在 END 前面声明 DEFINE_SCAN_NUM

PRINT_NUM ; 输出 AX 寄存器中的有符号数；使用时，需要在 END 前面声明 DEFINE_PRINT_NUM以及 DEFINE_PRINT_NUM_UNS.

PRINT_NUM_UNS ; 输出 AX 寄存器中的无符号数；使用时，需要在 END 前面声明 DEFINE_PRINT_NUM_UNS.
```

使用例：

```assembly
include 'emu8086.inc'

ORG 100h

LEA SI, msg1 ; 要求输入数字
CALL print_string ;
CALL scan_num ; 读取数字放入 cx

MOV AX, CX ; CX 存放数值拷贝到 AX

; 输入如下字符
CALL pthis
DB 13, 10, 'You have entered: ', 0

CALL print_num ; 输出 AX 中的字符

RET ; 返回操作系统

msg1 DB 'Enter the number: ', 0

DEFINE_SCAN_NUM      ; 使用这些宏需要添加的
DEFINE_PRINT_STRING
DEFINE_PRINT_NUM
DEFINE_PRINT_NUM_UNS 
DEFINE_PTHIS

END ; 结束
```



### MASM debug 常用命令

- #### r 命令：查看或者改变CPU寄存器的内容

  - 查看寄存器：r
  - 改变某个寄存器内容：`r 寄存器`（如：ax），之后按下 Enter 出现 `:` ，再输入值



- #### d 命令：查看某段内存内容

  - 查看内存内容：`d 段地址:偏移地址` （结束的偏移地址，可忽略）
  - 注意：直接使用 d 命令，显示的是 debug 预设地址处的内容



- #### e 命令：改变内存内容

  - 改变内存内容：`e 段地址:偏移地址` 写入的数据
  - 也可以通过 `e 段地址:偏移地址 "字符串"`    这种方式向内存中写入字符串的 16 进制值



- #### u 命令：将机器指令翻译成汇编指令

  - 机器指令翻译成汇编指令：`u 段地址:偏移地址`
  - 注意：如果直接使用命令 u，debug 会把 CPU 中 CS:IP 指向的内存内容翻译成汇编指令



- #### t 命令：让 cpu 执行 CS:IP 指向的指令



- #### a 命令：以汇编指令的格式在内存中写入机器指令

  - 写入汇编指令：`a 段地址:偏移地址`，按下 enter 键后，输入汇编指令，当不想输入时直接按 enter 退出输入

  

- #### q 命令：退出 debug 

  

