# 汇编与接口技术笔记

期末考试开卷、50% + 平时成绩20% + 常规实验15% + 研究性实验15%

地点：**YF312** 或九教 4 层实验室

- #### 这份笔记画 ※ 的都要背！

- #### 做实验 **<u>需要在上机前就编写完程序</u>** ！！




## 汇编部分的网络参考资料

[8086汇编语言初学者教程](https://www.cnblogs.com/QuLory/archive/2012/11/07/2758048.html) （点击 [#补充资料8086-汇编语言初学者教程](https://github.com/Sayaka-4987/Notes_for_BJTU_Finals/blob/main/21-Fall-%E6%B1%87%E7%BC%96%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0.md#%E8%A1%A5%E5%85%85%E8%B5%84%E6%96%998086-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%88%9D%E5%AD%A6%E8%80%85%E6%95%99%E7%A8%8B) 可以跳转到本笔记的这一部分）



## 1. 基础知识

### 1.2 硬件接口

~~（这段抄的 zll 的，后面还一段也是，不想打字惹）~~

CPU与接口交换数据的方式：

1. **查询方式**

信息交换的控制完全由主机执行程序实现，程序查询方式接口中设置一个数据缓冲寄存器（数据端口）和一个设备状态寄存器（状态顿口）；

主机进行 I/O 操作时，先发出询问信号，读取设备的状态，并根据设备状态决定下一步操作究竟是进行数据传送还是等待。在这种控制方式下，CPU 一旦启动 I/O，就必须停止现行程序的运行，并在现行程序中插入一段程序；

CPU 要花费很多时间来查询和等待，而且在一段时间内只能与一台外设交换信息，效率低；

2. **中断方式**

CPU在程序中安排好于某个时刻启动某台外设，然后CPU继续执行原来的程序，不需要像查询方式一样一直等待外设准备就绪；

一旦外设完成数据传送的准备工作，就主动向CPU发出中断请求，请求CPU为自己服务；在可以响应中断的条件下，CPU暂时中止正在执行的程序，转去执行中断服务程序为外设服务，在终端服务程序中完成一次主机与外设之间的数据传送，传送完成后，CPU返回原来的程序；

3. **DMA 方式**

主存和 DMA 接口之间有一条直接的数据通路；

DMA 方式传送数据不需要经过CPU，因此不必中断现行程序，I/O与主机并行工作，程序和传送并行工作。



## 2. 80x86 计算机组织

本课程以 16 位的 8086 作为教学对象；



### 2.1 计算机系统

微处理器就是把 **运算器、寄存器组、控制器** 集成在一个超大规模集成电路芯片上的功能部件；

存储器是微机存放和记忆程序、数据的部件，分为内存和外存；

外设可以分为两部分，一类是直接为计算机运行服务的，如键盘、鼠标；另外一类是暂时不影响计算机的外设，如打印机，显示器；

系统总线包括数据总线（传送数据）、地址总线（指出数据来源或目的地）、控制总线（传送 CPU 对存储器或 I/O 设备的控制命令，和 I/O 设备对 CPU 的请求服务信号），总线工作由系统总线控制模块指挥；



### 2.2 8086 微处理器

8086 的基本性能指标：

1. 16位微处理器；
2. 16根数据线、20根地址线，可寻址的地址空间达 1MB (220Byte＝1MB)；
3. 可以和浮点运算器、I/O 处理器或其他处理器组成多处理器系统，提高系统的数据吞吐能力、处理能力

<img src=".\media\微信截图_20210908104652.webp" style="zoom:33%;" />

通用寄存器包括 8 个 16 位寄存器：AX、BX、CX、DX、SP、BP、SI 和 DI；
标志寄存器为 FLAGS ，是一个 16 位的寄存器；

总线接口部件：负责管理与系统总线的接口，负责对存储器和外设访问；包括指令队列、指令指针、段寄存器、地址加法器和总线控制逻辑；

指令执行部件：包括 ALU 、通用寄存器、标志寄存器和控制电路；负责指令译码、数据运算和指令执行；

指令执行的两个主要阶段：取指和执行，其中取指：从主存取出指令代码进入指令队列，执行：译码指令、并发出有关控制信号实现指令功能；

8086 处理器的指令读取实质是 **指令预取**：8086 处理器维护着长度为 6 个字节的指令队列；EU 单元译码、执行指令，同时 BIU 单元读取后续指令，BIU 和 EU 两个单元相互独立，可以并行操作；



#### ※ 8086 CPU 寄存器分组表

<img src=".\media\8086寄存器.webp" style="zoom:67%;" />

以 [ BX+SI ] 为例：BX 为基址、SI 为变址；

##### 数据寄存器 AX,  BX, CX, DX

- 数据寄存器用来保存 **操作数或运算结果** 等；

  - AX 是累加器，用于算术、逻辑运算以及外设传送信息等；
  - BX 是基址寄存器，常用于存放存储器地址；
  - CX 是计数器，作为循环或串操作等指令中的隐含计数器；
  - DX 是数据寄存器，用来存放双字数据的高16位或存放外设端口地址；

- 以 AX 为例，它对应的 AH, AL 指的是 AX 的高位和低位；

  

##### 指针寄存器 SP, BP 

- 指针寄存器和变址寄存器用于存放 **某个存储单元的偏移地址**；

  - SP 用于存放当前堆栈中栈顶的偏移地址；

  - BP 用于存放堆栈段中某一存储单元的偏移地址；

    

##### 变址寄存器 SI, DI

- 在串操作中， SI 和 DI 都具有自动增量或减量的功能，它的目的操作数和源操作数都在连续空间；

  - SI 用于存源地址（操作完其值不改变）；
  - DI 用于存目的地址，操作完其值发生改变；



##### 控制寄存器 IP, FLAGS 

- 2 个控制寄存器

  - IP 指令指针寄存器保存下一次将要取出指令的偏移地址，IP 的内容由微处理器硬件自动设置，不能用指令直接修改，有一些指令可以改变 IP 的值，如转移指令、子程序调用指令等；
  - FLAGS 标志寄存器包含 9 个标志位，保存一条指令执行后，CPU 所处状态信息及运算结果的特征；

  

##### 段寄存器 CS, DS, SS, ES 

- 段寄存器用来确定 **该段在内存中的起始地址**，8086 有 4 个 16 位的段寄存器

  - 代码段 CS 主要存放运行的程序
  - 数据段 DS 存放运行程序所用的数据
  - 堆栈段 SS 定义了堆栈的所在区域
  - 附加段 ES 是附加的数据段，它是辅助数据区，在串操作指令中，用到的目的串必定存放在附加段中

  

#### 通用寄存器的专门用途

<img src=".\media\通用寄存器的专门用途.webp" style="zoom: 33%;" />



#### 堆栈的两种访问方式

1. 随机访问方式：用 BP 寄存器来指示随机访问地址；

2. 先进后出访问方式：用 SP 寄存器来表示栈顶；



#### ※ 标志寄存器的格式及各位的含义

<img src=".\media\标志寄存器的格式及各位的含义.webp" style="zoom:50%;" />

##### 进位标志 CF（Carry Flag）

当 **无符号整数** 加减运算的最高有效位有进位（加法）或借位（减法）时，CF＝1，否则 CF＝0；



##### 零标志 ZF（Zero Flag）

若运算结果为 0，则 ZF＝1，否则 ZF＝0；



##### 奇偶标志 PF（Parity Flag）

当运算结果的 **最低字节**（注：就是看最后 8 位，1 个字节 Byte 是 8 位 bit，8 位的结果看全部 8 位，16 位的结果看后 8 位）中， 1 的个数为零或偶数时，PF＝1；否则 PF＝0；



##### 辅助进位标志 AF（Auxiliary Carry Flag）

当运算结果的 **最低字节** （同 PF）低位的一半向高位（看最后 8 位的低 4 位向高 4 位）有进位或借位时，AF = 1；

该标志与操作数长度无关，只看最低字节中间那两位就行；



##### 符号标志 SF（Sign Flag）

若运算结果最高位为 1，则 SF＝1，否则 SF＝0；



##### 溢出标志 OF（Overflow Flag）

当 **有符号整数** 加减结果有溢出，则 OF＝1，否则 OF＝0；

> 对于程序员，无符号数关心进位，有符号数关心溢出，相同符号数相加后符号相反（如正+正=负），则有溢出；
>
> 对于处理器硬件判断，最高位和次高位同时进位或不进位，则无溢出；反之则有溢出；



##### 方向标志 DF（Direction Flag）

仅用于串操作指令，控制地址的变化方向：

1. 设置 DF＝0，每次串操作后的存储器地址就自动增加，即从低地址向高地址处理数据串；
2. 设置 DF＝1，每次串操作后的存储器地址就自动减少，即从高地址向低地址处理数据串；
3. 可以执行 CLD 指令设置 DF＝0；执行 STD 指令设置 DF＝1 ；



##### 中断允许标志 IF（Interrupt-enable Flag）

主要针对外中断中可屏蔽中断的开放或禁止：

1. 当 IF=1 时，CPU 允许响应可屏蔽中断，中断当前程序，转去执行中断处理程序；
2. 当 IF＝0 时，则不允许响应可屏蔽中断；
3. 可以执行 STI 指令设置 IF = 1；执行 CLI 指令设置 IF = 0；



##### 追踪标志 TF（Trace Flag）

用于单步调试程序：

1. 当 TF=1 时，在执行完一条指令后，产生单步中断；这在DEBUG调试程序状态下，可以使指令单步运行，可逐一检查各寄存器内容，标志状态、存储器的检查或修改等等；
2. 追踪标志 TF=1 时为调试程序时所用，当程序调试成功后让 TF=0，CPU正常工作不产生单步中断；



### 2.3 存储器地址

#### 存储器的组织：8086 实模式

采用分段方式，20 位的物理地址 由 **16 位的段地址** 和 **16 位的偏移地址** 形成，每个段的最大寻址空间为 64KB；

段地址必须是 16 的倍数，即（二进制写法）末尾 4 位必须为 0；



#### 存储单元的内容

课件记为存储地址加括号”( )” ，编程时用 []；

X 单元中存放着 Y，而 Y 是另一个存储单元的地址，则 Y 单元的内容表示为 (Y) = ((X))；

字单元由**两个字节单元**组成，其地址采用它的低地址来表示；

字存入存储器：低位字节存入低地址单元，高位字节存入高地址单元；



#### 储存单元地址例题

<img src=".\media\储存单元地址例题.webp" alt="image-20210908121210248" style="zoom:50%;" />



#### 储存器的分段

8086 的内部寄存器是 16 位，地址是 20 位，地址宽度大于字长，显然不能用16位的寄存器仅一次操作实现对 2^20^＝1M 字节单元的寻址；

- 20 根地址线，地址范围 00000H ~ FFFFFH （1MB）
- 机器字长 16 位，仅能表示地址范围  0000H ~ FFFFH（64KB)
- 物理地址：每一个存储单元有一个唯一的 20 位地址



为此引入存储器“分段”的概念，即把 1M 字节内存空间，分成最大 64KB 的段，每段可用 16 位寄存器进行寻址；



段地址：表示一个段的开始，段地址一般存在段寄存器；

偏移地址：在段内相对于段起始地址的偏移值；

逻辑地址：**段地址：偏移地址**



<img src=".\media\储存器的逻辑地址与物理地址.webp" style="zoom:38%;" />



物理地址：每一个存储单元有一个唯一的 20 位地址，表示范围：00000H～FFFFFH；

物理地址形成：**段地址左移 4 位，再加上偏移地址值**；

<img src=".\media\物理地址的形成.webp" style="zoom:38%;" />



- 逻辑地址的形式：指令操作数，指令间的相对地址
- 物理地址：MEM 的绝对地址
- 逻辑地址到物理地址的转换过程因 CPU 架构的不同而不同



##### 例：8086 逻辑地址与物理地址的转换

<img src=".\media\逻辑地址与物理地址的转换.webp" style="zoom:38%;" />



> 这里左移的 4 位是二进制位；如果用十六进制表达地址就是左移一位；
>
> 左移 4 位还可以表达为乘以 16，即：**物理地址 = 段地址 × 16D + 偏移地址** （或 = 段地址 × 10H + 偏移地址）



例：设某操作数存放在数据段，DS = 250AH，数据所在单元的偏移地址 = 0204H；则该操作数所在单元的物理地址为（    ）；

解：此类题目会设坑，给出一堆寄存器，答题需要先找**哪个是段地址**，需要注意偏移地址和段基址对应关系；本题提示了操作数存放在数据段，所以 DS 就是段地址，得物理地址 = **252A4H**；



<img src=".\media\段寄存器分配.webp" style="zoom:38%;" />



#### 偏移地址的组成

16 位有效地址：

- EA＝基址寄存器＋变址寄存器＋位移量
  - 基址寄存器：BX 或 BP，**一般由基址寄存器决定哪个段寄存器作为段指针**
  - 变址寄存器：SI 或 DI
  - 位移量：8 或 16 位有符号值（可正可负）





## ※ 8086 缺省 16 位段 + 偏移寻址组合表

注意：当 BX/BP 与 SI/DI 组合作为偏移地址时，默认的段寄存器是 BX/BP 所在段的寄存器，而不是 SI/DI 所在段的寄存器；

一般程序中 **只给出偏移地址**，因此需要背这张表的默认对应关系，记 **偏移寄存器 -> 段寄存器** 方向；

| 段寄存器  | 偏移寄存器            | 主要用途   |
| --------- | --------------------- | ---------- |
| CS 代码段 | IP                    | 指令寻址   |
| DS 数据段 | BX, DI, SI 或 16 位数 | 数据寻址   |
| SS 堆栈段 | SP 或 BP              | 堆栈寻址   |
| ES 附加段 | DI                    | 目标串寻址 |



## 3. 寻址方式

操作数寻址：获取操作数

指令寻址：控制指令跳转

### 3.1 操作数寻址

#### 8086 汇编指令格式

指令 = 操作码 + 操作数；

<img src=".\media\8086汇编指令格式.webp" style="zoom:38%;" />

寻址方式：为取得操作数或指令地址所使用的方法

操作数寻址：与数据有关的寻址方式

指令寻址：与转移地址有关的寻址方式  

指令寻址分为顺序寻址（IP 一条指令接一条指令地顺序进行移动）和跳转寻址（下条指令的地址码不是由程序计数器给出，而是由本条指令给出）



#### 3 种数据寻址方式

这 3 种寻址方式没有 “物理地址” 的概念；

AX 中一定是 16 位数，AL 中一定是 8 位数；

##### 立即数寻址

例：**MOV AX, 1100H**

<img src=".\media\立即数寻址.webp" style="zoom:38%;" />

- 操作数直接存在 **指令** 中，即 **立即数**（Immediate），用常量形式直接表达；
- 因此操作数存储在 **代码段（CS）**中；
- 注意：
  - 源操作数和目的操作数的 **字长必须一致**；例如 **MOV  AH, 3064H** 就是非法的；
  - 只能用于源操作数；



##### 寄存器寻址

例：**MOV  AX,  BX**

- 操作数在 CPU 的 **内部寄存器** 中；
- 不需要访问存储器，速度快；
- 注意：
  - 源操作数和目的操作数的 **字长必须一致**；例如 **MOV  AH (16 位), BX (8 位)** 是非法的；
  - 代码段寄存器 CS 不能用 MOV 指令改变（其他段寄存器都允许重新分配）；



##### 存储器寻址

- 存储器寻址共有 5 种寻址方式（见后文）
- 操作数在 **存储器** 中，用存储单元的地址表示；
- 编程时使用包含 **段寄存器** 和 **偏移地址** 的逻辑地址（一般只给出偏移地址）；
- 段寄存器指示段的 **基地址**；
- 偏移地址由各种寻址方式计算，常被称为 **有效地址 EA**（Effective Address）；
- 一般情况下存储器地址由有效地址表示，段寄存器不用显式说明，数据在默认的段中；如果不使用默认段寄存器，则要用 **段超越指令前缀** 加以说明；



#### 段寄存器的默认和超越

| 访问存储器的方式   | 默认      | 偏移地址    | 可超越             |
| ------------------ | --------- | ----------- | ------------------ |
| 取指令             | 代码段 CS | IP          | 无                 |
| 堆栈操作           | 堆栈段 SS | SP          | 无                 |
| 一般数据访问       | 数据段 DS | 有效地址 EA | CS, ES, SS, FS, GS |
| BP 基址的寻址方式  | 堆栈段 SS | 有效地址 EA | CS, ES, SS, FS, GS |
| 串操作的源操作数   | 数据段 DS | SI          | CS, ES, SS, FS, GS |
| 串操作的目的操作数 | 附加段 ES | DI          | 无                 |



#### 5 种存储器寻址方式

做题注意一下哪边是高地址，哪边是低地址；

##### 直接寻址

例：**MOV CX，[2000H]**

- 指令中直接包含了操作数的有效地址 EA，在指令操作码之后；
- 默认段地址在DS寄存器中，即操作数的实际地址（物理地址）是 DS:EA ；
- 常用于存取变量；



##### 寄存器间接寻址

例： **MOV AX，[SI]**

- 操作数的有效地址 EA 存放在基址寄存器 BX 或变址寄存器 SI, DI 中，**不能放在 AX / CX / DX 中**；
- 操作数的段地址（数据处于哪个段）取决于 **选择哪一个间址寄存器**；
- 可以方便地对数组的元素或字符串的字符进行操作；
- 寄存器间接寻址没有说明存储单元类型；



##### 寄存器相对寻址

例： **MOV BX，NUM+[DI]** 

- 有效地址 EA 是 **寄存器内容与位移量之和**；
- 适用于数组、字符串、表格的操作；

<img src=".\media\寄存器相对寻址.webp" style="zoom:38%;" />



例：计算寄存器相对寻址的有效地址

<img src=".\media\寄存器相对寻址例题.webp" style="zoom:38%;" />



##### 基址变址寻址

例：**MOV AX，\[BX][SI]**

- 有效地址是基址寄存器和变址寄存器之和
- 适用于二维数组、字符串、表格的操作
- 必须是一个基址寄存器和一个变址寄存器的组合
  - **MOV  AX,  \[BX][BP]**    非法，这是两个基址寄存器
  - **MOV  AX,  \[SI][DI]**      非法，这是两个变址寄存器

<img src=".\media\基址变址寻址.webp" style="zoom:48%;" />



##### 相对基址变址寻址

例：**MOV AX，MASK\[BX][SI]**

也可以写成 **MOV AX, [BX+SI+MASK]** 

或 **MOV AX, MASK[BX+SI]**

- 有效地址计算如下：

<img src=".\media\相对基址变址寻址.webp" style="zoom:38%;" />



例：计算相对基址变址寻址的有效地址

<img src=".\media\相对基址变址寻址例题.webp" style="zoom:38%;" />



#### 操作数寻址（共 7 种）总结

1. 立即数寻址                **MOV  AX , 3069H**
2. 寄存器寻址                **MOV  AL , BH**
3. 直接寻址                    **MOV  AX , [2000H]**
4. 寄存器间接寻址         **MOV  AX , [BX]** 
5. 寄存器相对寻址         **MOV  AX , NUM [ SI ]** 
6. 基址变址寻址             **MOV  AX , \[BP][DI]**
7. 相对基址变址寻址      **MOV  AX , MASK \[BX][SI]**



#### 未解决的疑问（更新解答）

2021/9/13：老师说下次课讲

2021/9/16：讲了，但没完全讲.jpg

作业题：假设（DS）= 2000H，（ES）= 2100H，（SS）= 1500H，（SI）= 00A0H，（BX）= 0100H，（BP）= 0010H，数据段中的变量名VAL的 **偏移地址值** 为 0050H；试指出下列源操作数的寻址方式是什么？其物理地址值是什么？（8）MOV  AX，VAL

（这里先放一下 lys 大佬和老师的说法：）

<img src=".\media\image-20210913193654164.webp" alt="image-20210913193654164" style="zoom:33%;" />

<img src=".\media\image-20210913193830411.webp" alt="image-20210913193830411" style="zoom:33%;" />

老师的解释：

MOV AX, VAL 等价于 MOV AX, [VAL]，是一个直接寻址，变量的名字就代表变量的偏移地址；



### 3.2 指令寻址

#### 段内直接寻址

例： 

**JMP  NEAR PTR  NEXT**    近转移    <u>-32768 ~ +32767</u>，汇编时，位移量为16位

**JMP  SHORT  NEXT**          短转移    <u>-128 ~ +127</u>，汇编时，位移量为8位

- 段内寻址 CS 不变，只改变 IP；
- 直接体现地址信息，需要进行一个转换；
- 转向的有效地址 = 当前 (IP) + 位移量 (8bit/16bit) ，其中位移量是 **转向的有效地址与当前 IP 值之差**；



#### 段内间接寻址

<img src=".\media\段内间接寻址.webp" style="zoom:48%;" />

- 段内寻址 CS 不变，只改变 IP；
- PTR 是强制类型转换；
- 转向的有效地址是一个寄存器或存储单元的内容；
- 可用除立即数以外的任何一种数据寻址方式得到；



#### 段间寻址

例：

**JMP  1234H:5678H**                        ;  (CS) = 1234H ，(IP) = 5678H

**JMP dword ptr 内存地址单元**      ;  (CS) = (内存地址单元+2) ，(IP) = (内存地址单元) 

- 段间寻址，既改变 IP 也改变 CS 转向的有效地址是 XXXX:YYYY 形式

- 一般仅供操作系统（OS）使用

  

### 3.3 伪指令

汇编语言语句分为 **指令** 和 **伪指令** 两种类型：

| 指令性语句                                                   | 指示性语句（伪指令语句）                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 能够被直接翻译成机器码，并让CPU直接执行的语句；<br>每一条指令语句对应一条可执行的CPU机器指令，执行产生相应的CPU动作；<br>有操作码和操作数两个部分； | 指导汇编程序如何编译汇编语言源程序，并不翻译成机器代码，CPU也不执行；<br>通常完成储存模式定义、数据定义、存储器分配、指示程序开始结束等功能；<br>可以提高编程效率，指导编译器如何编译汇编程序； |

<img src=".\media\汇编语言语句类型.webp" style="zoom:75%;" />



#### 汇编语言语句格式 

名字定义满足的规则：

1. 数字不能作为第一个字符；
2. 单独的问号（?）不能作为名字；
3. 最大有效长度为 31；
4. 保留字不能作为名字使用；

<img src=".\media\汇编语言语句格式.webp" style="zoom: 25%;" />



##### 操作码

- 含义：指明操作的性质或功能；
- 书写规则：操作码与操作数之间用空格分开；



##### 操作数

- 含义：指定参与操作的数据或者地址表达式；
- 个数：一般指令，1个或2个，也可以没有；伪指令和宏指令可以有多个；
- 书写规则：操作数多于1个时，操作数之间用逗号分开



#### 段定义伪操作 `SEGMENT`、`ENDS`

- 程序由4个逻辑段组成：数据段、堆栈段、附加段和代码段；

- 每个逻辑段以 `SEGMENT` 语句开始，以 `ENDS` 语句结束；

  

##### 段定义的格式

```assembly
段名  SEGMENT  [定位类型]  [组合类型]  [使用类型]  [‘类别’]	; 方括号这几项一般采取默认设置，缺省：
          ……
          ……            ; 语句序列
段名  ENDS
```

例：

```assembly
DATA   SEGMENT         ; 定义数据段
       …
DATA   ENDS
;----------------------------------------
EXTRA  SEGMENT         ; 定义附加段
       …
EXTRA  ENDS
;----------------------------------------
CODE   SEGMENT         ; 定义代码段
       ASSUME CS:CODE, DS:DATA, ES:EXTRA
START: 
       MOV   AX, DATA
       MOV   DS, AX    ; 段地址 -> 段寄存器
       …
CODE   ENDS
       END   START
```



#### 指定段地址伪指令 `ASSUME`

- 伪指令的格式：**ASSUME <段寄存器名>:<段名>[,<段寄存器名>:<段名>…]**
- 功能：建立段寄存器与段的缺省关系；
- 注意：ASSUME 伪指令 **是给程序员看的**，并不为段寄存器设定初值，没有真正建立关联；



**例： assume cs:code, ds:data, es:extra**

其中：code 是代码段的段名，data 是数据段的段名，extra 是扩展段的段名



#### 设置段地址值 

- 在代码段开始处进行 DS, SS, ES 的段地址装填；
- DS, SS, ES 默认指向 PSP（默认分 256 字节），CS 默认指向 PSP 完成段后的地址；

<img src=".\media\设置段地址值.webp" style="zoom:38%;" />

* 8086 **不支持将数据直接送入段寄存器** ，DATA 是地址常量，只能通过 AX 中继一下才能进入 DS 
* MOV 也不能在段寄存器之间直接赋值；



#### 程序结束伪操作 `END`

- 格式：**END  [ label ]**

例：

```assembly
code   segment           ; 定义代码段
       assume cs:code, ds:data, es:extra
start: 
       mov   ax, data
       mov   ds, ax      ; 段地址 -> 段寄存器
       …
code   ends
       end   start
```



#### 数据定义及存储器分配伪操作 `DB`、`DW`、`DD`、`DQ`、`DT`

- 格式：**[变量] 助记符 操作数 \[,操作数,…] \[;注释]** 

- 助记符：**DB, DW, DD, DQ (8字节), DT (10字节)** 

  - DB： 定义字节
  - DW：定义字
  - DD： 定义双字

  

<img src=".\media\数据定义以及储存器分配伪操作.webp" style="zoom:48%;" />

例：

```assembly
DATA_BYTE  DB  10,4,10H,?            
DATA_WORD  DW  100,100H,-5,? 	; -5 按补码存储
```

<img src=".\media\数据定义例.webp" style="zoom:38%;" />

这里 **DB 2 DUP (0,2 DUP(1,2),3) = 2 DUP（0, 1, 2, 1, 2, 3）= （0, 1, 2, 1, 2, 3, 0, 1, 2, 1, 2, 3）**

<img src=".\media\数据定义例2.webp" style="zoom:38%;" />



##### 操作数

<img src=".\media\操作数.webp" style="zoom: 50%;" />

**MOV AL, OPER2**  和 **MOV AL, [OPER2]** 是等价的；  

<img src=".\media\操作数和类型匹配.webp" style="zoom:38%;" />



#### 表达式赋值伪操作 `EQU`

- 相当于给表达式起一个别名，碰到别名就替换成表达式；
- 格式：表达式名 EQU 表达式
- 同一个程序中 `=` 可以对一个符号重复定义，但 EQU 不能对同一个符号重复定义
- 注意：EQU 指令不占用内存空间；

```assembly
BUF1 DW 1,2,3
INTT EQU 5
BUF2 DW 4,5,6       ; 3和4的地址是连续的
```



#### 解除定义伪指令 `PURGE`

- 格式：PURGE <符号1，符号2，…，符号n>
- 功能：解除指定符号的定义



#### 地址计数器与对准伪操作 `$`

- 常用于确定数组中元素的个数

```assembly
BUF1 DB 1，2，3，4，5
CNT1 EQU $-BUF1              ;（常用）
BUF2 DW 1，2，3，4，5
CNT2 EQU ($-BUF2)/2          ;（/2后等于数组元素个数）
```

- 在代码段，\$ 表示当前正在汇编的指令的地址；

```assembly
ORG   $+8       ;  跳过8个字节的存储区
JNE   $+6       ;  转向地址是 JNE 的地址 +6
JMP   $+2       ;  转向下一条指令
```

- 在数据段，\$ 表示当前地址计数器的值；

```assembly
ARRAY DW 1, 2 , $+4 , 3 , 4 , $+4
```

结果如图：

<img src=".\media\地址计数器内存图.webp" style="zoom:38%;" />



#### 表达式操作符

在指令中出现，主要是对常量进行运算:

| 运算符类型 | 运算符及说明                                            |
| ---------- | ------------------------------------------------------- |
| 算术运算符 | + 、－、*、 /、MOD（取余数）                            |
| 逻辑运算符 | AND（与）、OR（或）、XOR（异或）、NOT（非）             |
| 位移运算符 | SHL（逻辑左移）、SHR（逻辑右移）                        |
| 关系运算符 | EQ（=）、NE（!=）、GT（>）、LT（<）、GE（>=）、LE（<=） |



##### 算术运算符：`+` 、`-`、`*`、 `/`、`MOD` 

```assembly
VIDEO_BUF  DB  25*80*2  DUP(?)
ARRAY   DW   1,2,3,4,5,6,7
ARYEND  DW   ?
MOV  CX, (ARYEND-ARRAY)/2	; 赋值
BLOCK DB  1，2，3

MOV  AL, BLOCK+2   ; 符号地址 ± 常数有意义，等价于  MOV  AL, [BLOCK+2] 
```



##### 逻辑和移位操作符： `AND`、`OR`、`XOR`、`NOT`、`SHL`、`SHR` 

```assembly
OPR1  EQU  25    ; 00011001B
OPR2  EQU  7     ; 00000111B

AND  AX, OPR1 AND OPR2     ; AND AX,1

MOV  AX,  0FFFFH SHL 2     ; MOV AX,0FFFCH
```



##### 关系操作符： `EQ`、`NE`、`GT`、`LT`、`GE`、`LE`

```assembly
MOV FID, (OFFSET Y - OFFSET X) LE 128
; 若 <= 128  (真)   汇编结果：  MOV  FID, -1
; 若 >  128  (假)   汇编结果：  MOV  FID, 0
```



##### 数值回送操作符： `OFFSET`、`SEG`、`LENGTH`、`SIZE`

- **OFFSET /  SEG**      变量 / 标号
  - 功能：回送变量或标号的偏址 / 段址
  - 如 **MOV DX, SEG FUNC** 或  **MOV AX, OFFSET LNAME**



- **LENGTH**   变量
  - 功能：回送由 **<u>DUP 定义的变量</u>** 的 **单元数**，其它情况 **回送 1**；



- **SIZE**   变量
  - 功能：返回配送给由 **<u>DUP 定义的变量</u>** 的 **字节数**，其它情况 **回送 1**；
  - **SIZE** 操作等价于 **LENGTH * TYPE        ;DB的TYPE值为1，DW的TYPE值为2**



例：

```assembly
ARRAY   DW   100 DUP (?)
TABLE   DB   ‘ABCD’

MOV  CX,  LENGTH  ARRAY   ;  MOV  CX, 100
MOV  CX,  LENGTH  TABLE   ;  MOV  CX, 1
MOV  CX,  SIZE    ARRAY   ;  MOV  CX, 200
MOV  CX,  SIZE    TABLE   ;  MOV  CX, 1
```



##### 属性修改的伪指令： `PTR`

- **BYTE PTR** 表示字节，**WORD PTR**  表示字（2个字节）
  - 例：**BYTE PTR [BX]       ; 按字节访问 BX**
  - ​        **WORD PTR [BX]    ; 按字访问 BX** 
- 格式： 新属性 PTR （旧属性的）表达式
- 功能：用于 **暂时改变** 内存变量或标号的原有属性，但 **不能修改寄存器的原有属性**（寄存器属性是固定的）；
- 方式：与其它汇编指令配合使用，不能独立使用

例：**MOV  AX, WORD PTR [BX]**

应用场合：

```assembly
; 1. 有一些指令中，操作数或表达式的属性是不明显的，需要加以明确。
CALL DWORD PTR [BX]    ; 远调用
CALL BYTE PTR  [BX]    ; 段内近调用

; 2. 需要修改操作数或表达式的属性的。
F1 DW 1234H
MOV AL，BYTE PTR F1   ; AL=34H
F2 DB 23H，56H，18H
MOV BX，WORD PTR F2   ; BX=5623H
```



##### 定位类型的伪指令： `PARA`

- `PARA` 是定位类型之一；
- 功能：PARA (Paragraph，节) 表明 **该段起始地址对齐到 para** ，供 OS 使用
- 一般各个逻辑段的首地址在“节”的整数边界上（每 16 个存储单元叫做一节, 1 para = 16 Bytes），即每个逻辑段的起始地址是 16 的整数倍，或地址的最低 4 位为 0

例： **code segment para 'code'**

（完全没看明白，但还是先记下了）



#### 汇编语言程序格式

- 一个汇编源程序一般应该由 3 个逻辑段组成，即数据段、堆栈段、代码段；
- 每个逻辑段以 **SEGMENT** 语句开始，以 **ENDS** 语句结束。整个源程序以 **END** 语句结束；
  - 数据段用来在内存中建立一个适当容量的工作区，以存放常数、变量等操作数据；
  - 堆栈段用来在内存中建立一个适当的堆栈区，以便在中断、子程序调用时使用；
  - 代码段包括了许多以符号表示的指令，其内容就是程序要执行的指令；

例：求字存储单元中两个数之差，存入下一个相邻字单元

<img src=".\media\用段定义伪指令.webp" style="zoom:38%;" />





#### 程序段前缀结构 FAR 

把整个程序定义成一个 FAR 型过程（或子程序），该过程能够让其它汇编文件中的段来调用，而 near 则不能。 

##### 过程定义伪指令：`PROC`、`ENDP`

格式：

```assembly
NAME  PROC  [TYPE]
; ... 
NAME  ENDP
```

例：

<img src=".\media\程序段前缀结构FAR.webp" style="zoom:38%;" />

##### 代码段中程序结束的两种方式

```assembly
INT 21H ; DOS 中断调用

RET     ; 过程结束
```



#### 汇编语言程序的上机过程

汇编程序的主要功能：

- 检查源程序，给出出错信息
- 产生目标文件 (.obj) 和列表文件 (.lst) 
- 展开宏指令

<img src=".\media\汇编程序运行步骤以及生成的文件.webp" style="zoom:38%;" />



## 4. 8086 的指令系统

（这部分为啥在伪指令后面？？？）

主要可以分为：

- 数据传送指令
- 算术指令
- 逻辑指令
- 串处理指令
- 控制转移指令
- 处理机控制指令
- 杂项操作指令

需要记忆：指令的基本功能、支持的寻址方式、执行前后标志位的影响、指令的特殊要求



### 传送指令：`MOV` 

**MOV DST, SRC**       ; 执行操作：**(DST)   ←  (SRC)**

- **寄存器 REG**：AX, BX, CX, DX, AH, AL, BL, BH, CH, CL, DH, DL, DI, SI, BP, SP；
- **段寄存器 SREG**：DS, ES, SS, 注意 **CS 只能作为操作源**（意思是 MOV CS, AX 会报错，MOV AX, CS 可以）；
- **存储器 memory**：[BX], [BX+SI+7], 变量等；
- **立即数 immediate**：5, -24, 3Fh, 10001101b 等；
- 注意事项：
  - 不允许使用 AX、CX、DX 存放 EA； 
  - CS 和 IP 寄存器的修改只能使用 JMP XX:YY 指令进行修改，不能用 MOV 指令修改。通常来说，CS 都是由 OS 分配的，应用程序不能对其进行修改；
  - DST、SRC 的类型要匹配，因此不能同时为存储器寻址。因为两者的位宽是否匹配不能确定；
  - MOV 只允许下方代码块中允许的移动：

```assembly
; MOV 支持的寄存器操作：
MOV REG, memory
MOV REG, REG
MOV REG, immediate
MOV memory, REG
MOV memory, immediate

; MOV 只支持如下段寄存器操作：
MOV SREG, memory
MOV memory, SREG
MOV REG, SREG
MOV SREG, REG
```

总结：

<img src=".\media\MOV小结.webp" style="zoom: 50%;" />



### 堆栈操作指令：`PUSH`、`POP` 

- 堆栈是 **后进先出**（LIFO）的存储区；
- 栈顶是低位地址，SP 指向栈顶；
- 段地址存放在 SS 中，堆栈指针 SP 在任何时候都指向栈顶，进出栈后自动修改 SP；   
- 堆栈用于 **保存子程序返回地址和断点地址** 以及 **主程序通用寄存器内容的保护和恢复** ；
- 因为 LIFO，所以在保存和恢复寄存器的内容时，要 **按照相反的顺序** 执行一组压入和弹出指令；
- 注意：
  - 堆栈操作必须以字为单位
  - 不影响标志位
  - 不能用立即寻址方式（不能压栈一个立即数），例：**PUSH  1234H      ; 非法**
  - DST 不能是 CS ，CS 只能用 JMP 指令间接修改，例：**POP  CS      ; 非法**
  - 没有明确的寄存器表示栈底，除非程序人为定义了 SS 段使用自定义的堆栈；
  - BP 可以寻址堆栈中任何一个位置；

指令格式：

```assembly
进栈指令：PUSH  SRC
执行操作：
(SP) ←  (SP) – 2        ; 栈顶指针 SP 上移，所以是 - ；堆栈以字（2个字节）为单位，所以 -2
((SP+1), (SP)) ←  (SRC)

出栈指令：POP  DST
执行操作：
(DST) ←  ((SP+1), (SP))
(SP) ←  (SP) + 2        ; 栈顶指针 SP 下移，
```



### 数据交换指令：`XCHG` 

- 格式：**XCHG  OPR1，OPR2**
- 功能： (OPR1)  <-->  (OPR2) 交换值
- 注意： 
  - 不影响标志位
  - 不允许使用段寄存器，两个操作数必须有一个在寄存器中（内存之间不能相互传送数据，因为不知位宽是否匹配）

 例：

```assembly
BX=6F30H，BP=0200H，SI=0046H，AX=2105H
SS=2F00H，(2F246H)=4154H 
XCHG  BX，[BP+SI]     ; (BX) = 4154H, [SS*10H +BP+SI] = 6F30H
XCHG  AL，BH          ; (AL) = 41H, BH = 05H 
```



### I/O数据传送指令：`IN`、`OUT`

- 功能：用于外部设备 I/O 端口与 CPU 之间的信息交换；
- IN/OUT 指令中 AX（AL）操作数的位置是不同的，一个是目标操作数位置，另一个是源操作数位置；
- IN/OUT 指令操作期间，端口地址处将产生一个负脉冲信号；
- 只能使用 AX 或 AL 来存放数据，只限 **8 位立即数** 或 **DX** 来存放端口号；
  - 该操作不影响标志位
  - 前 256 个端口号（00H~FFH）可直接在指令中指定（长格式）
  - 如果端口号大于等于 256，端口号就只能存在 DX 中（短格式）

输入指令：

```assembly
; I/O端口直接寻址方式(直接用 8 位的立即数)
; 长格式：
IN   AL, PORT         （字节）
IN   AX, PORT         （字）
; 执行操作：
(AL) ← (PORT)   	  （字节）
(AX) ← ((PORT+1),(PORT)) （字）

; I/O端口间接寻址方式(超过 256 位的时候只能间接寻址)
; 短格式：   
IN   AL, DX   	  （字节）
IN   AX, DX   	  （字）
; 执行操作：
(AL) ← (DX)     	  （字节）
(AX) ← ((DX+1),(DX)) （字）     
```



输出指令：

```assembly
; I/O端口直接寻址方式(直接用 8 位的立即数)
; 长格式： 
OUT   PORT, AL  （字节）
OUT   PORT, AX  （字）
; 执行操作：
(PORT) ← (AL)      （字节）
((PORT+1),(PORT)) ← (AX)（字）

; I/O端口间接寻址方式(超过 256 位的时候只能间接寻址)
; 短格式：   
OUT   DX, AL  	（字节）
OUT   DX, AX  	（字）
; 执行操作： 
(DX) ← (AL)    （字节）
((DX+1),(DX)) ← (AX)（字）
```



例：

```assembly
IN   AL, 28H    ; 将端口28H中的字节数据读出送AL
OUT  28H, AL    ; 将AL的数据写入28H中

MOV  DX, 03FCH  ; 将端口03FCH送DX
IN   AL, DX     ; 将端口03FCH中字节数读出送AL
OUT  DX, AL     ; 将AL中数据写入端口03FCH中

; TEST 指令测试某状态寄存器（端口号27H）的第2位是否为1
IN     AL, 27H
TEST   AL, 00000100B
JNZ    ERROR          ; 若第2位为1，转ERROR处理
```



### 换码/查表指令：`XLAT` 或 `XLAT  OPR`

这两个指令默认了操作数，执行操作：**(AL）←  ( BX + AL )**

功能：AL 给出偏移量，然后存储该偏移地址处的内容

注意：
*  不影响标志位
*  字节表格（长度不超过256）首地址存在 BX
*  需转换的位移量存在 AL

```assembly
; 例：
MOV BX, OFFSET TABLE   ; BX=0040H
MOV  AL, 3
XLAT  TABLE ; 指令执行后：(AL)=33H
```

<img src=".\media\换码查表指令内存示意图.webp" style="zoom:48%;" />



### 地址传送指令：`LEA`、`LDS`、`LES`



- ##### 有效地址送寄存器指令：LEA  REG, SRC

  - 执行操作： **(REG) ← SRC**
  - 功能：将源操作数的有效地址 EA 传送到目标寄存器
  - 注意：
    - **SRC** 不能是立即寻址或寄存器寻址，**必须为存储器寻址方式**；
    - **REG 不能是段寄存器；**



- ##### 指针送寄存器和 DS 指令：LDS  REG, SRC

  - 执行操作：**(REG) ← (SRC) ,  (DS) ← (SRC+2)**
  - 功能：将源操作数中存放的地址指针 ”段基址: 偏移地址” 的低 16 位送入目标寄存器，高 16 位送入 DS 段寄存器



- ##### 指针送寄存器和 ES 指令：LES  REG, SRC

  - 执行操作：**(REG)  ←  (SRC)，(ES)  ←  (SRC+2)**
  - 功能：将源操作数中存放的地址指针”段基址: 偏移地址”的低 16 位送入目标寄存器，高 16 位送入 ES 段寄存器

例：

<img src=".\media\地址传送指令例.webp" style="zoom:38%;" />

判断题：

① LEA    BX,  [2728H]      ; (BX)=2728H  

② MOV   BX,  [2728H]     ; (BX)=DS段内2728H处一个字的内容

③ MOV   BX,  2728H        ; (BX)=2728H

④ LDS    BX,  [2728H]      ; (BX)=DS段内2728H处一个字的内容

⑤ LEA    BX,  2728H         ×

⑥ LDS    BX,  2728H        ×

⑦ LES    BX,  2728H         ×

⑧ LEA    BX,  SI                 ×

⑨ LDS    BX,  SI                 ×

⑩ LES    BX,  SI                  ×



### 标志寄存器传送指令：`LAHF` 、`SAHF` 、`PUSHF`、`POPF` 

**FLAGS** 为 16 位标志寄存器，低字节指 FLAGS 的 **低 8 位**；

这里的操作都影响标志位；



- ##### 标志送 AH 指令：`LAHF`

  - 功能：读取标志位低字节，把标志寄存器中的 SF、ZF、AF、PF、CF 五个标志传至 AH 的第 7、6、4、2、0 位，第 5、3、1 位未定义；
  - 执行操作：(AH) ← (FLAGS 的低字节)

  <img src=".\media\LAHF指令.webp" style="zoom:38%;" />

  

  

- ##### AH 送标志寄存器指令：`SAHF`

  - 功能：写入标志位低字节
  - 执行操作：**（FLAGS 的低字节） ←  (AH)**

  

- ##### 标志进栈指令：`PUSHF` （FLAGS 的高和低两字节） 

  - 功能：读取标志位的 2 个字节内容到堆栈中；
  - 执行操作：**(SP)  ←  (SP) – 2 ，((SP)+1，(SP))  ←  (FLAGS)**

  

- ##### 标志出栈指令：`POPF` （FLAGS 的高和低两字节） 

  - 功能：写入堆栈的 2 个字节内容到标志位中；
  - 执行操作：**(FLAGS)  ←  ((SP)+1, (SP))，(SP)  ←  (SP) + 2**



### 加法指令：`ADD`、`ADC`、`INC`



- ##### 加法指令：ADD  DST, SRC
  
  - 执行操作：**(DST) ← (SRC) + (DST)**
  



- ##### 带进位加法指令：ADC  DST, SRC
  
  - 执行操作：**(DST) ← (SRC) + (DST) + CF**
  



- ##### 加 1 指令：INC  OPR 
  
  - 执行操作：**(OPR) ← (OPR) + 1**



注意：  

   * `INC` 指令不影响 CF 标志（硬件结构决定的），对其它条件标志位都有影响；

   * 汇编器不会区分有符号数还是无符号数，它会统一当作有符号的，并全部编译成补码形式进行运算；

   * 如果要将一个加法解释成无符号数加法，那么就只使用 CF，否则就需要使用 OF；

   * OF = 1 说明运算结果已经错误，应该中止运算；

   * CF 与 OF 不在同一解释中同时使用；

     

> 8086 指令中专门提供了一条 **[溢出中断指令 `INTO`](https://github.com/Sayaka-4987/Notes_for_BJTU_Finals/blob/main/21-Fall-%E6%B1%87%E7%BC%96%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0.md#%E4%B8%AD%E6%96%AD%E4%B8%8E%E4%B8%AD%E6%96%AD%E8%BF%94%E5%9B%9E%E6%8C%87%E4%BB%A4intintoiret)**，用来判断有符号数加减运算是否有溢出；
>
> 该命令常用于算术运算中，若算术运算（它的上一条指令）的结果产生溢出，即 OF=1 ，则立即调用一个处理算术溢出的中断服务程序；否则不进行任何操作，接着执行下一条指令；



例：双精度数的加法，分别加低位和高位

DX = 0002H，AX = 0F365H （16 进制表示中，最高位是字母时，前面要补 0）

BX = 0005H，CX = 8100H

指令序列：

```assembly
ADD  AX, CX    ; (1) 执行后，(AX) = 7465H，CF=1，OF=1
ADC  DX, BX    ; (2) 执行后，(DX) = 0008H，CF=0，OF=0
```



### 减法指令：`SUB`、`SBB`、`DEC`、`NEG`

- ##### 减法指令：SUB  DST, SRC

  - 执行操作： **(DST) ←  (DST) – (SRC)**



- ##### 带借位减法指令：SBB  DST, SRC

  - 执行操作： **(DST) ←  (DST) – (SRC) – CF**



- ##### 减 1 指令：DEC  OPR 

  - 执行操作： **(OPR)  ←  (OPR) – 1**



- ##### 求补指令：NEG  OPR 

  - 执行操作：**(OPR) ←  – (OPR)**
  - 功能：将操作数按位求反后末位加1，因而操作也可以表示为（OPR）←  0FFFFH（补码的 -1） –  (OPR) + 1（也可以写成 0 -  (OPR) 
  - 例：如果 (CL) = 100，执行 NEG CL 后 (CL)=1001 1100B，是 -100 的补码；如果(CL) = –8，执行 NEG CL 后 (CL)=0000 1000B，是 8 的补码
  - 

### 比较指令 `CMP`

- ##### 格式： CMP  OPR1, OPR2 

  - 执行操作： **(OPR1) – (OPR2)**
  - 功能：该指令与 SUB 指令一样执行减法操作，但它不保存结果，只根据结果 **设置条件标志位**；
  - CMP 指令后一般跟随条件转移指令，根据比较结果产生不同的程序分支；
  - 说明：OPRT1 和 OPRT2 可以是寄存器或存储器，但**不能同时为存储器**（否则位宽不能保证），OPRT2 还可以为立即数



注意：

* `DEC` 指令不影响 CF 标志（硬件结构决定的），对其它条件标志位都有影响；
* 有符号减法下 CF 没有意义，无符号数减法下 OF 没有意义；
* `CMP` 指令执行后对标志位的影响：
  * 对于有符号数，SF 异或 OF 等于 1 时是小于，

<img src=".\media\CMP指令执行后对标志位的影响.webp" style="zoom:38%;" />



### 乘法指令：`MUL`、`IMUL`  



- ##### 无符号数乘法指令：**MUL    SRC**

- ##### 带符号数乘法指令：**IMUL   SRC**

- 执行操作：

  - 字节操作数      **(AX) ← (AL) * (SRC)**
  - 字操作数    **(DX,AX) ← (AX) * (SRC)**

- 注意：
  *  AL (AX) 为隐含的乘数寄存器；
  *  AX (DX,AX) 为隐含的乘积寄存器；
  *  SRC 不能为立即数，因为位宽不详；
  *  除 CF 和 OF 外，对条件标志位无定义；

<img src=".\media\乘法指令对CF和OF的影响.webp" style="zoom:38%;" />

<img src=".\media\乘法指令对CF和OF的影响2.webp" style="zoom: 25%;" />



### 除法指令：`DIV`、`IDIV`



### 十进制调整指令：`DAA`、`DAS`、`AAA`、`AAS`、`AAM`、`AAD`



### 逻辑运算指令：`AND`、`OR`、`NOT`、`XOR`、`TEST` 



- ##### 逻辑非指令：**NOT  OPR**  

- 执行操作： **(OPR) ←  ¬ (OPR)**    

  

- ##### 逻辑与指令：**AND  DST, SRC**

- 执行操作： **(DST) ← (DST) ∧ (SRC)**



- ##### 逻辑或指令：**OR  DST, SRC**

- 执行操作： **(DST) ← (DST) ∨ (SRC)**



- ##### 异或指令：  **XOR  DST, SRC**

- 执行操作： **(DST) ← (DST) ⊕ (SRC)**



- ##### 测试指令：  **TEST  OPR1, OPR2**

- 执行操作： **(OPR1) ∧ (OPR2)**

- 注意：

  - OPR 不能为立即数
  - 不影响标志位 



例：

<img src=".\media\逻辑运算使用例.webp" style="zoom:38%;" />



### 移位指令：`SHL`、`SHR`、`SAL`、`SAR`、`ROL`、`ROR`、`RCL`、`RCR`

注意：

*  OPR 可用 **除立即数以外** 的任何寻址方式 
*  条件标志位：
     *  CF = 移入的数值
     *  OF=1：当 CNT=1 时，最高有效位的值发生变化
     *  OF=0：当 CNT=1 时，最高有效位的值不变
     *  CNT>1时，OF 无意义
     *  移位指令：SF、ZF、PF 根据移位结果设置，AF 无定义；
     *  循环移位指令可以改变操作数中所有位的位置，不影响 SF、ZF、PF、AF
*  算术/逻辑移位指令常用来乘以 2 或除以 2，以及 2 的整数幂，根据移位的位数，即移动 1、2、3…，分别为乘以或除以 21、 22、 23…
*  **算术 **移位适用于 **带符号数** 的运算；**逻辑 **移位指令用于 **无符号数** 的运算；



<img src=".\media\移位指令1.webp" style="zoom:38%;" />

<img src=".\media\移位指令2.webp" style="zoom:38%;" />



### 无条件转移指令：`JMP`

- ##### 段内直接短转移：JMP   SHORT  OPR 

- 执行操作：IP ←  IP + 8位位移量



- ##### 段内直接近转移：JMP   NEAR PTR  OPR

- 执行操作：IP ← IP + 16位位移量



- ##### 段内间接转移：JMP   WORD PTR  OPR

- 执行操作：IP ← (EA) ，其中 OPR 为存放在 16 位通用寄存器或字内存单元内的偏移量



### 条件转移指令：`JZ/JNZ` 、 `JE/JNE`、 `JS/JNS`、 `JO/JNO`、`JP/JNP`、 `JB/JNB`、 `JL/JNL`、 `JBE/JNBE`、`JLE/JNLE`、 `JCXZ` 

首先回忆标志位作用：

<img src=".\media\标志寄存器的格式及各位的含义.webp" style="zoom:50%;" />



**条件转移指令** 将标志位的状态作为测试的条件，所以 **首先需要执行影响标志位的指令**（如 CMP 或 TEST 等），然后采用条件转移指令测试相应的标志，决定程序的转移

注意：

- 只能使用 **段内直接寻址** 的 8 位位移量；
- 条件转移指令均为段内短转移，即转移范围为：**-128 ~ +127** 



（还是 PPT 最靠后出现的这张表比较细……）

测试 CX 的值为 0 则转移：**JCXZ   OPR           (CX)=0**

<img src=".\media\条件转移指令表.webp" style="zoom:75%;" />



条件转移指令可分为三种：

* ##### 根据单个条件标志的设置情况转移

  <img src=".\media\根据单个条件标志.webp" style="zoom:38%;" />

  

* ##### 比较两个无符号数，并根据比较结果转移

  * 适用于地址（为无符号数）或双精度数低位字（为无符号数）的比较

<img src=".\media\比较两个无符号数.webp" style="zoom:38%;" />



* ##### 比较两个有符号数，并根据比较结果转移

  * 参考有符号数的 CMP 指令或减法指令对 SF/OF 的影响
  *  适用于有符号数的比较

<img src=".\media\比较两个带符号数.webp" style="zoom:38%;" />



### 循环指令：`LOOP`、`LOOPZ/LOOPE`、`LOOPNZ/LOOPNE`

- ##### 循环指令：**LOOP   OPR**

  测试条件：(CX) ≠ 0

  

- ##### 为零或相等时循环指令：**LOOPZ(LOOPE)   OPR**

  测试条件：ZF=1 且 (CX) ≠ 0

  

- ##### 不为零或不相等时循环指令：**LOOPNZ(LOOPNE)   OPR**

  测试条件：ZF=0 且 (CX) ≠ 0

  

- 执行步骤：

  - (CX) ← (CX) - 1   
  - 检查是否满足测试条件，如满足则 (IP) ← (IP) + 8 位位移量，实行循环；不满足则 IP 不变，退出循环；
    - **LOOP  AGAIN** 等价于 **DEC  CX；JNZ  AGAIN**，可以进行等价替换

- 注意：

  - CX 中存放循环次数；

  - 只能使用段内直接寻址的 8 位位移量；

  - LOOP 不影响 CF 和 ZF 位；

    

  #### 两种多重循环的方式：

<img src=".\media\CX计数器的保存和恢复.png" style="zoom:38%;" />



### 子程序调用和返回指令：`CALL`、`RET`

##### 子程序调用和返回的执行过程
- 保护断点；
  - 将调用指令的下一条指令的地址（断点）压入堆栈
- 获取子过程的入口地址；
  - 子过程第1条指令的偏移地址
- 执行子过程，含相应参数的保存及恢复；
- 恢复断点，返回原程序；
  - 将断点偏移地址由堆栈弹出



段间调用需要同时保护 CS 和 IP：

<img src=".\media\子过程调用和返回.png" style="zoom:38%;" />



#### `CALL` 调用指令：

- 段内直接近调用：**CALL  DST**（其中 DST 为子程序名）

  - 执行操作： **(SP) ← (SP) – 2              ; 断点压入堆栈**

  ​                           **( (SP)+1,(SP) ) ← (IP)     ; 主程序地址压栈**

  ​                           **(IP) ← (IP) + 16 位位移量**

  - 注意：IP为Call指令的下一条指令的地址，其与 DST 子程序的地址间的相对地址或位移量是固定的

    

- 段内间接近调用：**CALL  DST**，其中 DST 为寄存器（如 BX）或存储器地址（如 WORD PTR [BX]）

  - 执行操作： **(SP) ← (SP) – 2**

  ​                           **( (SP)+1, (SP) ) ← (IP)**

  ​                           **(IP) ← (EA)     ; (DST为内存地址)**



#### `RET` 返回指令

- 段内近返回：**RET**

- 功能：将堆栈中保存的2字节断点的偏移地址恢复IP中，CS不变

  - 执行操作： **(IP) ← ( (SP)+1, (SP) )** 

    ​                    **(SP) ← (SP) + 2**

- 段内带立即数近返回：**RET  EXP**

  - EXP 表示弹出断点之后，使 SP 内容再回退 EXP 个字节单元，作用是 **使断点之后的 EXP 个字节单元分数据失效**（区别于带参数返回，主要作用是回退堆栈，使之前入栈内容失效）



<img src=".\media\子过程例题.png" style="zoom:38%;" />





### 中断与中断返回指令：`INT`、`INTO`、`IRET`

8086 中断系统最大支持 256 个中断，每个中断具有唯一的中断号，且具有独立的中断服务程序；

发生中断时，CPU 当前程序被暂停，转而执行中断处理程序；

<img src=".\media\8086中断表.png" style="zoom:48%;" />



#### **中断向量**

- 中断向量是中断例行程序的入口地址，存放于中断向量区，指向中断服务程序的段值和偏移量（CS:IP）；
- CPU 在执行 `INT` 指令时，从中断向量表中取出相应的值赋值给 CS 和 IP，转去执行中断服务程序。这些操作是由硬件直接实现的，把它称为中断隐指令，其操作过程程序员不可见；程序员能够做的就是修改中断向量表中存储的值。
- 中断隐指令并不是指令系统中的一条真正的指令，它没有操作码，所以中断隐指令是一种特殊指令。



（在 8086 中，reset 不算是中断，不在中断向量表内）



#### 中断指令格式：`INT   TYPE` 或  `INT`（没有类型号就默认调用 3 号中断）

- 隐含的操作：**(SP) ← (SP) - 2**

  ​                       **( (SP)+1, (SP) ) ← (FLAGS)**

  ​                       **(SP) ← (SP) - 2**

  ​                       **( (SP)+1, (SP) ) ← (CS)**

  ​                       **(SP) ← (SP) - 2**

  ​                       **( (SP)+1, (SP) ) ← (IP)**

  ​                       **(IP) ← (TYPE\*4)**

  ​                       **(CS) ← (TYPE\*4+2)**

- 注意：

  - TYPE (0~255) 是中断类型号



#### 中断返回指令：**`IRET`**

- 执行操作： **(IP) ← ( (SP)+1,(SP) )** 

  ​                    **(SP) ← (SP) + 2**

  ​                    **(CS) ← ( (SP)+1,(SP) )** 

  ​                    **(SP) ← (SP) + 2**

  ​                    **(FLAGS) ← ( (SP)+1,(SP) )** 

  ​                    **(SP) ← (SP) + 2**

  - `INT` 指令还把 IF 和 TF 置0，但不影响其它标志位
  - `IRET` 指令执行完，标志位由堆栈中取出的值确定



#### 溢出中断指令：**`INTO`**

- 执行操作：**若 OF=1**，则 **(SP) ← (SP) - 2**

  ​                                          **( (SP)+1, (SP) ) ← (FLAGS)**

  ​                                          **(SP) ← (SP) - 2**

  ​                                          **( (SP)+1, (SP) ) ← (CS)**

  ​                                          **(SP) ← (SP) - 2**

  ​                                          **( (SP)+1, (SP) ) ← (IP)**

  (最后两步不一样)

  ​                                          **(IP) ← (10H)**

  ​                                          **(CS) ← (12H)**



### 处理机控制指令

#### 标识处理指令

- ##### `CLC`、 `STC`、 `CMC`：对CF位清零/置位/取反

- ##### `CLD`、`STD`：字符串移动方向增/减标志

- ##### `CLI`、`STI`：开/关中断  



#### 其他处理机控制与杂项操作指令

##### 空操作指令：`NOP`

该指令没有的显式操作数，主要起延迟下一条指令的执行，只是占用一条指令的时间，不影响任何标志位。



##### 等待指令：`WAIT`

该指令使CPU处于等待状态，直到协处理器(Coprocessor)完成运算，并用一个重启信号唤醒CPU为止。该指令的执行不影响任何标志位。 

*协处理器不算外设，而是另一个FPU（浮点运算器）



##### 暂停指令：`HLT`

在等待中断信号时，该指令使CPU处于暂停工作状态【低功耗模式】，CS:IP指向下一条待执行的指令，但不进行任何操作，保持先前操作中所有寄存器的状态不变 。当产生了中断信号，CPU把CS和IP压栈，并转入中断处理程序。在中断处理程序执行完后，中断返回指令IRET弹出IP和CS，并唤醒CPU执行下条指令。指令的执行不影响任何标志位。



##### 封锁数据指令：`LOCK` 

格式：**LOCK INSTRUCTION**

该指令是一个前缀指令形式，后面跟一个具体的操作指令；

LOCK指令可以保证是在其后指令执行过程中，禁止协处理器修改数据总线上的数据，起到独占总线的作用。

该指令的执行不影响任何标志位。




## 习题课（作业 1 ~ 作业 3）

- 寄存器和立即数寻址没有物理地址
- 汇编机器中数字一律以补码形式储存，**DB -12H** 记成 **0EEH**  
- 一个 Byte 只能放一个字母的 ascii 码值
- 定义字符串可以后加 `,’$’`，类似于 C 语言的 `\0`，代表显示字符串结束



课堂小测题：

1、指出下列指令的错误

(1)	**MOV	AH,BX**                                 错，位宽不匹配

(2)	**MOV	[BX],[SI]**                              错，不能在内存之间mov

(3)	**MOV	AX,\[DI][SI]**                          错，DI和SI都是变址寄存器

(4)	**MOV	MYDAT\[BX][SI],ES:AX**      错，1.两个内存不能mov，2.AX不能进行段超越，应该是ES:[BX]

(5)	**MOV	CS,AX**                                  错，CS不能用mov改变



2、下列哪些指令是非法的

(1)	**CMP	15,BX**                                  错，第一个不能是立即数

(2)	**CMP	BYTE PTR OP1,25**             对

(3)	**CMP	OP1,OP2**                            错，不能同时是存储器寻址

(4)	**CMP	AX,OP1**                               对



## 5. 汇编程序的结构设计



### 编写汇编代码的一般步骤

1. 分析题意，确定算法
2. 确定解决问题的思路和方法
3. 根据算法画出程序框图
4. 根据框图编写程序
5. 上机调试程序



#### 两个常用中断指令调用

参考 [中断功能表（全英文）](https://github.com/Sayaka-4987/Notes_for_BJTU_Finals/blob/main/21-Fall-%E6%B1%87%E7%BC%96%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0.md#%E4%B8%AD%E6%96%AD%E5%8A%9F%E8%83%BD%E8%A1%A8%E5%85%A8%E8%8B%B1%E6%96%87) 部分；

- ##### `INT 21H`，功能号 `02H`
  向显示屏幕上输出来自 DL 的单个字符；

```assembly
MOV  DL, ‘A’ 	; 调用参数: 输出字符 ‘A’ 
MOV	 AH, 02	    ; DOS功能号: 显示输出
INT	 21H		; DOS调用
```



- ##### `INT 21H`，功能号 `09H`
  向显示屏幕上输出来自 DX 的字符串；

```assembly
STR	DB ‘computer’, ‘$’	 ;在数据段定义

MOV	DX, OFFSET STR        ; 调用参数: 输出字符串 ‘computer’ 
MOV	AH, 09H               ; DOS功能号: 显示输出串
INT	21H 	              ; DOS调用
```



### 分支结构程序设计

首先需要理明白程序逻辑；

#### 分支程序涉及的条件转移指令

##### 无条件转移指令 `JMP`

功能：无条件地使程序转移到指定的目标地址

<img src=".\media\JMP类型表.png" style="zoom:38%;" />



例：不同类型的 `JMP` 指令

```assembly
JMP  NEXT                ; 段内直接转移
JMP  SHORT LP1           ; 段内直接转移，LP1 为短距离标号
JMP  AX                  ; 段内间接转移，IP ← AX
JMP  [BX]                ; 段内间接转移，IP ← [BX+1][BX]
JMP  LABLE_NAME          ; 段间直接转移，LABEL_NAME 标号在其他代码段
JMP  DWORD PTR[BX][SI]   ; 段间间接转移，DWORD PTR 说明后面是双字数据
```



##### 条件转移指令 

<img src=".\media\条件转移指令表.webp" style="zoom:75%;" />



例：字符比较程序，两个字符相同时，显示 YES ；否则显示 NO ；

```assembly
DATA SEGMENT
  D1   DB ‘A’
  D2   DB ‘B’
  RES1 DB ‘YES’, ’$’
  RES2 DB ‘NO’,  ’$’
DATA ENDS
CODE SEGMENT	
ASSUME CS:CODE,
	   DS:DATA
START: MOV AX,DATA
       MOV DS,AX
       MOV AL,D1
       MOV BL,D2    
       CMP AL,BL 
       JNE NEXT1
       LEA DX,RES1 
       JMP NEXT2         
NEXT1: LEA DX,RES2
NEXT2: MOV AH,09H
       INT 21H
       MOV AH,4CH
       INT 21H
CODE ENDS
     END START
```



例：设存储单元 A 和 B 各有一 **无符号字节数**，比较大小，将较大数送A单元

```assembly
DATA  SEGMENT
  A   DB 39H             
  B   DB 0B4H
DATA  ENDS

CODE  SEGMENT	
      ASSUME CS:CODE,DS:DATA
START:MOV AX,DATA
      MOV DS,AX
      MOV AL,A
      CMP AL,B
      JNB NEXT
      XCHG AL,B
      MOV A,AL
NEXT: MOV AH,4CH
      INT 21H	
CODE ENDS
     END START
```



#### 分支程序的 CASE 和 IF-THEN-ELSE 结构

实现方法：

1. 用多个双分支结构实现多分支结构
2. 利用地址表法实现多分支结构（存指令入口地址）
3. 利用转移表法实现多分支结构（存指令）
4. 利用逻辑分解法实现多分支结构



例：计算符号函数 SNG（X）的值

```assembly
DATA   SEGMENT
   X   DB 0B9H
   Y   DB ?
DATA   ENDS
CODE   SEGMENT	
       ASSUME CS:CODE,DS:DATA 
START: MOV AX,DATA
       MOV DS,AX
       MOV AL,X
       CMP AL,0
       JL NEXT1
       CMP AL,0
       JG NEXT2      	
       MOV Y,0 	   	; 0 送 Y
       JMP RES	  
NEXT1: MOV Y,0FFH	; -1 送 Y    
       JMP RES
NEXT2: MOV Y,1	   	; 1 送 Y
    RES: MOV AH,4CH
         INT 21H
CODE  ENDS
      END START
```



#### 地址表法

设计方法：把各分支程序段的入口地址依次存放在 **数据段用 `ADTAB` 定义的一个表中**，形成地址表，取各分支程序段的编号作为各分支入口地址的表地址的位移量；

某个分支程序入口地址的表地址为：**表地址 = 编号 * 2（IP 是 16 位，占两个字节）+ 入口地址首地址**



例：用地址表法编写程序实现从低到高逐位检测一个字节数据，找出第一个非0的位数；

检测时，为0则继续检测，为1则转移到对应的处理程序段显示相应的位数；

```assembly
DATA   SEGMENT
    NUM   DB 78H
    ADTAB DW AD0,AD1,AD2,AD3,AD4,AD5,AD6,AD7
DATA   ENDS

CODE   SEGMENT
       ASSUME CS:CODE,DS:DATA
       
START: MOV AX,DATA
       MOV DS,AX
       MOV AL,NUM
       MOV DL,'?'
       CMP AL,0
       JZ DISP
       MOV BX,0
       
AGAIN: SHR AL,1
       JC NEXT
       INC BX
       JMP AGAIN
       
 NEXT: SHL BX,1        
       JMP ADTAB[BX]
       
  AD0: MOV DL,’0’ 
       JMP DISP
  AD1: MOV DL,’1’
       JMP DISP
  AD2: MOV DL,’2’
       JMP DISP
  AD3: MOV DL,’3’
       JMP DISP
  AD4: MOV DL,’4’
       JMP DISP 
  AD5: MOV DL,’5’
       JMP DISP
  AD6: MOV DL,’6’
       JMP DISP
  AD7: MOV DL,’7’
  
 DISP: MOV AH,2
       INT 21H
       MOV AH,4CH
       INT 21H
CODE ENDS
     END START 
```



#### 转移表法

设计方法：把转移到各分支程序段的转移指令依次存放在一起，用 `TAB: ` 开头，作为转移表；

使用时，以各转移指令在表中的位置，即离表首地址的偏移量，作为转移条件，偏移量加上表首地址作为转移地址，转到表的相应位置，执行相应的无条件转移指令；

转移表中每条转移指令（段内短转移）占用2个字节，计算公式如下：**表地址 = 模式字 * 2 + 转移表首地址**



例：根据输入值（0~4）的不同，执行不同的操作，用转移表法编写程序

```assembly
CODE   SEGMENT
       ASSUME CS:CODE
START: LEA BX,TAB    ; 转移表首地址送BX
       MOV AH,1           
       INT 21H       ; 输入字符送AL  
       SUB AL,30H    ; 字符变数字
       MOV AH,0
       ADD AX,AX     ; 模式字*2送AX
       ADD BX,AX
       JMP BX
       
  TAB: JMP SHORT MODE0    ; 转移表
       JMP SHORT MODE1
       JMP SHORT MODE2
       JMP SHORT MODE3
       JMP SHORT MODE4 

MODE0: MOV DL,30H
       JMP EXIT
MODE1: MOV DL,31H
       JMP EXIT
MODE2: MOV DL,32H
       JMP EXIT
MODE3: MOV DL,33H
       JMP EXIT
MODE4: MOV DL,34H

     EXIT: MOV AH,2
           INT 21H
           MOV AH,4CH
           INT 21H
           
CODE  ENDS
      END START
```



#### 逻辑分解法

设计方法：将多分支结构采用逻辑等效的方法，按条件的先后，依次分解成一串双分支结构，然后再使用双分支的方法来进行程序设计；

例：根据AL中的值（0~4），执行不同的操作，但用逻辑分解法编写程序    

```assembly
DATA  SEGMENT
      NUM   DB 2
DATA  ENDS

CODE  SEGMENT
ASSUME CS:CODE,DS:DATA
START: MOV AX,DATA
       MOV DS,AX
       MOV AL,NUM
       CMP AL,0
       JZ NEXT0
       CMP AL,1       
       JZ NEXT1
       CMP AL,2
       JZ NEXT2
       CMP AL,3
       JZ NEXT3
       CMP AL,4
       JZ NEXT4
NEXT0: MOV DL,30H
       JMP EXIT
NEXT1: MOV DL,31H
       JMP EXIT
NEXT2: MOV DL,32H
       JMP EXIT
NEXT3: MOV DL,33H
       JMP EXIT
NEXT4: MOV DL,34H
    EXIT: MOV AH,2
          INT 21H
          MOV AH,4CH
          INT 21H
CODE ENDS
     END START
```







### 循环结构程序设计

<img src=".\media\循环程序的两种结构.png" style="zoom:38%;" />

循环结构包括这些部分：

- 初始化：设置循环的初始状态
- 循环体：循环的工作部分及修改部分
- 控制条件：
  - 计数控制
  - 特征值控制
  - 地址边界控制



可以用分支指令控制循环：

```assembly
DATA  SEGMENT
  STR  DB ’computer$’
  LEN  DB ?
DATA  ENDS

CODE  SEGMENT
      ASSUME CS:CODE,DS:DATA
START:
    MOV AX,DATA	
    MOV DS,AX
    LEA SI,STR		    ; 串首地址
    XOR BL,BL		    ; 计数器清0
    LOP:
        MOV AL,[SI]	    ; 取一个字节
        CMP AL,24H      ; 和’$’进行比较
        JZ STOP         ; 相等则结束
        INC BL          ; 否则计数器加1
        INC SI          ; 地址指针加1
        JMP LOP         ; 转回到LOP
    STOP:
        MOV LEN,BL  ; 存储字符个数
        MOV AH,4CH 
        INT 21H
CODE  ENDS	
      END START
```



#### 用专用的循环指令控制循环

循环指令执行步骤： 

1.  **(CX)  ←  (CX) - 1**

2.  检查是否满足测试条件，如满足则 (IP) ← (IP) + 8 位位移量，实行循环；不满足则 IP 不变，退出循环；



注意：`LOOP` 指令执行时，CX 是否为 0 不影响 ZF 和 CF 的变化，等价于 `DEC` 指令；所以 `LOOP` 指令和 `LOOPNZ` 指令才有区别；

| 指令                        | 转移条件                   | 说明                 |
| --------------------------- | -------------------------- | -------------------- |
| **`LOOP  OPR`**             | 测试条件：(CX) ≠ 0         |                      |
| **`LOOPZ (LOOPE)   OPR`**   | 测试条件：ZF=1 且 (CX) ≠ 0 | 为零或相等时循环     |
| **`LOOPNZ (LOOPNE)   OPR`** | 测试条件：ZF=0 且 (CX) ≠ 0 | 不为零或不相等时循环 |



例：求以 BUF 为首地址的10个内存单元的无符号数据和。已知其和小于等于 255，将结果存入第 11 个内存单元

```assembly
DATA  SEGMENT
  BUF  DB 12H,38H,46H,0BH,09H,41H,32H,56,02H,26H
  RES  DB ?
DATA  ENDS
CODE  SEGMENT
      ASSUME CS:CODE,DS:DATA
START: 
    MOV AX,DATA	
    MOV DS,AX
    MOV AL,0	; 存放累加之和
    MOV CX,0AH  ; 累加次数
    LEA BX,BUF  ; 数据表的首地址	
    LP: 
        ADD AL,[BX]          ; 累加
        INC BX          	 ; 地址增1     	
        LOOP LP              ; 若CX-1不为0，则继续循环
    MOV RES,AL 	         ; CX-1=0，则存累加和 
    MOV AH,4CH
    INT 21H
CODE  ENDS	
      END START
```



例：在字节数组中找出第一个非 0 的数据，并将其下标存入 RES 单元，假设其下标值小于 10 

```assembly
DATA  SEGMENT
  ARR  DB 0,0,38H,46H	
       DB 89H,67H,0H,92H
  CNT  EQU $–ARR
  RES  DW ?
DATA  ENDS
CODE  SEGMENT	
      ASSUME CS:CODE,DS:DATA
START: 
    MOV AX,DATA
    MOV DS,AX
    MOV CX,CNT   ; 循环次数为 CNT 数组长度
    MOV DI,-1    ; 数组下标从 0 开始
AGAIN: 
    INC DI                                       
    CMP ARR[DI],0       ; 和0比较
    LOOPZ AGAIN         ; 为0，且没比较完，则循环
    JZ EXIT             ; 比较完仍为0，转 EXIT
    MOV RES,DI          ; 找到了，送下标号到 RES
EXIT: 
    MOV AH,4CH
    INT 21H 
CODE  ENDS
      END START
```



#### 按问题的条件控制循环

含义：用转移指令来判断循环条件

应用场合：循环次数不确定



例：记录某个字节存储数据单元中1的个数，并把结果存入RES中

```assembly
DATA  SEGMENT
  NUM  DB  75H
  RES  DB  ?
DATA  ENDS   

CODE  SEGMENT
      ASSUME CS:CODE,DS:DATA
START:
    MOV AX,DATA        
    MOV DS,AX
    MOV BL,NUM    	
    XOR DL,DL    ; DL清零    
    AGAIN:
        TEST BL,0FFH
        JZ NEXT      ; 判断数据是否0
        SHR BL,1     ; 逻辑右移1位
        ADC DL,0     ; 带进位加法
        JMP AGAIN
NEXT:
    MOV RES,DL
    MOV AH,4CH
    INT 21H		
CODE  ENDS	       
      END START
```



#### 按逻辑变量控制循环

含义：用转移指令来判断循环条件

应用场合：控制转入不同的循环支路

方法：把逻辑变量送入寄存器中，以逻辑变量各位的状态作为执行某段程序的标志



例：在以 BUF 为起始地址的内存中放有若干个字节型无符号数，假定某逻辑变量的长度为一个字节（其值为10010101），它的 D0 \~ D7 位对应着 BUF \~ BUF + 7 单元内容的运算。即某位为 0，则将相应单元内容的最高位求反，其它位不变；而某位为 1，则将相应单元内容之高低四位互换

```assembly
DATA  SEGMENT
 BUF  DB 75H,12H,87H,98H
      DB 81H,56H,73H,51H
  B   EQU 8
  C   EQU 10010101B
DATA  ENDS	

CODE  SEGMENT	                          
      ASSUME CS:CODE,DS:DATA
START:
    MOV AX，DATA        
    MOV DS,AX            
    MOV AH,B       ; 指示数据个数
    MOV CH,C
    LEA BX,BUF
LP:
    MOV AL,[BX]      
    SHR CH,1
    JNC NEXT       ; CF=0跳转
    MOV CL,4
    ROL AL,CL      ; 高低位交换
    JMP RES
    
NEXT:
    XOR AL,80H     ; 高位取反
    
RES:
    MOV [BX],AL 
    INC BX
    DEC AH         ; 数据个数-1
    JNZ LP         ; 未读完则继续
    MOV AH,4CH
    INT 21H
    
CODE ENDS
     END START
```



<img src=".\media\例8配图.png" style="zoom:48%;" />



#### 多重循环程序设计

含义：指循环体内还有循环，也就是嵌套循环

注意：(1) 不允许循环结构交叉；(2) 转移指令只能从循环结构内转出或可在同层循环内转移



例：设在以 EXST 为首址的存储区中依次存放着某考区 245 个理科生的七门成绩，现要统计每个考生的总成绩，并将其存放在该考生单科成绩之后的两个单元

```assembly
DATA  SEGMENT
    EXST  DB 01,75,82,84,92,78,49,85,00,00
          DB 02,83,92,63,76,82,58,69,00,00
    ……      
DATA  ENDS   

CODE  SEGMENT                                                            
    ASSUME CS:CODE,DS:DATA                               
    MOV AX,DATA                                                     
    MOV DS,AX
START:
    LEA SI,EXST		; 数据表首地址
    MOV BL,245  	; 245个学生，外循环次数
    LOP2: 
        MOV CX,7        ; 七门课成绩，内循环次数 
        XOR AX,AX		; 清0，存总成绩
        INC SI     		; 跳过准考证号
        LOP1: 
            ADD AL,[SI]	    ; 单科成绩累加
            ADC AH,0	    ; 加进位位
            INC SI 		    ; 修改地址指针
            LOOP LOP1       ; 没累加完单科成绩，则继续   
        MOV WORD PTR [SI],AX   ; 累加完，存总成绩
        INC SI 		           ; 跳过存总成绩的2个单元               
        INC SI                                     
        DEC BL 		           ; 外循环次数减1
        JNZ LOP2		       ; 不为0，则求下个学生总成绩              
    MOV AH,4CH             
    INT 21H
CODE  ENDS                                           
END  START
```



## 实验 1. Debug 调试

（应该是）不区分大小写；

### DEBUG 命令

#### “ U ” 命令

功能：将程序反汇编

格式：-`U` 



#### “ D ” 命令

功能：显示内存单元的内容.

注意：十六进制是 DEBUG 唯一认识的数字系统,键入和输出时十六进制数不用后加 “H”，十进制数后要加 “D” 

格式： -`D [存储单元地址]`    

例：-`D 7A0:100`    ; 显示的信息是段地址是 7A0H 和偏移地址是 100H 开始的内存单元的内容，表示方式是一行 16 个数据，然后是对于的 ASCII 字符



#### “ E ” 命令

功能：修改存储单元的内容

格式：

1.  -`E 存储单元地址 数据 数据 数据 ...`  ;（输入数据后按空格键可连续修改数据）此格式使键入的数据替代了指定范围的存储单元内容
2.  -`E 存储单元地址`       ; 此格式采用逐个存储单元相继修改的方法



#### “ F ” 命令

功能：用一个指定的十六进制数填入一部分存储单元

格式：-`F 开始地址 终止地址 常量`        ;   “F”命令与“E”命令都可修改存储单元的内容,但“F”命令只能键入一串相同的数据。

例：-`F 100 120 4F`



#### “ R ” 命令

功能：检查和修改寄存器的内容

格式：

1. -`R`                       ; 显示CPU内所有寄存器内容和标志位状态
2. -`R 寄存器名字`   ; 显示和修改某个寄存器的内容
3. -`RF`                    ; 显示和修改标志位状态



#### “ A ” 命令

功能：汇编命令

格式：-`A [开始存放指令的地址]`    ; 可以键入汇编语言语句，并能把它汇编成机器代码，相继放入从指定地址开始的存储器中，回车键退出，回到 DEBUG 提示符下



#### “ T ” 命令

功能：跟踪命令

格式：

1. -`T [=指令地址]`   ; 功能：从指定的地址起执行一条指令后停下来，显示所有寄存器内容及标志位的值；如未指定地址，则从当前的 CS:IP 开始执行
2. -`T [=指令地址][要执行的指令条数N]`   ; 功能：从指定地址开始执行 N 条指令后停下来显示



#### “ G ” 命令

功能：运行命令

格式：-`G=<地址>,<断点>`       ; 从起始地址 0 开始运行，在断点地址 1C 处停止，并显示指令从 0 开始，到断点 1C 执行后，所有寄存器及标志位内容，以及下一条要执行的指令

例：-`G=0,1C`



#### “ Q ” 命令

功能：退出 DEBUG 命令符模式

格式：-`Q` 







# 附录

这里放一些外部资料笔记或者暂时没法归类的内容：



## 补充资料：8086 汇编语言初学者教程

- 这部分内容来自 [8086汇编语言初学者教程](https://www.cnblogs.com/QuLory/archive/2012/11/07/2758048.html)；
- 用于 **快速入门** 编写汇编语言；

（目前不太确定这部分放在哪，因为在教师课件那里 **8086的指令系统** 安排太靠后，但在课件介绍具体功能前，就已经出现了很多指令，暂时先放在这）



### `MOV` 指令

- 功能：将第二个操作数（源）拷贝到第一个操作数（目的）指定位置；
- 源操作数可以是立即数，通用寄存器或者内存单元；
- 目的寄存器可以是通用寄存器或者内存单元；
- 源和目的必须是同样大小，要么都是字节要么都是字；



#### `MOV` 指令的操作类型

- **REG**：AX, BX, CX, DX, AH, AL, BL, BH, CH, CL, DH, DL, DI, SI, BP, SP；
- **memory**：[BX], [BX+SI+7], 变量等；
- **immediate**：5, -24, 3Fh, 10001101b 等；
- **SREG**：DS, ES, SS, 注意 **CS 只能作为操作源**（意思是 MOV CS, AX 会报错，MOV AX, CS 可以）；

```assembly
MOV REG, memory
MOV memory, REG
MOV REG, REG
MOV memory, immediate
MOV REG, immediate

; MOV 只支持如下段寄存器：
MOV SREG, memory
MOV memory, SREG
MOV REG, SREG
MOV SREG, REG
```



### 声明变量

编译器支持两种变量： **BYTE**（字节） 和 **WORD**（字）；

- name 可以是任何字母与数字构成，但是必须由字母开头；
- 可以通过不命名来声明一个没有名称的的变量（这个变量只有地址，没有名称）；
- value 可以是任何数值，支持三种进制（十六进制、二进制、十进制），可以使用 `?` 符号表示初始值没有确定；

```assembly
name DB value ; 名称 DB 值, DB = stays for Define Byte.
name DW value ; 名称 DW 值, DW = stays for Define Word.
```

例：（COM 文件）

```assembly
#MAKE_COM#
ORG 100h

MOV AL, var1
MOV BX, var2

RET    ; stops the program.

VAR1 DB 7
var2 DW 1234h
```



### 声明常量

常量同变量很相似，但是它一直存在。定义一个变量之后，它的值不会改变；

使用 `EQU` 语句定义常量；

格式：**name equ <任意表达式>**

```assembly
k EQU 5
MOV AX, k    ; 等价于 MOV AX, 5
```



### `ORG` 伪指令

`ORG` 是一个编译指令，它告诉编译器如何处理源代码；

`ORG 100` 通知编译器，可执行程序将被调入偏移量是 100h（256 字节）的位置，从而可以计算出所有变量的正确地址，然后用这些地址（偏移量）来代替变量名称；

- 这些指令不会真正的编译为任何机器代码，本身也不占内存空间；

- 可执行程序总是被装入偏移量 **100h**；

- EXE文件调入在偏移量 0000 的位置，它使用特定的段保存变量

#### `ORG` 的使用

- `ORG 100` 用在 COM 文件的开头；
- 还可以用于指明下一条汇编语句的偏移地址 ：


```assembly
SEG1    SEGMENT
        ORG   10         ; 设置$为10，此段目标代码从偏移地址10开始
        VAR1  DW  1234H  ; VAR1的偏移地址为10
        ORG   20         ; 在10和20地址之间是没有指令的
        VAR2  DW  5678H
        ORG   $+8        ; $增加8，即在5678H之后空出8个字节
        VAR3  DW  1357H
SEG1    ENDS

        ORG  100H
START:  ……
```



### 数组

- 数组可以看作是变量链，一个字符串本质是一个字节数组；
- 对于字符串，字符串是 byte 的数组，byte 是最小单位；
- 对于双字节整数，word 是最小单位



#### 定义数组

```assembly
a DB 48h, 65h, 6Ch, 6Ch, 6Fh, 00h
b DB 'Hello', 0
```



### `DUP` 指令：重复

- 格式：**number DUP ( value(s) )** 
- 其中 number 为重复的数量（任意常数），value 为将要复制的表达式

```assembly
c DB 5 DUP(9)    ; 等价于 c DB 9, 9, 9, 9, 9 
d DB 5 DUP(1, 2) ; 等价于 d DB 1, 2, 1, 2, 1, 2, 1, 2, 1, 2 
```



### `LEA` 指令或 `OFFSET` 指令：取得变量地址

```assembly
#MAKE_COM#
ORG 100h
  
MOV AL, VAR1
LEA BX, VAR1  			; 等效于 MOV BX, OFFSET VAR1  

RET    ; stops the program.
   
VAR1 DB 12H
```



### `INT` 指令：软件中断

中断是一系列功能调用。比如，在打印机上输出一个字符，只需要简单的调用中断，它将完成所有的事情；

这些功能调用称作软件中断；

需要使用 INT 指令触发一个软件中断；

格式：**INT value**

其中 value 的取值范围是从 0 到 255 （或者 0 到 0FFH），通常使用十六进制写法；

每一个中断都有子功能，在调用一个中断的子功能之前，需要设置  AH 寄存器（通常使用 AH）；


每一个中断最多可以拥有 256 个子功能（因此，总共可以有 256*256＝65536 个功能调用）；



例：使用中断 **0Eh** 子功能输出字符串 ‘Hello!' 

```assembly
#MAKE_COM# ; 生成com文件的指令

ORG 100h

MOV AH, 0Eh ; 选择子功能 int 10h/0Eh，输出放在 AL 寄存器中的 ASCII 码对应的字符

MOV AL, 'H' ; ASCII码: 72
INT 10h ; 输出

MOV AL, 'e' ; ASCII 码: 101
INT 10h ; 输出

MOV AL, 'l' ; ASCII 码: 108
INT 10h ; 输出

MOV AL, 'l' ; ASCII 码: 108
INT 10h ; 输出

MOV AL, 'o' ; ASCII 码: 111
INT 10h ; 输出

MOV AL, '!' ; ASCII 码: 33
INT 10h ; 输出

RET ; 返回操作系统
```



#### 中断功能表（全英文）

有些可能是 emu8086 模拟器或者 DOSBOX 不支持的，没全部测试，请以运行结果为准；

| 指令及其功能                                                 | 输入                                                         | 输出                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **INT 10h** / **AH = 00h** \- set video mode.                | **AL** = desired video mode.<br>**00h** - Text mode 40x25, 16 colors, 8 pages. |                                                              |
| **INT 10h** / **AH = 01h** - set text-mode cursor shape.     | **CH** = cursor start line (bits 0-4) and options (bits 5-7). <br>**CL** = bottom cursor line (bits 0-4).<br>When bits 6-5 of CH are set to **00**, the cursor is visible, to hide a cursor set these bits to **01** |                                                              |
| **INT 10h** / **AH = 02h** - set cursor position.            | **DH** = row.<br/>**DL** = column.<br/>**BH** = page number (0..7). |                                                              |
| **INT 10h** / **AH = 03h** - get cursor position and size.   | **BH** = page number.                                        | **DH** = row.<br/>**DL** = column.<br/>**CH** = cursor start line.<br/>**CL** = cursor bottom line. |
| **INT 10h** / **AH = 05h** - select active video page.       | **AL** = new page number (0..7).                             |                                                              |
| **INT 10h** / **AH = 06h** - scroll up window.<br/>**INT 10h** / **AH = 07h** - scroll down window. | **AL** = number of lines by which to scroll (00h = clear entire window).<br/>**BH** = [attribute](https://www.cnblogs.com/QuLory/archive/2012/11/07/2758054.html#attrib) used to write blank lines at bottom of window.<br/>**CH, CL** = row, column of window's upper left corner.<br/>**DH, DL** = row, column of window's lower right corner. |                                                              |
| **INT 10h** / **AH = 08h** - read character and [attribute](https://www.cnblogs.com/QuLory/archive/2012/11/07/2758054.html#attrib) at cursor position. | **BH** = page number.                                        | **AH** = [attribute](https://www.cnblogs.com/QuLory/archive/2012/11/07/2758054.html#attrib).<br/>**AL** = character. |
| **INT 10h** / **AH = 09h** - write character and [attribute](https://www.cnblogs.com/QuLory/archive/2012/11/07/2758054.html#attrib) at cursor position. | **AL** = character to display.<br/>**BH** = page number.<br/>**BL** = [attribute](https://www.cnblogs.com/QuLory/archive/2012/11/07/2758054.html#attrib).<br/>**CX** = number of times to write character. |                                                              |
| **INT 10h** / **AH = 0Ah** - write character only at cursor position. | **AL** = character to display.<br/>**BH** = page number.<br/>**CX** = number of times to write character. |                                                              |
| **INT 10h** / **AH = 0Eh** - teletype output.                | **AL** = character to write.<br>This functions displays a character on the screen, advancing the  cursor and scrolling the screen as necessary. <br>The printing is always  done to current active page. |                                                              |
| **INT 10h** / **AH = 13h** - write string.                   | **AL** = write mode:<br/>  **bit 0**: update cursor after writing;<br/>  **bit 1**: string contains [attributes](https://www.cnblogs.com/QuLory/archive/2012/11/07/2758054.html#attrib).<br/>**BH** = page number.<br/>**BL** = [attribute](https://www.cnblogs.com/QuLory/archive/2012/11/07/2758054.html#attrib) if string contains only characters (bit 1 of AL is zero).<br/>**CX** = number of characters in string (attributes are not counted).<br/>**DL,DH** = column, row at which to start writing.<br/>**ES:BP** points to string to be printed. |                                                              |
| **INT 10h** / **AX = 1003h** - toggle intensity/blinking.    | **BL** = write mode:<br/>  **0**: enable intensive colors.<br/>  **1**: enable blinking (not supported by emulator!).<br/>**BH** = 0 (to avoid problems on some adapters). |                                                              |
| **INT 11h** - get BIOS equipment list.                       | **AX** = BIOS equipment list word, actually this call returns the contents of the word at 0040h:0010h. |                                                              |
| **INT 12h** - get memory size.                               | **AX** = kilobytes of contiguous memory starting at  absolute address 00000h,	this call returns the contents of the word at  0040h:0013h. |                                                              |
| **INT 13h** / **AH = 00h** - reset disk system               | (currently this call doesn't do anything).                   |                                                              |
| **INT 13h** / **AH = 02h** - read disk sectors into memory.<br/>**INT 13h** / **AH = 03h** - write disk sectors. | **AL** = number of sectors to read/write (must be nonzero)<br/>**CH** = cylinder number (0..79).<br/>**CL** = sector number (1..18).<br/>**DH** = head number (0..1).<br/>**DL** = drive number (0..3 , depends on quantity of FLOPPY_? files).<br/>**ES:BX** points to data buffer. | **CF** set on error.<br/>**CF** clear if successful.<br/>**AH** = status (0 - if successful).<br/>**AL** = number of sectors transferred. |
| **INT 15h** / **AH = 86h** - BIOS wait function.             | **CX:DX** = interval in microseconds                         | **CF** clear if successful (wait interval elapsed),<br/>**CF** set on error or when wait function is already in progress. |
| **INT 16h** / **AH = 00h** - get keystroke from keyboard (no echo). |                                                              | **AH** = BIOS scan code.<br/>**AL** = ASCII character.<br>(if a keystroke is present, it is removed from the keyboard buffer). |
| **INT 16h** / **AH = 01h** - check for keystroke in keyboard buffer. |                                                              | **ZF = 1** if keystroke is not available.<br/>**ZF = 0** if keystroke available.<br/>**AH** = BIOS scan code.<br/>**AL** = ASCII character.<br/>(if a keystroke is present, it is not removed from the keyboard buffer). |
| **INT 19h** - system reboot.                                 |                                                              |                                                              |
| **INT 1Ah** / **AH = 00h** - get system time.                |                                                              | **CX:DX** = number of clock ticks since midnight.<br/>**AL** = midnight counter, advanced each time midnight passes. |
| **INT 20h** - exit to operating system.                      |                                                              |                                                              |
| **INT 21h** / **AH=09h** - output of a string at DS:DX.      | **DS:DX** = 要输出的字符串<br>例：MOV DX, OFFSET MSG<br/>MOV AH, 09H<br/>INT 21H<br/>RET<br/>MSG DB "HELLO$" |                                                              |
| **INT 21h** / **AH=0Ah** - input of a string to DS:DX, fist byte is buffer size, second byte is number of chars actually read. | （待补充，使用时能弹出输入框，但没观测到 DS:DX 和其他寄存器有什么变化，可能是调用方式不对……） |                                                              |
| **INT 21h** / **AH=4Ch** - exit to operating system.         |                                                              |                                                              |
| **INT 21h** / **AH=01h** - read character from standard input, with echo, result is stored in AL. |                                                              | **AL** = 读入字母的 ascii 值                                 |
| **INT 21h** / **AH=02h** - write character to standard output. | **DL** = 要输出的字符                                        | 运行后 **AL** = DL                                           |



#### 颜色表

字符属性为 8 位值，低 4 位设置前景色，高 4 位设置背景色；

但是，不支持背景色闪烁；

```assembly
HEX    BIN       COLOR
-----------------------
0      0000      black
1      0001      blue
2      0010      green
3      0011      cyan
4      0100      red
5      0101      magenta
6      0110      brown
7      0111      light gray
8      1000      dark gray
9      1001      light blue
A      1010      light green
B      1011      light cyan
C      1100      light red
D      1101      light magenta
E      1110      yellow
F      1111      white
```



例：emu8086 中 1_sample.asm 的闪烁 Hello World!

```assembly
; color all characters:
mov cx, 12  ; number of characters.
mov di, 03h ; start from byte after 'h'

c:  mov [di], 11101100b   ; light red(1100) on yellow(1110)
    add di, 2 ; skip over next ascii code in vga memory.
    loop c
```



### 常用函数库 `emu8086.inc`

编译器会自动在你源程序所在的文件夹中查找你引用的文件，如果没有找到，它将搜索 `Inc` 文件夹；

使用 **emu8086.inc** 头文件需要在程序开头加上：

```assembly
include 'emu8086.inc'
```

**emu8086.inc** 定义了一些方便的输入输出宏：

```assembly
PUTC char ; 将一个ascii字符输出到光标当前位值，只有一个参数的宏

GOTOXY col, row ; 设置当前光标位置，有两个参数

PRINT string ; 输出字符串，一个参数

PRINTN string ; 输出字符串，一个参数。与 PRINT 功能相同，不同在于输出之后自动回车

CURSOROFF ; 关闭文本光标

CURSORON ; 打开文本光标

PRINT_STRING ; 在当前光标位置输出一个字符串字符串地址；由DS:SI 寄存器给出；使用时，需要在 END 前面声明 DEFINE_PRINT_STRING

PTHIS ; 在当前光标位置输出一个字符串（同 PRINT_STRING一样，不同之处在于它是从堆栈接收字符串。字符串终止符应在 call 之后定义；例如:
CALL PTHIS;  
db 'Hello World!', 0
; 使用时，需要在 END 前面声明 DEFINE_PTHIS  

GET_STRING ; 从用户输入得到一个字符串，输入的字符串写入 DS:DI 指出的缓冲，缓冲区的大小由 DX 设置；回车作为输入结束；使用时，需要在 END 前面声明 DEFINE_GET_STRING 

CLEAR_SCREEN ; 清屏过程(滚过整个屏幕)，然后将光标设置在左上角。使用时，需要在 END 前面声明DEFINE_CLEAR_SCREEN
　
SCAN_NUM ; 取得用户从键盘输入的多位有符号数，并将输入存放在 CX 寄存器；使用时，需要在 END 前面声明 DEFINE_SCAN_NUM

PRINT_NUM ; 输出 AX 寄存器中的有符号数；使用时，需要在 END 前面声明 DEFINE_PRINT_NUM以及 DEFINE_PRINT_NUM_UNS.

PRINT_NUM_UNS ; 输出 AX 寄存器中的无符号数；使用时，需要在 END 前面声明 DEFINE_PRINT_NUM_UNS.
```

使用例：

```assembly
include 'emu8086.inc'

ORG 100h

LEA SI, msg1 ; 要求输入数字
CALL print_string ;
CALL scan_num ; 读取数字放入 cx

MOV AX, CX ; CX 存放数值拷贝到 AX

; 输入如下字符
CALL pthis
DB 13, 10, 'You have entered: ', 0

CALL print_num ; 输出 AX 中的字符

RET ; 返回操作系统

msg1 DB 'Enter the number: ', 0

DEFINE_SCAN_NUM      ; 使用这些宏需要添加的
DEFINE_PRINT_STRING
DEFINE_PRINT_NUM
DEFINE_PRINT_NUM_UNS 
DEFINE_PTHIS

END ; 结束
```



### MASM debug 常用命令

- #### r 命令：查看或者改变CPU寄存器的内容

  - 查看寄存器：r
  - 改变某个寄存器内容：`r 寄存器`（如：ax），之后按下 Enter 出现 `:` ，再输入值



- #### d 命令：查看某段内存内容

  - 查看内存内容：`d 段地址:偏移地址` （结束的偏移地址，可忽略）
  - 注意：直接使用 d 命令，显示的是 debug 预设地址处的内容



- #### e 命令：改变内存内容

  - 改变内存内容：`e 段地址:偏移地址` 写入的数据
  - 也可以通过 `e 段地址:偏移地址 "字符串"`    这种方式向内存中写入字符串的 16 进制值



- #### u 命令：将机器指令翻译成汇编指令

  - 机器指令翻译成汇编指令：`u 段地址:偏移地址`
  - 注意：如果直接使用命令 u，debug 会把 CPU 中 CS:IP 指向的内存内容翻译成汇编指令



- #### t 命令：让 cpu 执行 CS:IP 指向的指令



- #### a 命令：以汇编指令的格式在内存中写入机器指令

  - 写入汇编指令：`a 段地址:偏移地址`，按下 enter 键后，输入汇编指令，当不想输入时直接按 enter 退出输入

  

- #### q 命令：退出 debug 

  

