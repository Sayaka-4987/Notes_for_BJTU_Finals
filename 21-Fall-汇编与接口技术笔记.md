# 汇编与接口技术

期末考试开卷、50% + 平时成绩20% + 常规实验15% + 研究性实验15%

地点：YF312 或九教 4 层实验室

### 这份笔记画 ※ 的都要背

### ！！做实验**<u>需要在上机前就编写完程序</u>** 



## 1. 基础知识

### 1.2 硬件接口

~~（这段抄的 zll 的，后面还一段也是，不想打字惹）~~

CPU与接口交换数据的方式：

1. **查询方式**

信息交换的控制完全由主机执行程序实现，程序查询方式接口中设置一个数据缓冲寄存器（数据端口）和一个设备状态寄存器（状态顿口）；

主机进行 I/O 操作时，先发出询问信号，读取设备的状态，并根据设备状态决定下一步操作究竟是进行数据传送还是等待。在这种控制方式下，CPU 一旦启动 I/O，就必须停止现行程序的运行，并在现行程序中插入一段程序；

CPU 要花费很多时间来查询和等待，而且在一段时间内只能与一台外设交换信息，效率低；

2. **中断方式**

CPU在程序中安排好于某个时刻启动某台外设，然后CPU继续执行原来的程序，不需要像查询方式一样一直等待外设准备就绪；

一旦外设完成数据传送的准备工作，就主动向CPU发出中断请求，请求CPU为自己服务；在可以响应中断的条件下，CPU暂时中止正在执行的程序，转去执行中断服务程序为外设服务，在终端服务程序中完成一次主机与外设之间的数据传送，传送完成后，CPU返回原来的程序；

3. **DMA 方式**

主存和 DMA 接口之间有一条直接的数据通路；

DMA 方式传送数据不需要经过CPU，因此不必中断现行程序，I/O与主机并行工作，程序和传送并行工作。



## 2. 80x86 计算机组织

本课程以 16 位的 8086 作为教学对象；

### 2.1 计算机系统

微处理器就是把 **运算器、寄存器组、控制器** 集成在一个超大规模集成电路芯片上的功能部件；

存储器是微机存放和记忆程序、数据的部件，分为内存和外存；

外设可以分为两部分，一类是直接为计算机运行服务的，如键盘、鼠标；另外一类是暂时不影响计算机的外设，如打印机，显示器；

系统总线包括数据总线（传送数据）、地址总线（指出数据来源或目的地）、控制总线（传送 CPU 对存储器或 I/O 设备的控制命令，和 I/O 设备对 CPU 的请求服务信号），总线工作由系统总线控制模块指挥；



### 2.2 8086 微处理器

8086 的基本性能指标：

1. 16位微处理器；
2. 16根数据线、20根地址线，可寻址的地址空间达 1MB (220Byte＝1MB)；
3. 可以和浮点运算器、I/O 处理器或其他处理器组成多处理器系统，提高系统的数据吞吐能力、处理能力

<img src=".\media\微信截图_20210908104652.png" style="zoom:33%;" />

通用寄存器包括 8 个 16 位寄存器：AX、BX、CX、DX、SP、BP、SI和DI；
标志寄存器为 FLAGS ，是一个 16 位的寄存器；

总线接口部件：负责管理与系统总线的接口，负责对存储器和外设访问；包括指令队列、指令指针、段寄存器、地址加法器和总线控制逻辑；

指令执行部件：包括 ALU 、通用寄存器、标志寄存器和控制电路；负责指令译码、数据运算和指令执行；

指令执行的两个主要阶段：取指和执行，其中取指：从主存取出指令代码进入指令队列，执行：译码指令、并发出有关控制信号实现指令功能；

8086 处理器的指令读取实质是 **指令预取**：8086 处理器维护着长度为 6 个字节的指令队列；EU 单元译码、执行指令，同时 BIU 单元读取后续指令，BIU 和 EU 两个单元相互独立，可以并行操作；



#### ※ 8086 CPU 寄存器分组表

<img src=".\media\8086寄存器.png" style="zoom:67%;" />

以 [ BX+SI ] 为例：BX 为基址、SI 为变址；

##### 数据寄存器 AX,  BX, CX, DX

- 数据寄存器用来保存 **操作数或运算结果** 等；

  - AX 是累加器，用于算术、逻辑运算以及外设传送信息等；
  - BX 是基址寄存器，常用于存放存储器地址；
  - CX 是计数器，作为循环或串操作等指令中的隐含计数器；
  - DX 是数据寄存器，用来存放双字数据的高16位或存放外设端口地址；

  

##### 指针寄存器 SP, BP 

- 指针寄存器和变址寄存器用于存放 **某个存储单元的偏移地址**；

  - SP 用于存放当前堆栈中栈顶的偏移地址；

  - BP 用于存放堆栈段中某一存储单元的偏移地址；

    

##### 变址寄存器 SI, DI

- 在串操作中， SI 和 DI 都具有自动增量或减量的功能，它的目的操作数和源操作数都在连续空间；

  - SI 用于存源地址（操作完其值不改变）；
  - DI 用于存目的地址，操作完其值发生改变；



##### 控制寄存器 IP, FLAGS 

- 2 个控制寄存器

  - IP 指令指针寄存器保存下一次将要取出指令的偏移地址，IP 的内容由微处理器硬件自动设置，不能用指令直接修改，有一些指令可以改变 IP 的值，如转移指令、子程序调用指令等；
  - FLAGS 标志寄存器包含 9 个标志位，保存一条指令执行后，CPU 所处状态信息及运算结果的特征；

  

##### 段寄存器 CS, DS, SS, ES 

- 段寄存器用来确定 **该段在内存中的起始地址**，8086 有 4 个 16 位的段寄存器

  - 代码段 CS 主要存放运行的程序
  - 数据段 DS 存放运行程序所用的数据
  - 堆栈段 SS 定义了堆栈的所在区域
  - 附加段 ES 是附加的数据段，它是辅助数据区，在串操作指令中，用到的目的串必定存放在附加段中

  

#### 通用寄存器的专门用途

<img src=".\media\通用寄存器的专门用途.png" style="zoom: 33%;" />



#### 堆栈的两种访问方式

1. 随机访问方式：用 BP 寄存器来指示随机访问地址；

2. 先进后出访问方式：用 SP 寄存器来表示栈顶；



#### 标志寄存器的格式及各位的含义

<img src=".\media\标志寄存器的格式及各位的含义.png" style="zoom:50%;" />

##### 进位标志 CF（Carry Flag）

当 **无符号整数** 加减运算的最高有效位有进位（加法）或借位（减法）时，CF＝1，否则 CF＝0；



##### 奇偶标志 PF（Parity Flag）

当运算结果的 **最低字节**（注：就是看最后 8 位，1 个字节 Byte 8 位 bit，8 位的结果看全部 8 位，16 位的结果看后 8 位）中， 1 的个数为零或偶数时，PF＝1；否则 PF＝0；



##### 辅助进位标志 AF（Auxiliary Carry Flag）

当运算结果的低位的一半向高位（如字节数 8 位，就是低 4 位向高 4 位）有进位或借位时，AF = 1；

其实只看（数据宽度）/ 2 两边那两位就行；该标志与操作数长度无关；



##### 零标志 ZF（Zero Flag）

运算结果为0，则 ZF＝1，否则 ZF＝0；



##### 符号标志 SF（Sign Flag）

运算结果最高位为1，则 SF＝1，否则 SF＝0；



##### 溢出标志 OF（Overflow Flag）

当 **有符号整数** 加减结果有溢出，则 OF＝1，否则 OF＝0；

> 对于程序员，无符号数关心进位，有符号数关心溢出，相同符号数相加后符号相反（如正+正=负），则有溢出；
>
> 对于处理器硬件判断，最高位和次高位同时进位或不进位，则无溢出；反之则有溢出；



##### 方向标志 DF（Direction Flag）

仅用于串操作指令，控制地址的变化方向：

1. 设置 DF＝0，每次串操作后的存储器地址就自动增加，即从低地址向高地址处理数据串；
2. 设置 DF＝1，每次串操作后的存储器地址就自动减少，即从高地址向低地址处理数据串；
3. 可以执行 CLD 指令设置 DF＝0；执行 STD 指令设置 DF＝1 ；



##### 中断允许标志 IF（Interrupt-enable Flag）

主要针对外中断中可屏蔽中断的开放或禁止：

1. 当 IF=1 时，CPU 允许响应可屏蔽中断，中断当前程序，转去执行中断处理程序；
2. 当 IF＝0 时，则不允许响应可屏蔽中断；
3. 可以执行 STI 指令设置 IF = 1；执行 CLI 指令设置 IF = 0；



##### 追踪标志 TF（Trace Flag）

用于单步调试程序：

1. 当 TF=1 时，在执行完一条指令后，产生单步中断；这在DEBUG调试程序状态下，可以使指令单步运行，可逐一检查各寄存器内容，标志状态、存储器的检查或修改等等；
2. TF=1 时为调试程序时所用，当程序调试成功后让 TF=0，CPU正常工作不产生单步中断；



### 2.3 存储器地址

#### 存储器的组织：8086 实模式

采用分段方式，20位的物理地址 由 **16位的段地址** 和 **16位的偏移地址** 形成，每个段的最大寻址空间为 64KB；

段地址必须是 16 的倍数，即（二进制写法）末尾 4 位必须为 0；



#### 存储单元的内容

课件记为存储地址加括号”( )” ，编程时用 []；

X 单元中存放着 Y，而 Y 是另一个存储单元的地址，则 Y 单元的内容表示为 (Y) = ((X))；

字单元由**两个字节单元**组成，其地址采用它的低地址来表示；

字存入存储器：低位字节存入低地址单元，高位字节存入高地址单元；



#### 储存单元地址例题

<img src=".\media\储存单元地址例题.png" alt="image-20210908121210248" style="zoom:50%;" />



#### 储存器的分段

8086 的内部寄存器是 16 位，地址是 20 位，地址宽度大于字长，显然不能用16位的寄存器仅一次操作实现对 2^20^＝1M 字节单元的寻址；

- 20 根地址线，地址范围 00000H ~ FFFFFH （1MB）
- 机器字长 16 位，仅能表示地址范围  0000H ~ FFFFH（64KB)
- 物理地址：每一个存储单元有一个唯一的 20 位地址



为此引入存储器“分段”的概念，即把 1M 字节内存空间，分成最大 64KB 的段，每段可用 16 位寄存器进行寻址；



段地址：表示一个段的开始，段地址一般存在段寄存器；

偏移地址：在段内相对于段起始地址的偏移值；

逻辑地址：**段地址：偏移地址**



<img src=".\media\储存器的逻辑地址与物理地址.png" style="zoom:38%;" />



物理地址：每一个存储单元有一个唯一的 20 位地址，表示范围：00000H～FFFFFH；

物理地址形成：**段地址左移 4 位，再加上偏移地址值**；

<img src=".\media\物理地址的形成.png" style="zoom:38%;" />



- 逻辑地址的形式：指令操作数，指令间的相对地址
- 物理地址：MEM 的绝对地址
- 逻辑地址到物理地址的转换过程因 CPU 架构的不同而不同



##### 例：8086 逻辑地址与物理地址的转换

<img src=".\media\逻辑地址与物理地址的转换.png" style="zoom:38%;" />



> 这里左移的 4 位是二进制位；如果用十六进制表达地址就是左移一位；
>
> 左移 4 位还可以表达为乘以 16，即：**物理地址 = 段地址 × 16D + 偏移地址** （或 = 段地址 × 10H + 偏移地址）



例：设某操作数存放在数据段，DS = 250AH，数据所在单元的偏移地址 = 0204H；则该操作数所在单元的物理地址为（    ）；

解：此类题目会设坑，给出一堆寄存器，答题需要先找**哪个是段地址**，需要注意偏移地址和段基址对应关系；本题提示了操作数存放在数据段，所以 DS 就是段地址，得物理地址 = **252A4H**；



<img src=".\media\段寄存器分配.png" style="zoom:38%;" />



#### ※ 8086 缺省 16 位段 + 偏移寻址组合表

注意：当 BX/BP 与 SI/DI 组合作为偏移地址时，默认的段寄存器是 BX/BP 所在段的寄存器，而不是 SI/DI 所在段的寄存器；

一般程序中 **只给出偏移地址**，因此需要背这张表的默认对应关系，记 **偏移寄存器 → 段寄存器** 方向；

| 段寄存器  | 偏移寄存器            | 主要用途   |
| --------- | --------------------- | ---------- |
| CS 代码段 | IP                    | 指令寻址   |
| DS 数据段 | BX, DI, SI 或 16 位数 | 数据寻址   |
| SS 堆栈段 | SP 或 BP              | 堆栈寻址   |
| ES 附加段 | 串指令 DI             | 目标串寻址 |



#### 偏移地址的组成

16位有效地址

- EA＝基址寄存器＋变址寄存器＋位移量
  - 基址寄存器：BX 或 BP，**一般由基址寄存器决定哪个段寄存器作为段指针**
  - 变址寄存器：SI 或 DI
  - 位移量：8 或 16 位有符号值



## 3. 寻址方式

操作数寻址：获取操作数

指令寻址：控制指令跳转

### 3.1 操作数寻址

#### 8086 汇编指令格式

指令 = 操作码 + 操作数；

<img src=".\media\8086汇编指令格式.png" style="zoom:38%;" />

寻址方式：为取得操作数或指令地址所使用的方法

操作数寻址：与数据有关的寻址方式

指令寻址：与转移地址有关的寻址方式  

指令寻址分为顺序寻址（IP 一条指令接一条指令地顺序进行移动）和跳转寻址（下条指令的地址码不是由程序计数器给出，而是由本条指令给出）



#### 3 种数据寻址方式

##### 立即数寻址

<img src=".\media\立即数寻址.png" style="zoom:38%;" />

- 操作数直接存在 **指令** 中，即立即数（Immediate），用常量形式直接表达；
- 因此操作数存储在 **代码段（CS）**中；
- 注意：
  - 源操作数和目的操作数的 **字长必须一致**；例如 **MOV  AH, 3064H** 就是非法的；
  - 只能用于源操作数；



##### 寄存器寻址

例：**MOV  AX,  BX**

- 操作数在 CPU 的 **内部寄存器** 中；
- 不需要访问存储器，速度快；
- 注意：
  - 源操作数和目的操作数的 **字长必须一致**；例如 **MOV  AH (16 位), BX (8 位)** 是非法的；
  - 代码段寄存器 CS 不能用 MOV 指令改变（其他段寄存器都允许重新分配）；



##### 存储器寻址

- 有 5 种存储器寻址方式（见后文）
- 操作数在 **存储器** 中，用存储单元的地址表示；
- 编程时使用包含 **段寄存器** 和 **偏移地址** 的逻辑地址（一般只给出偏移地址）；
- 段寄存器指示段的基地址；
- 偏移地址由各种寻址方式计算，常被称为 **有效地址 EA**（Effective Address）；
- 一般情况下存储器地址由有效地址表示，段寄存器不用显式说明，数据在默认的段中；如果不使用默认段寄存器，则要用 **段超越指令前缀** 加以说明；



#### 段寄存器的默认和超越

| 访问存储器的方式   | 默认      | 偏移地址    | 可超越             |
| ------------------ | --------- | ----------- | ------------------ |
| 取指令             | 代码段 CS | IP          | 无                 |
| 堆栈操作           | 堆栈段 SS | SP          | 无                 |
| 一般数据访问       | 数据段 DS | 有效地址 EA | CS, ES, SS, FS, GS |
| BP 基址的寻址方式  | 堆栈段 SS | 有效地址 EA | CS, ES, SS, FS, GS |
| 串操作的源操作数   | 数据段 DS | SI          | CS, ES, SS, FS, GS |
| 串操作的目的操作数 | 附加段 ES | DI          | 无                 |



#### 5 种存储器寻址方式

做题注意一下哪边是高地址，哪边是低地址；

##### 直接寻址

例：**MOV CX，[2000H]**

- 指令中直接包含了操作数的有效地址 EA，在指令操作码之后；
- 默认段地址在DS寄存器中，即操作数的实际地址（物理地址）是 DS:EA ；
- 常用于存取变量；



##### 寄存器间接寻址

例： **MOV AX，[SI]**

- 操作数的有效地址 EA 存放在基址寄存器 BX 或变址寄存器 SI, DI 中，**不能放在 AX / CX / DX 中**；
- 操作数的段地址（数据处于哪个段）取决于 **选择哪一个间址寄存器**；
- 可以方便地对数组的元素或字符串的字符进行操作；
- 寄存器间接寻址没有说明存储单元类型；



##### 寄存器相对寻址

例： **MOV BX，NUM+[DI]** 

- 有效地址 EA 是 **寄存器内容与位移量之和**；
- 适用于数组、字符串、表格的操作；

<img src=".\media\寄存器相对寻址.png" style="zoom:38%;" />



例：计算寄存器相对寻址的有效地址

<img src=".\media\寄存器相对寻址例题.png" style="zoom:38%;" />



##### 基址变址寻址

例：**MOV AX，\[BX][SI]**

- 有效地址是基址寄存器和变址寄存器之和
- 适用于二维数组、字符串、表格的操作
- 必须是一个基址寄存器和一个变址寄存器的组合
  - MOV  AX,  \[BX][BP]    非法，这是两个基址寄存器
  - MOV  AX,  \[SI][DI]      非法，这是两个变址寄存器

<img src=".\media\基址变址寻址.png" style="zoom:48%;" />



##### 相对基址变址寻址

例：**MOV AX，MASK\[BX][SI]**

也可以写成 **MOV AX, [BX+SI+MASK]** 

或 **MOV AX, MASK[BX+SI]**

- 有效地址计算如下：

<img src=".\media\相对基址变址寻址.png" style="zoom:38%;" />



例：计算相对基址变址寻址的有效地址

<img src=".\media\相对基址变址寻址例题.png" style="zoom:38%;" />



### 3.2 指令寻址

#### 段内直接寻址

例： 

**JMP  NEAR PTR  NEXT**    近转移    -32768 ~ +32767，汇编时，位移量为16位

**JMP  SHORT  NEXT**          短转移    -128 ~ +127，汇编时，位移量为8位

- 转向的有效地址 = 当前 (IP) + 位移量 (8bit/16bit) ，其中位移量是**转向的有效地址与当前 IP 值之差**；



#### 段内间接寻址

<img src=".\media\段内间接寻址.png" style="zoom:48%;" />

- CS 不变，但 IP 变化；
- 转向的有效地址是一个寄存器或存储单元的内容；
- 可用除立即数以外的任何一种数据寻址方式得到；



#### 段间寻址

例：

**JMP  1234H:5678H** ；					 (CS) = 1234H ，(IP) = 5678H

**JMP dword ptr 内存地址单元**；	(CS) = (内存地址单元+2) ，(IP) = (内存地址单元) 

- 转向的有效地址是 XXXX:YYYY 形式



### 3.3 存储器寻址









