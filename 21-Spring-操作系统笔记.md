# 操作系统笔记

### 成绩构成

平时40% + 期末60% 

加分项：挑战性作业、研究性项目、各种随堂测试
扣分项：迟到早退一次扣1分，缺勤一次扣2分，3次缺勤取消考试资格，请假、免听除外（提前一天通知老师）

作业和实验迟交一天扣1分/40分，抄袭一次平时成绩扣10分/40分，发现两次取消考试资格。

## 1. 绪论

### 课程参考资料

- [教务处教学平台](http://jwc.bjtu.edu.cn)
  - 操作系统电子教材
  - 操作系统参考书
  - 最简操作系统 linux 0.11 相关资料
- 国外教学网站
  - http://www.scs.stanford.edu/11wi-cs140/
  - http://www.cs.cmu.edu/~410/
  - http://www.cs.berkeley.edu/~kubitron/courses/cs162-F10/

### 操作系统的作用

- 用作扩充机器（或虚拟机）
  - 在裸机上提供一个虚拟机抽象层，处理复杂多样的硬件，使计算机系统功能显著增强、使用更为方便
- 用户与计算机硬件系统之间的接口
  - 命令方式（操作系统外壳）：面向一般用户
    - 命令行/菜单式/命令脚本式/图形用户接口
  - 系统调用方式（操作系统内核）：面向程序开发人员
    - 形式上类似于过程调用，编制程序中使用
- 计算机系统资源的管理者
  - 管理对象：处理器、存储器、外围设备以及信息
  - 管理内容：资源的分配、回收和访问操作，共享、保护

### 操作系统的发展过程

#### 单道批处理系统

OS的前身，脱机输入/输出技术，解决人机矛盾、CPU和I/O速度不匹配问题，特征如下：

- 自动性。在顺利情况下，在磁带上的一批作业能自动地逐个地依次运行，而无需人工干预。
  顺序性。磁带上的各道作业是顺序地进入内存，各道作业的完成顺序与它们进入内存的顺序，在正常情况下应完全相同，亦即先调入内存的作业先完成。
  单道性。内存中仅有一道程序运行，即监督程序每次从磁带上只调入一道程序进入内存运行，当该程序完成或发生异常情况时，才换入其后继程序进入内存运行。

#### 多道批处理系统

<img src="media/image-20220303114744885.webp" alt="image-20220303114744885" style="zoom: 50%;" />

中断技术的引入为多道批处理提供了技术基础，主要优缺点如下：

- 资源利用率高。由于在内存中驻留了多道程序，它们共享资源，可保持资源处于忙碌状态，从而使各种资源得以充分利用。
- 系统吞吐量大。系统吞吐量是指系统在单位时间内所完成的总工作量。能提高吞吐量的主要原因可归结为：第一，CPU 和其它资源保持“忙碌”状态； 第二，仅当作业完成时或运行不下去时才进行切换，系统开销小。
- 平均周转时间长。作业的周转时间是指从作业进入系统开始，直至其完成并退出系统为止所经历的时间。在批处理系统中，由于作业要排队，依次进行处理，因而作业的周转时间较长，通常需几个小时，甚至几天。
- 无交互能力。用户一旦把作业提交给系统后，直至作业完成，用户都不能与自己的作业进行交互，这对修改和调试程序是极不方便的

#### 分时系统

分时系统与多道批处理系统相比，具有非常明显的不同特征，可以归纳成以下四个特点：

1. 多路性。允许在一台主机上同时联接多台联机终端，系统按分时原则为每个用户服务。宏观上，是多个用户同时工作，共享系统资源；而微观上，则是每个用户作业轮流运行一个时间片。多路性即同时性，它提高了资源利用率，降低了使用费用，从而促进了计算机更广泛的应用。
2. 独立性。每个用户各占一个终端，彼此独立操作，互不干扰。用户感觉是一人独占主机。
3. 及时性。用户的请求能在很短的时间内获得响应。此时间间隔是以人们所能接受的等待时间来确定的，通常仅为 1～3 秒钟。
4. 交互性。用户可通过终端与系统进行广泛的人机对话。其广泛性表现在：用户可以请求系统提供多方面的服务，如文件编辑、数据处理和资源共享等

#### 实时系统

实时系统有着与分时系统相似但并不完全相同的特点，下面从五个方面对这两种系统加以比较。

1. 多路性。实时信息处理系统也按分时原则为多个终端用户服务。实时控制系统的多路性则主要表现在系统周期性地对多路现场信息进行采集，以及对多个对象或多个执行机构进行控制。而分时系统中的多路性则与用户情况有关，时多时少。
2. 独立性。实时信息处理系统中的每个终端用户在向实时系统提出服务请求时，是彼此独立地操作，互不干扰；而实时控制系统中，对信息的采集和对对象的控制也都是彼此互不干扰。
3. 及时性。实时信息处理系统对实时性的要求与分时系统类似，都是以人所能接受的等待时间来确定的；而实时控制系统的及时性，则是以控制对象所要求的开始截止时间或完成截止时间来确定的，一般为秒级到毫秒级，甚至有的要低于 100 微秒。
4. 交互性。实时信息处理系统虽然也具有交互性，但这里人与系统的交互仅限于访问系统中某些特定的专用服务程序。它不像分时系统那样能向终端用户提供数据处理和资源共享等服务。
5. 可靠性。分时系统虽然也要求系统可靠，但相比之下，实时系统则要求系统具有高度的可靠性。因为任何差错都可能带来巨大的经济损失，甚至是无法预料的灾难性后果，所以在实时系统中，往往都采取了多级容错措施来保障系统的安全性及数据的安全性。

### 操作系统的基本特性

并发性和共享性

#### 并发 VS 并行

并行：在同一时刻发生

并发：在同一时间间隔内发生

#### 进程、线程

进程：

- 引入进程是为了使多个程序能**并发**执行；
- 进程是在系统中能独立运行并作为资源分配的基本单位，由一组机器指令、数据和堆栈等组成，多个进程之间可以并发执行和交换信息；
- 一个进程在运行时需要一定的资源，如 CPU、存储空间及 I/O 设备等；

线程：

- 通常在一个进程中可以包含若干个线程，它们可以利用进程所拥有的资源；
- 通常都是把进程作为**分配资源的基本单位**，而把线程作为**独立运行和独立调度的基本单位**；
- 由于线程比进程更小，基本上不拥有系统资源，调度开销小，能提高系统内多个程序间并发执行的程度；

实现资源共享的方式主要有两种：互斥共享方式、同时访问方式

### 微内核操作系统结构

微内核操作系统结构 (Micro Kernel) 即将操作系统中最基本的部分放入内核中，而把操作系统的绝大部分功能都放在微内核外面的一组服务器(进程)中实现

特征描述：

1. 足够小的内核，只实现与硬件紧密相关的处理，只实现一些较基本的功能，只为构建通用 OS 提供基础

2. 客户/服务器模式

3. 应用“机制与策略分离”原理

4. 采用面向对象技术，利用“对象”、“封装”和“继承”等概念

### 中断

中断可分为外部中断和内部中断

外部中断包括不可屏蔽中断和可屏蔽中断，内部中断包括陷入，故障，中止

## 2.  进程管理

进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位，操作系统把CPU资源分配给进程的过程就是调度

程序并发执行出现的问题：

1. 交替间断回来执行还能保持上次的状态

2. 失去封闭性

3. 计算结果不可再现

4. ……

### 进程控制块PCB

程序的仅仅是代码和数据组成的，而并发执行要求CPU需要保存指令指针寄存器，寄存器，堆栈等信息，因此切换时需要先保存 $CPU_i$ 的信息，然后加载 $CPU_j$ 的信息，再开始执行新的进程 $j$ ，这些数据就通过进程控制块PCB来存储

PCB是进程实体的一部分，拥有描述进程情况及控制进程运行所需的全部信息的记录性数据结构，常驻内存并存放于操作系统专门开辟的PCB区

### 进程的组成

<img title="" src="./media/进程的组成.webp" alt="loading-ag-19343" data-align="center" width="543">

### 进程的特征

* 结构特征：程序段、数据段及进程控制块

* 动态性：生命周期及“执行” 本质

* 并发性：共存于内存、宏观同时运行

* 异步性：推进相互独立、速度不可预知

* 独立性：调度、资源分配、运行

### 状态模型

#### 进程的三状态模型

* 就绪

* 执行

* 等待

#### 进程的五状态模型

* 新状态

* 终止状态

* 就绪

* 执行

* 等待

#### 引入挂起状态

<img title="" src="./media/引入挂起的进程状态图.webp" alt="" data-align="center" width="686">

* 新状态

* 就绪挂起状态

* 就绪状态

* 阻塞挂起状态

* 阻塞状态

* 运行状态

* 终止状态

### 进程图

描述进程家族关系的有向树，包括结点/有向边，用来描述父/子进程关系

### 创建和终止进程

需要创建进程的场景：用户登录、作业调度、提供服务、应用请求……

需要终止进程的场景：正常结束、异常结束、特权指令错、非法指令错、运行超时、等待超时、算术运算错、I/O故障、外界干预、父进程请求/终止……

##### Create()

1. 申请Pid,空白PCB
2. 为新进程的程序和数据及用户栈分配必要的内存空间
   所需内存大小问题
3. 初始化进程控制块
   自身/父进程标识符
   处理机状态/调度信息
4. 将新进程插入到就绪进程队列

##### Terminate()

1. 读取进程状态，若其正处于执行状态，应立即中止执行并设置调度标志为真
2. 终止其子进程
3. 资源归还
4. 释放PCB

### 阻塞和唤醒进程

需要阻塞进程的场景：请求系统服务但不能立即满足、启动某种操作且必须等操作完成之后才能继续执行、新数据尚未到达、无新工作可做

需要唤醒进程的场景：系统服务满足、操作完成、数据到达、新任务出现

##### Block()

1. 先立即停止执行，把进程控制块中的现行状态由“执行”改为阻塞，并将它插入到对应的阻塞队列中
2. 转调度程序进行重新调度，将处理机分配给另一就绪进程，并进行切换

##### Wakeup()

首先把被阻塞进程从等待该事件的阻塞进程队列中移出，将其PCB中的现行状态由阻塞改为就绪，然后再将该进程插入到就绪队列中

### 挂起和激活进程

##### Suspend()

1. 检查被挂进程现行状态并修改和插队
2. 复制PCB到指定区域
3. 若被挂进程正在执行则转向调度程序重新调度

##### Activate()

1. 检查进程现行状态并修改和插队
2. 若有新进程进入就绪队列且采用了抢占式调度策略，则检查和决定是否重新调度

### 系统调用中的进程控制

##### fork 系统调用（克隆）

* 创建子进程，父子进程代码共享。子进程复制父进程当前的所有其他上下文信息
  然后都从同一地方开始运行

* 0号（对换）进程 => 1号（始祖）进程

* 以1号进程为根创建其他进程，形成进程树。

##### exec 系统调用（变异）

* 改变进程原有代码（更新用户级上下文）

* 没有新的进程产生

##### exit 系统调用

* 实现进程自我终止
