# 操作系统笔记

### 成绩构成

平时40% + 期末60% 

加分项：挑战性作业、研究性项目、各种随堂测试
扣分项：迟到早退一次扣1分，缺勤一次扣2分，3次缺勤取消考试资格，请假、免听除外（提前一天通知老师）

作业和实验迟交一天扣1分/40分，抄袭一次平时成绩扣10分/40分，发现两次取消考试资格

## 1. 绪论

### 课程参考资料

- [教务处教学平台](http://jwc.bjtu.edu.cn)
  - 操作系统电子教材
  - 操作系统参考书
  - 最简操作系统 linux 0.11 相关资料
- 国外教学网站
  - http://www.scs.stanford.edu/11wi-cs140/
  - http://www.cs.cmu.edu/~410/
  - http://www.cs.berkeley.edu/~kubitron/courses/cs162-F10/

### 操作系统的作用

- 用作扩充机器（或虚拟机）
  - 在裸机上提供一个虚拟机抽象层，处理复杂多样的硬件，使计算机系统功能显著增强、使用更为方便
- 用户与计算机硬件系统之间的接口
  - 命令方式（操作系统外壳）：面向一般用户
    - 命令行/菜单式/命令脚本式/图形用户接口
  - 系统调用方式（操作系统内核）：面向程序开发人员
    - 形式上类似于过程调用，编制程序中使用
- 计算机系统资源的管理者
  - 管理对象：处理器、存储器、外围设备以及信息
  - 管理内容：资源的分配、回收和访问操作，共享、保护

### 操作系统的发展过程

#### 单道批处理系统

OS的前身，脱机输入/输出技术，解决人机矛盾、CPU和I/O速度不匹配问题，特征如下：

- 自动性。在顺利情况下，在磁带上的一批作业能自动地逐个地依次运行，而无需人工干预。
  顺序性。磁带上的各道作业是顺序地进入内存，各道作业的完成顺序与它们进入内存的顺序，在正常情况下应完全相同，亦即先调入内存的作业先完成。
  单道性。内存中仅有一道程序运行，即监督程序每次从磁带上只调入一道程序进入内存运行，当该程序完成或发生异常情况时，才换入其后继程序进入内存运行。

#### 多道批处理系统

<img src="media/image-20220303114744885.webp" alt="image-20220303114744885" style="zoom: 50%;" />

中断技术的引入为多道批处理提供了技术基础，主要优缺点如下：

- 资源利用率高。由于在内存中驻留了多道程序，它们共享资源，可保持资源处于忙碌状态，从而使各种资源得以充分利用。
- 系统吞吐量大。系统吞吐量是指系统在单位时间内所完成的总工作量。能提高吞吐量的主要原因可归结为：第一，CPU 和其它资源保持“忙碌”状态； 第二，仅当作业完成时或运行不下去时才进行切换，系统开销小。
- 平均周转时间长。作业的周转时间是指从作业进入系统开始，直至其完成并退出系统为止所经历的时间。在批处理系统中，由于作业要排队，依次进行处理，因而作业的周转时间较长，通常需几个小时，甚至几天。
- 无交互能力。用户一旦把作业提交给系统后，直至作业完成，用户都不能与自己的作业进行交互，这对修改和调试程序是极不方便的

#### 分时系统

分时系统与多道批处理系统相比，具有非常明显的不同特征，可以归纳成以下四个特点：

1. 多路性。允许在一台主机上同时联接多台联机终端，系统按分时原则为每个用户服务。宏观上，是多个用户同时工作，共享系统资源；而微观上，则是每个用户作业轮流运行一个时间片。多路性即同时性，它提高了资源利用率，降低了使用费用，从而促进了计算机更广泛的应用。
2. 独立性。每个用户各占一个终端，彼此独立操作，互不干扰。用户感觉是一人独占主机。
3. 及时性。用户的请求能在很短的时间内获得响应。此时间间隔是以人们所能接受的等待时间来确定的，通常仅为 1～3 秒钟。
4. 交互性。用户可通过终端与系统进行广泛的人机对话。其广泛性表现在：用户可以请求系统提供多方面的服务，如文件编辑、数据处理和资源共享等

#### 实时系统

实时系统有着与分时系统相似但并不完全相同的特点，下面从五个方面对这两种系统加以比较。

1. 多路性。实时信息处理系统也按分时原则为多个终端用户服务。实时控制系统的多路性则主要表现在系统周期性地对多路现场信息进行采集，以及对多个对象或多个执行机构进行控制。而分时系统中的多路性则与用户情况有关，时多时少。
2. 独立性。实时信息处理系统中的每个终端用户在向实时系统提出服务请求时，是彼此独立地操作，互不干扰；而实时控制系统中，对信息的采集和对对象的控制也都是彼此互不干扰。
3. 及时性。实时信息处理系统对实时性的要求与分时系统类似，都是以人所能接受的等待时间来确定的；而实时控制系统的及时性，则是以控制对象所要求的开始截止时间或完成截止时间来确定的，一般为秒级到毫秒级，甚至有的要低于 100 微秒。
4. 交互性。实时信息处理系统虽然也具有交互性，但这里人与系统的交互仅限于访问系统中某些特定的专用服务程序。它不像分时系统那样能向终端用户提供数据处理和资源共享等服务。
5. 可靠性。分时系统虽然也要求系统可靠，但相比之下，实时系统则要求系统具有高度的可靠性。因为任何差错都可能带来巨大的经济损失，甚至是无法预料的灾难性后果，所以在实时系统中，往往都采取了多级容错措施来保障系统的安全性及数据的安全性。

### 操作系统的基本特性

并发性和共享性

#### 并发 VS 并行

并行：在同一时刻发生

并发：在同一时间间隔内发生

#### 进程、线程

进程：

- 引入进程是为了使多个程序能**并发**执行；
- 进程是在系统中能独立运行并作为资源分配的基本单位，由一组机器指令、数据和堆栈等组成，多个进程之间可以并发执行和交换信息；
- 一个进程在运行时需要一定的资源，如 CPU、存储空间及 I/O 设备等；

线程：

- 通常在一个进程中可以包含若干个线程，它们可以利用进程所拥有的资源；
- 通常都是把进程作为**分配资源的基本单位**，而把线程作为**独立运行和独立调度的基本单位**；
- 由于线程比进程更小，基本上不拥有系统资源，调度开销小，能提高系统内多个程序间并发执行的程度；

实现资源共享的方式主要有两种：互斥共享方式、同时访问方式

### 微内核操作系统结构

微内核操作系统结构 (Micro Kernel) 即将操作系统中最基本的部分放入内核中，而把操作系统的绝大部分功能都放在微内核外面的一组服务器(进程)中实现

特征描述：

1. 足够小的内核，只实现与硬件紧密相关的处理，只实现一些较基本的功能，只为构建通用 OS 提供基础

2. 客户/服务器模式

3. 应用“机制与策略分离”原理

4. 采用面向对象技术，利用“对象”、“封装”和“继承”等概念

### 中断

中断可分为外部中断和内部中断

外部中断包括不可屏蔽中断和可屏蔽中断，内部中断包括陷入，故障，中止

## 2.  进程管理

进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位，操作系统把CPU资源分配给进程的过程就是调度，引入进程的目的，就是为了能并发执行多个程序。

程序并发执行出现的问题：

1. 交替间断回来执行还能保持上次的状态

2. 失去封闭性

3. 计算结果不可再现

4. ……

### 进程控制块PCB

程序的仅仅是代码和数据组成的，而并发执行要求CPU需要保存指令指针寄存器，寄存器，堆栈等信息，因此切换时需要先保存 $CPU_i$ 的信息，然后加载 $CPU_j$ 的信息，再开始执行新的进程 $j$ ，这些数据就通过进程控制块PCB来存储

PCB是进程实体的一部分，拥有描述进程情况及控制进程运行所需的全部信息的记录性数据结构，常驻内存并存放于操作系统专门开辟的PCB区

#### 进程的组成

<img title="" src="media/进程的组成.webp" width="543">

#### 进程的特征

* 结构特征：程序段、数据段及进程控制块

* 动态性：生命周期及“执行” 本质

* 并发性：共存于内存、宏观同时运行

* 异步性：推进相互独立、速度不可预知

* 独立性：调度、资源分配、运行

### 进程的状态模型

#### 进程的三状态模型

* 就绪

* 执行

* 等待

#### 进程的五状态模型

* 新状态

* 终止状态

* 就绪

* 执行

* 等待

#### 引入挂起状态

<img title="" src="./media/引入挂起的进程状态图.webp" alt="" data-align="center" width="686">

* 新状态

* 就绪挂起状态

* 就绪状态

* 阻塞挂起状态

* 阻塞状态

* 运行状态

* 终止状态

#### 进程图

描述进程家族关系的有向树，包括结点/有向边，用来描述父/子进程关系

### 创建和终止进程

需要创建进程的场景：用户登录、作业调度、提供服务、应用请求……

需要终止进程的场景：正常结束、异常结束、特权指令错、非法指令错、运行超时、等待超时、算术运算错、I/O故障、外界干预、父进程请求/终止……

##### Create()

1. 申请Pid,空白PCB
2. 为新进程的程序和数据及用户栈分配必要的内存空间
   所需内存大小问题
3. 初始化进程控制块
   自身/父进程标识符
   处理机状态/调度信息
4. 将新进程插入到就绪进程队列

##### Terminate()

1. 读取进程状态，若其正处于执行状态，应立即中止执行并设置调度标志为真
2. 终止其子进程
3. 资源归还
4. 释放PCB

### 阻塞和唤醒进程

需要阻塞进程的场景：请求系统服务但不能立即满足、启动某种操作且必须等操作完成之后才能继续执行、新数据尚未到达、无新工作可做

需要唤醒进程的场景：系统服务满足、操作完成、数据到达、新任务出现

##### Block()

1. 先立即停止执行，把进程控制块中的现行状态由“执行”改为阻塞，并将它插入到对应的阻塞队列中
2. 转调度程序进行重新调度，将处理机分配给另一就绪进程，并进行切换

##### Wakeup()

首先把被阻塞进程从等待该事件的阻塞进程队列中移出，将其PCB中的现行状态由阻塞改为就绪，然后再将该进程插入到就绪队列中

### 挂起和激活进程

##### Suspend()

1. 检查被挂进程现行状态并修改和插队
2. 复制PCB到指定区域
3. 若被挂进程正在执行则转向调度程序重新调度

##### Activate()

1. 检查进程现行状态并修改和插队
2. 若有新进程进入就绪队列且采用了抢占式调度策略，则检查和决定是否重新调度

### 系统调用中的进程控制

##### fork 系统调用（克隆）

* 创建子进程，父子进程代码共享。子进程复制父进程当前的所有其他上下文信息
  然后都从同一地方开始运行

* 0号（对换）进程 => 1号（始祖）进程

* 以1号进程为根创建其他进程，形成进程树。

##### exec 系统调用（变异）

* 改变进程原有代码（更新用户级上下文）

* 没有新的进程产生

##### exit 系统调用

* 实现进程自我终止

### 进程同步

临界资源：一段时间内只允许一个进程访问的资源

临界区：每个进程中访问临界资源的那段代码称为临界区

如果共享该临界资源的每个进程能互斥的进入自己的临界区，就能保证对临界资源的互斥访问。
所有的（进程间）共享变量一般都应看做临界资源

#### 临界资源的互斥访问

加锁 → 关键代码执行 → 解锁

#### 软件互斥peterson算法

<img src="media/Peterson算法.webp" style="zoom:50%;"  >

#### 进程同步机制基本准则

1. 空闲让进（效率）：当无进程处于临界区时，可允许一个请求进入临界区的进程立即进入自己的临界区

2. 忙则等待（正确性）：当已有进程进入自己的临界区时，所有企图进入临界区的进程必须等待

3. 有限等待（公平性）：对要求访问临界资源的进程，应保证该进程能在有限时间内进入自己的临界区

4. 让权等待（效率）：当进程不能进入自己的临界区时，应释放处理机

### 信号量机制

用于实现进程互斥和前驱关系

#### 整型信号量

Dijkstra 把整型信号量定义为一个用于**表示资源数目的整型量** S，它与一般整型量不同，除初始化外，仅能通过两个标准的**原子操作**（**原语**，英文Atomic Operation）wait(S)和 signal(S)访问

> 原语是指**完成某种功能且不被分割不被中断执行的操作序列**；

**进程处于“忙等”的状态**

Wait(S)和 signal(S)操作可描述为：（也有些材料写的是P操作和V操作）

```go
wait(S):      
    while S<=0 
        do no-op;
    S := S-1;

signal(S):    
    S := S+1;
```

S值为正数：有S个临界资源可用

S值为0：临界资源全部已经被占用

S为负数：S的绝对值为等待使用该资源而被阻塞的进程数

用法伪代码：

```go
func:
    begin
        repeat
            wait(S);
            do_something();
            signal(S);
        until false;
    end
```



#### 记录型信号量

增加一个进程链表指针 L，用于链接上述所有等待进程

```go
type semaphore=record
    value: integer;
    L:     list of process;
    end

procedure wait(S)
    var S：semaphore;
    begin
        S.value:=S.value-1;
        if S.value<0 then block(S.L);
    end

procedure signal(S)
    var S: semaphore;
    begin
        S.value:=S.value+1;
        if S.value<=0 then wakeup(S.L);
    end
```

#### AND型信号量

对于多个进程要共享两个以上的资源的情况，普通信号量机制则可能导致发生死锁，例如哲学家进餐问题；

解决方案：

1. 若干个临界资源的分配采取原子方式。
2. 一次申请多种不同资源，若所有资源都有空闲资源，则分配；
2. 否则，一个资源都不分配。

例：假定现有两个进程 A 和 B，他们都要求访问共享数据 D 和 E，可为这两个数据分别设置用于互斥的信号量 Dmutex 和 Emutex，并令它们的初值都是 1，相应地，在两个进程中都要包含两个对 Dmutex 和 Emutex 的操作，即

```go
process A: 
    wait(Dmutex); 
    wait(Emutex); 

process B:
    wait(Emutex); 
    wait(Dmutex);
```

若进程 A 和 B 按下述次序交替执行 wait 操作：

```go
process A: wait(Dmutex);    // 于是 Dmutex=0
process B: wait(Emutex);    // 于是 Emutex=0
process A: wait(Emutex);    // 于是 Emutex=-1 A 阻塞
process B: wait(Dmutex);    // 于是 Dmutex=-1 B 阻塞
```

### 三类经典进程同步问题和解法

解题思路：

1. 分析临界资源以及对应的临界区
2. 分析资源和同步要求（互斥、先后、共享）
3. 一步一步加约束条件实现：

注意事项：

1. 信号量的合法操作只有初始化赋值，wait()，signal()，**不可以对信号量进行算术操作和逻辑判断**
2. 互斥关系靠进程内临界区前后成对 wait, signal 实现，先后关系靠 signal, wait 分别出现实现；
3. 注意不能颠倒 wait 和 signal 序列的操作顺序

#### 生产者-消费者问题

对资源设一个mutex互斥信号量，和一个记录资源数量的信号量；

生产者：等拿到互斥锁再放资源

消费者：等有资源，再加互斥锁取走；

------

随堂练习题的坑：图书馆占座的读者是一个进程，所以不是生产者消费者问题，~~不要学了之后看啥都是生产者和消费者问题~~

#### 哲学家进餐问题

~~为了预防幽门螺旋杆菌，请不要模仿这些哲学家的行为~~

重点在于防止死锁：

1. 只允许最多n-1个哲学家同时进餐，保证至少有一个哲学家可以同时拿到两支筷子
2. 仅当哲学家左右两支筷子均可使用时，才允许他拿筷进餐
3. 规定奇数号哲学家先拿左筷后拿右筷，而偶数号哲学家则相反
4. 筷子统一交给一个服务员分配，要吃饭向服务员申请……

作业2.10题有1.的实现，来自南京大学网课《操作系统：设计与实现》的这段代码是2.的情况

```c++
// 拿筷子
mutex_lock(&mutex);
while(!(avail[lhs] && avail[rhs]) ) {
	wait(&cv, &mutex);
}
avail[lhs] = avail[rhs] = false;
mutex_unlock(&mutex);

// 放筷子
mutex_lock(&mutex);
avail[lhs] = avail[rhs] = true;
broadcast(&cv)
mutex_unlock(&mutex);
```

#### 读者-写者问题

保证任何写者进程必须与其它进程互斥地访问共享数据对象（数据文件或记录）的问题

- 多个进程共享一个数据对象
- 只要求读操作的进程称为读者
- 包括写操作的进程称为写者

总结：读读可共存，读写和写写互斥；

##### 读者-写者问题的变量设计

- 写者进程与其它进程的互斥执行：写互斥信号量wmutex，初始值为1
- 读者进程之间的并发执行：读者进程计数变量readercount，表示正在执行的读者进程数量，初始值为0
- 读者进程计数变量的互斥访问：readercount对于多个读者进程而言是临界资源，应为之设置读互斥信号量rmutex，其初始值为1

```go
writer:
   begin
      repeat
         wait(wmutex);
         Perform write operation; 
         signal(wmutex);
      until false;
   end

reader:
   begin
      repeat
         wait(rmutex);
         if readercount=0 
		    then wait(wmutex);
		 readercount := readercount +1;
         signal(rmutex);
         Perform read operation;
         wait(rmutex);
         readercount := readercount -1;
         if readercount=0 then signal(wmutex);
         signal(rmutex);
      until false;
   end
```

### 管程

基于信号量的进程同步机制的弊端

- 访问临界资源的各进程均须自备同步操作
- 大量同步操作分散不利于系统管理
- 同步操作使用不当可能导致系统死锁

**对策：引入管程**

- 软硬件资源及操作抽象描述为管程
- 并发进程间的同步操作，分别集中于相应的管程中，由管程专职负责同步方案

```go
producer:
Var nextp: item;
   begin
      repeat
         produce an item in nextp;
         wait(empty);   wait(mutex);
         buffer[in] := nextp;   in := (in+1) mod n;
         signal(mutex);   signal(full);
      until false;
   end

consumer:
Var nextc: item;
   begin
      repeat
         wait(full);   wait(mutex);
         nextc := buffer[out];   out := (out+1) mod n;
         signal(mutex);   signal(empty); 
         consume the item in nextc;
      until false;
   end
```

### 进程间通信

- 共享存储器系统
  - 申请一块物理空间，不同进程虚拟空间映射到这块物理空间

- 管道通信系统
  - 利用一个文件通信，对文件按队列处理
  - 生产者-消费者模型
- 消息传递系统
  - 利用共享的内核空间中的消息列表通信

### 线程

- 一个进程中有一个或者多个线程

- 每个线程是进程中可独立调度执行代码段的一次执行过程。
- 同一个程序中的全局变量在各个线程中是共享的，但是线程之间的局部变量是完全独立的
- 资源是共享的：打开文件；信号量；进程空间
- 进程是资源分配的基本单位，线程是调度的基本单位

进程：程序级别的并发。一个程序和另一个程序是独立的并发执行体。
线程：函数级别的并发。在一个程序中有多个线程函数，这些函数可以独立并发执行。提高了并发度。

进程间隔离，线程可以共享所属进程下的资源

#### 同步机制总结

||信号量|线程锁<br>条件变量|管程|
|--------|----------------------|----------------------------------------|------------------------|
|互斥命令|wait(sem)<br/>signal(sem)|lock(mutex)<br>unlock(mutex)|monitor(object)|
|要求|先wait再signal|先lock再unlock|无|
|同步命令|wait(sem)<br/>signal(sem)|cond_wait(cond,mutex)<br/>cond_signal(cond)|mon_wait()<br/>mon_signal()|
|要求|无|无|无|

## 3. 处理机调度

### 多级调度

<img src="media/image-20220402113131289.webp" alt="image-20220402113131289" style="zoom:50%;" />

#### 高级调度（作业/长程/宏观调度）

- 概念：用于决定把外存上处于后备队列中的哪些作业接纳进入可执行的进程池，并为它们创建进程和分配必要资源；然后，再将新创建进程插入到就绪队列上准备执行
- 作业调度机制要领
  - 作业量确定：多道程序度(Degree of Multiprogramming)
  - 作业选择：调度算法

#### 中级调度（中程调度）

- 概念：为提高内存利用率和系统吞吐量，应使那些暂时不能运行的进程放弃占用内存资源，即调至外存上去等待；当内存稍有空闲时，可将外存中那些重又具备运行条件的就绪进程重新调入内存，修改其状态和挂到就绪进程队列等待进程调度
- 实质：存储器管理中的对换功能

#### 低级调度（进程/短程调度）

- 概念：用来决定就绪队列中的哪个进程将获得处理机，然后再由分派程序（Dispatcher）执行把处理机分配给该进程的具体操作
- 操作系统配置进程调度机制：基本调度，所有类型操作系统均需配置
- 调度方式分类
  - 非抢占方式（仅适用于批处理系统）
  - 抢占方式（分时、实时及批处理系统均可）

#### 非抢占与抢占调度方式比较

- 非抢占调度方式(Non-preemptive Mode)
  - 处理机分配给进程直至完成或阻塞
  - 引起进程调度的因素：当前进程执行完毕或因发生事件、提出I/O请求、执行原语操作而阻塞
  - 实现简单、系统开销小，但难以满足紧急任务要求，故不宜在实时系统中采用
- 抢占调度方式(Preemptive Mode)
  - 允许暂停正在执行进程和重新分配处理机
  - 抢占原则（优先权/短作业优先/时间片原则）

### 调度算法

- 先来先服务调度算法：等待时间长的优先
- 短进程优先调度算法：
  - （剩余）服务时间短的优先
  - 本教材默认的短进程优先算法为 **非抢占式调度**

- 高优先权优先调度算法：紧迫型作业优先
- 高响应比优先调度算法：
  - $响应比=1+ (\frac{等待时间}{要求服务时间})$
  - 每次选响应比最大的执行

- 时间片轮转调度算法：
  - 按先来先服务原则排队，**抢占式调度**
  - 时间片大小的确定：根据系统对响应时间的要求、就绪队列中进程的数目、系统的处理能力
- 多级队列调度算法（待补充）
- 多级反馈队列调度算法（待补充）

<img src="media/image-20220407103618608.png" alt="image-20220407103618608" style="zoom:50%;" />

#### 选择和评价算法

- 算法时间/空间复杂度
- 面向用户的准则
  - 周转时间短
    - 平均周转时间 $T=\frac{1}{n}[\sum_{i=1}^n T_i]$ 
    - 平均带权周转时间 $W=\frac{1}{n}[\sum_{i=1}^n \frac{T_i}{T_{S_i}}]$ （$\frac{T_i}{T_{S_i}}$ 即周转时间/服务时间）
  - 响应时间快
  - 截止时间的保证
  - 优先权准则
- 面向系统的准则
  - 系统吞吐量高
  - 处理机利用率好
  - 各类资源的平衡利用

### 死锁产生和处理

#### 概念

##### 死锁（Deadlock）

- 在多道程序系统中，并发执行的多个进程(线程)因争夺资源而造成的一种若无外力作用有关进程都将永远不能向前推进的僵持状态或僵局
- 在多道程序系统中，一组进程（线程）中的每一个进程都无限等待被同组的另外一个进程所占有且永远不会释放的资源的状态。

##### 饿死（Starvation）

- 资源不被一个进程永久占用的情况下，系统不能保证某个进程等待该资源的时间上界，从而使得该进程长时间等待该资源而无法在规定的时间完成
- 例如：短进程优先调度算法，不断有更短的进程到达时，长进程将永久等待而饿死。

##### 活锁（Livelock）

- 除了进程状态可能在不断改变外，与死锁类似没有一个进程能向前执行。
- 例如：哲学家都拿起左手的筷子，试图拿起右手的筷子不成，等待一段时间后都放下筷子又同时拿起左手的筷子。

#### 资源分配图 RAG

<img src="media/image-20220411101702851.png" alt="image-20220411101702851" style="zoom: 33%;" />

#### 死锁产生的 4 个必要条件

1. 互斥条件：资源排它性使用，其他进程必须等待
2. 请求和保持条件：请求资源未果，进程虽阻塞但保持占有资源不放
3. 不剥夺条件：进程已获资源未使用完之前不能被剥夺
4. 环路等待条件：进程-资源环形链

#### 预防死锁

设置对程序代码在**申请资源环节**的限制，互斥条件是资源本身固有的，只要可以破坏产生死锁的其他3个必要条件之一，就可防止死锁的发生。

##### 一次性申请全部资源

- 优点：简单、安全且易于实现
- 缺点：全部资源一次申请，可能部分资源在很晚才会用到，资源浪费；
  如果一个将来才用的资源被其他进程占有，本进程也无法执行，进程延迟

##### 申请失败则释放所有资源：破坏“不剥夺”条件

- 优点：资源利用率提高
- 缺点：实现复杂，代价很大；
  要额外保证已经完成的部分工作不失效；
  反复地申请与释放资源、进程周转时间延长、系统吞吐量降低、系统开销增加，性能下降；

##### 按升序申请资源

- 优点：资源不是一次申请好，也不需要放弃已有资源，因此比前两种方法的资源利用率、系统吞吐量更好
- 缺点：编号小的后使用，资源浪费；
  编号排序有开销；
  编程者负担重，给程序员增加了过多限制；

#### 检测死锁

系统状态 S 为死锁状态的**充要条件**是，当且仅当该状态下的资源分配图 RAG 是**不可完全化简**的。

> 图的化简（图的归约）：代表所有进程存在按照化简次序的顺序执行的可能性，表明当前没有死锁。
> 不同的RAG化简的次序最后必定得到相同的最简图。
> 如果可以先化简P1也可以先化简P2，任意选择一个先化简不会导致是否“可完全化简”结论改变。

#### 避免死锁

**操作系统**在进程提出资源申请后、进行**资源分配**之前，验证是否能满足本次请求，当系统不会进入死锁状态时，才可分配，否则予以拒绝。

##### 死锁与安全状态的关系

在安全状态下，一定没有死锁；

如果死锁，则一定不是安全状态；

##### 银行家算法

- 检查初始状态是否安全状态：每个进程的资源申请最大数都不超过系统资源数。
- 每次进程申请资源，操作系统收到申请后分配资源前都进行检查；
  - 假设分配后进入安全状态，就分配。
  - 假设分配后进入不安全状态，就不予分配。

#### 解除死锁

- 基本方法：抢夺其它进程的的资源给死锁进程，撤消死锁进程（逐个撤销直到N-1个撤销）
- 死锁解除策略评价指标：为解除死锁所需撤消的进程数目最小，撤消死锁进程所付出的代价最小
